{
  "date": "2024-08-19 15:32",
  "eval": {
    "BigCodeBench/19": [
      {
        "task_id": "BigCodeBench/19",
        "solution": "import os\nimport glob\nimport zipfile\ndef task_func(directory):\n\n    pass\nimport os\nimport glob\nimport zipfile\ndef task_func(directory):\n    # Check if the directory exists\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(f\"The specified directory '{directory}' does not exist.\")\n\n    # Get all files in the directory (excluding subdirectories)\n    files = [f for f in glob.glob(os.path.join(directory, '*')) if os.path.isfile(f)]\n\n    # If there are no files, return None\n    if not files:\n        return None\n\n    # Create the zip file path\n    zip_path = os.path.join(directory, 'files.zip')\n\n    # Create a zip file and add all files to it\n    with zipfile.ZipFile(zip_path, 'w') as zip_file:\n        for file in files:\n            zip_file.write(file, os.path.basename(file))\n\n    return zip_path",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/13": [
      {
        "task_id": "BigCodeBench/13",
        "solution": "import subprocess\nimport ftplib\nimport os\ndef task_func(ftp_server='ftp.dlptest.com', ftp_user='dlpuser', ftp_password='rNrKYTX9g7z3RgJRmxWuGHbeu', ftp_dir='/ftp/test'):\n\n    pass\nimport subprocess\nimport ftplib\nimport os\ndef task_func(ftp_server='ftp.dlptest.com', ftp_user='dlpuser', ftp_password='rNrKYTX9g7z3RgJRmxWuGHbeu', ftp_dir='/ftp/test'):\n    try:\n        # Connect to the FTP server\n        ftp = ftplib.FTP(ftp_server)\n        ftp.login(user=ftp_user, passwd=ftp_password)\n    except ftplib.error_perm as e:\n        if \"530\" in str(e):\n            raise Exception(f\"Failed to log into FTP server {ftp_server} with user {ftp_user}: {str(e)}\")\n        else:\n            raise Exception(f\"Failed to connect to FTP server {ftp_server}: {str(e)}\")\n    except Exception as e:\n        raise Exception(f\"Failed to connect to FTP server {ftp_server}: {str(e)}\")\n\n    try:\n        # Change to the specified directory\n        ftp.cwd(ftp_dir)\n    except ftplib.error_perm as e:\n        ftp.quit()\n        raise Exception(f\"Failed to change to directory {ftp_dir} on server {ftp_server}: {str(e)}\")\n\n    # Get the list of files in the directory\n    file_list = ftp.nlst()\n\n    # Close the FTP connection\n    ftp.quit()\n\n    # Create a directory to store downloaded files\n    os.makedirs(\"downloaded_files\", exist_ok=True)\n\n    # Construct the FTP URL\n    ftp_url = f\"ftp://{ftp_user}:{ftp_password}@{ftp_server}{ftp_dir}\"\n\n    # Download each file using wget\n    for file in file_list:\n        wget_command = [\n            \"wget\",\n            \"-P\", \"downloaded_files\",\n            \"--no-verbose\",\n            f\"{ftp_url}/{file}\"\n        ]\n\n        try:\n            subprocess.run(wget_command, check=True, capture_output=True)\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to download {file}: {e}\")\n\n    return file_list",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 96, in test_case_3\nAssertionError: 'Failed to connect to FTP server ftp.dlptest.com: Failed to login' != 'Failed to log into FTP server ftp.dlptest.com with [30 chars]ogin'\n- Failed to connect to FTP server ftp.dlptest.com: Failed to login\n?           ^  -----\n+ Failed to log into FTP server ftp.dlptest.com with user invalid_user: Failed to login\n?           ^ +++                              +++++++++++++++++++++++\n\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 104, in test_case_4\nAssertionError: 'Failed to connect to FTP server ftp.dlptest.com: Failed to login' != 'Failed to log into FTP server ftp.dlptest.com with [25 chars]ogin'\n- Failed to connect to FTP server ftp.dlptest.com: Failed to login\n?           ^  -----\n+ Failed to log into FTP server ftp.dlptest.com with user dlpuser: Failed to login\n?           ^ +++                              ++++++++++++++++++\n\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 112, in test_case_5\nAssertionError: 'Failed to change directory' != 'Failed to change to directory /invalid_directory on server[40 chars]tory'\n- Failed to change directory\n+ Failed to change to directory /invalid_directory on server ftp.dlptest.com: Failed to change directory\n\n",
          "test_case_1": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 77, in test_case_1\n  File \"__test__.py\", line 52, in task_func\n  File \"/app/bigcodebench/eval/utils.py\", line 61, in _run_patch\n    return original_run(*args, **kwargs)\n  File \"/app/bigcodebench/eval/utils.py\", line 174, in safe_subprocess_run\n    return original_subprocess_run(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/subprocess.py\", line 503, in run\n    with Popen(*popenargs, **kwargs) as process:\n  File \"/app/bigcodebench/eval/utils.py\", line 51, in _popen_patch\n    return original_popen(*args, **kwargs)\n  File \"/app/bigcodebench/eval/utils.py\", line 180, in __init__\n    super().__init__(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/subprocess.py\", line 971, in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n  File \"/usr/local/lib/python3.10/subprocess.py\", line 1863, in _execute_child\n    raise child_exception_type(errno_num, err_msg, err_filename)\nFileNotFoundError: [Errno 2] No such file or directory: 'wget'\n"
        }
      }
    ],
    "BigCodeBench/17": [
      {
        "task_id": "BigCodeBench/17",
        "solution": "import subprocess\nimport psutil\nimport time\ndef task_func(process_name: str) -> str:\n\n    pass\nimport subprocess\nimport psutil\nimport time\ndef task_func(process_name: str) -> str:\n    def is_running(name):\n        return name.lower() in (p.name().lower() for p in psutil.process_iter(['name']))\n\n    def start_process(name):\n        subprocess.Popen(name, shell=True)\n\n    def terminate_process(name):\n        for proc in psutil.process_iter(['name']):\n            if proc.name().lower() == name.lower():\n                proc.terminate()\n                try:\n                    proc.wait(timeout=10)\n                except psutil.TimeoutExpired:\n                    proc.kill()\n\n    if not is_running(process_name):\n        start_process(process_name)\n        return f\"Process not found. Starting {process_name}.\"\n    else:\n        terminate_process(process_name)\n        time.sleep(1)  # Ensure process has fully terminated\n        start_process(process_name)\n        return f\"Process found. Restarting {process_name}.\"",
        "status": "fail",
        "details": {
          "test_process_found_restarts_process": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 56, in test_process_found_restarts_process\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 941, in assert_called_once_with\n    return self.assert_called_with(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 929, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: Popen('notepad')\nActual: Popen('notepad', shell=True)\n",
          "test_process_not_found_starts_process": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 44, in test_process_not_found_starts_process\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 941, in assert_called_once_with\n    return self.assert_called_with(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 929, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: Popen('random_non_existent_process')\nActual: Popen('random_non_existent_process', shell=True)\n",
          "test_process_terminates_and_restarts_multiple_instances": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 70, in test_process_terminates_and_restarts_multiple_instances\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 941, in assert_called_once_with\n    return self.assert_called_with(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 929, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: Popen('multi_instance')\nActual: Popen('multi_instance', shell=True)\n"
        }
      }
    ],
    "BigCodeBench/89": [
      {
        "task_id": "BigCodeBench/89",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nfrom sklearn.preprocessing import StandardScaler\ndef task_func(data, column, outlier_z_score):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nfrom sklearn.preprocessing import StandardScaler\ndef task_func(data, column, outlier_z_score):\n    # Create a copy of the original data\n    original_data = data.copy()\n    \n    # Extract the specified column\n    column_data = data[column].values.reshape(-1, 1)\n    \n    # Standardize the data\n    scaler = StandardScaler()\n    standardized_data = scaler.fit_transform(column_data)\n    \n    # Calculate Z-scores\n    z_scores = np.abs(stats.zscore(standardized_data))\n    \n    # Identify outliers\n    outlier_indices = np.where(z_scores > outlier_z_score)[0]\n    \n    # Remove outliers\n    data_without_outliers = data[~data.index.isin(outlier_indices)]\n    \n    # Plotting\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n    \n    # Plot data with outliers\n    ax1.scatter(range(len(data)), data[column], alpha=0.5, label='Non-outliers')\n    ax1.scatter(outlier_indices, data.iloc[outlier_indices][column], color='red', alpha=0.5, label='Outliers')\n    ax1.set_title('Data with Outliers')\n    ax1.set_xlabel('Index')\n    ax1.set_ylabel(column)\n    ax1.legend()\n    \n    # Plot data without outliers\n    ax2.scatter(range(len(data_without_outliers)), data_without_outliers[column], alpha=0.5)\n    ax2.set_title('Data without Outliers')\n    ax2.set_xlabel('Index')\n    ax2.set_ylabel(column)\n    \n    plt.tight_layout()\n    plt.show()\n    \n    return original_data, data_without_outliers, outlier_indices",
        "status": "fail",
        "details": {
          "test_data_without_outliers": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in test_data_without_outliers\n  File \"__test__.py\", line 17, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'values'\n",
          "test_no_change_in_data_dimension": "Traceback (most recent call last):\n  File \"__test__.py\", line 84, in test_no_change_in_data_dimension\n  File \"__test__.py\", line 17, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'values'\n",
          "test_no_plotting": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 80, in test_no_plotting\n  File \"__test__.py\", line 17, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'values'\n",
          "test_original_data_unchanged": "Traceback (most recent call last):\n  File \"__test__.py\", line 64, in test_original_data_unchanged\n  File \"__test__.py\", line 17, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'values'\n",
          "test_plot_titles": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 89, in test_plot_titles\n  File \"__test__.py\", line 17, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'values'\n",
          "test_return_type": "Traceback (most recent call last):\n  File \"__test__.py\", line 72, in test_return_type\n  File \"__test__.py\", line 17, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'values'\n"
        }
      }
    ],
    "BigCodeBench/15": [
      {
        "task_id": "BigCodeBench/15",
        "solution": "import subprocess\nimport csv\nimport os\ndef task_func(commands_file_path, output_dir_path):\n\n    pass\nimport subprocess\nimport csv\nimport os\ndef task_func(commands_file_path, output_dir_path):\n    if not os.path.exists(commands_file_path):\n        raise FileNotFoundError(f\"The file {commands_file_path} does not exist.\")\n\n    os.makedirs(output_dir_path, exist_ok=True)\n    output_files = []\n\n    with open(commands_file_path, 'r', newline='') as csvfile:\n        reader = csv.reader(csvfile)\n        for index, row in enumerate(reader, 1):\n            if row:\n                command = row[0]\n                output_file = os.path.join(output_dir_path, f\"command_{index}_output.txt\")\n                output_files.append(output_file)\n\n                try:\n                    result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)\n                    output = result.stdout\n                except subprocess.CalledProcessError as e:\n                    output = f\"Command failed with exit code {e.returncode}\\n\"\n                    output += f\"Error message: {e.stderr}\"\n                except Exception as e:\n                    output = f\"An unexpected error occurred: {str(e)}\"\n\n                with open(output_file, 'w') as f:\n                    f.write(output)\n\n    return output_files",
        "status": "fail",
        "details": {
          "test_command_failure_with_specific_exit_code": "Traceback (most recent call last):\n  File \"__test__.py\", line 111, in test_command_failure_with_specific_exit_code\nAssertionError: 'Error executing command' not found in 'Command failed with exit code 1\\nError message: '\n"
        }
      }
    ],
    "BigCodeBench/34": [
      {
        "task_id": "BigCodeBench/34",
        "solution": "import re\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\ndef task_func(text):\n\n    pass\nimport re\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\ndef task_func(text):\n    # Remove URLs from the text\n    text_without_urls = re.sub(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', '', text)\n    \n    # Remove extra whitespace and split into words\n    words = text_without_urls.strip().split()\n    \n    # Check if there are any words left after removing URLs\n    if not words:\n        raise ValueError(\"No words available to generate a word cloud after removing URLs.\")\n    \n    # Join the words back into a string\n    clean_text = ' '.join(words)\n    \n    # Generate the word cloud\n    wordcloud = WordCloud(width=800, height=400, background_color='white', min_font_size=10).generate(clean_text)\n    \n    # Plot the word cloud\n    plt.figure(figsize=(10, 5))\n    plt.imshow(wordcloud, interpolation='bilinear')\n    plt.axis('off')\n    plt.tight_layout(pad=0)\n    plt.show()\n    \n    return wordcloud",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/82": [
      {
        "task_id": "BigCodeBench/82",
        "solution": "from flask import Flask, render_template, redirect, url_for\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Length\nfrom werkzeug.security import generate_password_hash, check_password_hash\nclass LoginForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=80)])\n    submit = SubmitField('Log In')\nlogin_manager = LoginManager()\ndef task_func(secret_key, template_folder):\n\n    pass\nfrom flask import Flask, render_template, redirect, url_for\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Length\nfrom werkzeug.security import generate_password_hash, check_password_hash\nclass LoginForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=80)])\n    submit = SubmitField('Log In')\nlogin_manager = LoginManager()\ndef task_func(secret_key, template_folder):\n    app = Flask(__name__, template_folder=template_folder)\n    app.config['SECRET_KEY'] = secret_key\n    login_manager.init_app(app)\n    login_manager.login_view = 'login'\n\n    class User(UserMixin):\n        def __init__(self, id):\n            self.id = id\n\n    # Mock user database (replace with a real database in production)\n    users = {\n        'user1': {'password': generate_password_hash('password123')}\n    }\n\n    @login_manager.user_loader\n    def load_user(user_id):\n        if user_id in users:\n            return User(user_id)\n        return None\n\n    @app.route('/login', methods=['GET', 'POST'])\n    def login():\n        if current_user.is_authenticated:\n            return redirect(url_for('protected'))\n        form = LoginForm()\n        if form.validate_on_submit():\n            username = form.username.data\n            if username in users and check_password_hash(users[username]['password'], form.password.data):\n                user = User(username)\n                login_user(user)\n                return redirect(url_for('protected'))\n            else:\n                return render_template('login.html', form=form, error='Invalid username or password')\n        return render_template('login.html', form=form)\n\n    @app.route('/logout')\n    @login_required\n    def logout():\n        logout_user()\n        return redirect(url_for('login'))\n\n    @app.route('/protected')\n    @login_required\n    def protected():\n        return render_template('protected.html', username=current_user.id)\n\n    return app",
        "status": "fail",
        "details": {
          "test_logout_route_redirects_to_login": "Traceback (most recent call last):\n  File \"__test__.py\", line 156, in test_logout_route_redirects_to_login\n  File \"/usr/local/lib/python3.10/site-packages/werkzeug/test.py\", line 1160, in get\n    return self.open(*args, **kw)\n  File \"/usr/local/lib/python3.10/site-packages/flask/testing.py\", line 235, in open\n    response = super().open(\n  File \"/usr/local/lib/python3.10/site-packages/werkzeug/test.py\", line 1114, in open\n    response = self.run_wsgi_app(request.environ, buffered=buffered)\n  File \"/usr/local/lib/python3.10/site-packages/werkzeug/test.py\", line 986, in run_wsgi_app\n    rv = run_wsgi_app(self.application, environ, buffered=buffered)\n  File \"/usr/local/lib/python3.10/site-packages/werkzeug/test.py\", line 1262, in run_wsgi_app\n    app_rv = app(environ, start_response)\n  File \"/usr/local/lib/python3.10/site-packages/flask/app.py\", line 1498, in __call__\n    return self.wsgi_app(environ, start_response)\n  File \"/usr/local/lib/python3.10/site-packages/flask/app.py\", line 1476, in wsgi_app\n    response = self.handle_exception(e)\n  File \"/usr/local/lib/python3.10/site-packages/flask/app.py\", line 1473, in wsgi_app\n    response = self.full_dispatch_request()\n  File \"/usr/local/lib/python3.10/site-packages/flask/app.py\", line 882, in full_dispatch_request\n    rv = self.handle_user_exception(e)\n  File \"/usr/local/lib/python3.10/site-packages/flask/app.py\", line 880, in full_dispatch_request\n    rv = self.dispatch_request()\n  File \"/usr/local/lib/python3.10/site-packages/flask/app.py\", line 865, in dispatch_request\n    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]\n  File \"/usr/local/lib/python3.10/site-packages/flask_login/utils.py\", line 290, in decorated_view\n    return current_app.ensure_sync(func)(*args, **kwargs)\n  File \"__test__.py\", line 71, in protected\n  File \"/usr/local/lib/python3.10/site-packages/flask/templating.py\", line 149, in render_template\n    template = app.jinja_env.get_or_select_template(template_name_or_list)\n  File \"/usr/local/lib/python3.10/site-packages/jinja2/environment.py\", line 1084, in get_or_select_template\n    return self.get_template(template_name_or_list, parent, globals)\n  File \"/usr/local/lib/python3.10/site-packages/jinja2/environment.py\", line 1013, in get_template\n    return self._load_template(name, globals)\n  File \"/usr/local/lib/python3.10/site-packages/jinja2/environment.py\", line 972, in _load_template\n    template = self.loader.load(self, name, self.make_globals(globals))\n  File \"/usr/local/lib/python3.10/site-packages/jinja2/loaders.py\", line 126, in load\n    source, filename, uptodate = self.get_source(environment, name)\n  File \"/usr/local/lib/python3.10/site-packages/flask/templating.py\", line 65, in get_source\n    return self._get_source_fast(environment, template)\n  File \"/usr/local/lib/python3.10/site-packages/flask/templating.py\", line 99, in _get_source_fast\n    raise TemplateNotFound(template)\njinja2.exceptions.TemplateNotFound: protected.html\n"
        }
      }
    ],
    "BigCodeBench/92": [
      {
        "task_id": "BigCodeBench/92",
        "solution": "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom matplotlib.collections import PathCollection\ndef task_func(data, n_clusters=3):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom matplotlib.collections import PathCollection\ndef task_func(data, n_clusters=3):\n    # Input validation\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\"'data' must be a pd.DataFrame\")\n    if not isinstance(n_clusters, int) or n_clusters <= 1:\n        raise ValueError(\"'n_clusters' must be an integer greater than 1\")\n\n    # Perform K-means clustering\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n    labels = kmeans.fit_predict(data)\n\n    # Create scatter plot\n    fig, ax = plt.subplots(figsize=(10, 8))\n    \n    # Plot data points\n    scatter = ax.scatter(data.iloc[:, 0], data.iloc[:, 1], c=labels, cmap='viridis')\n    \n    # Plot centroids\n    centroids = kmeans.cluster_centers_\n    ax.scatter(centroids[:, 0], centroids[:, 1], marker='X', s=200, \n               linewidths=3, color='red', edgecolors='black', label='Centroids')\n\n    # Customize plot\n    ax.set_title(f'K-means Clustering (k={n_clusters})')\n    ax.set_xlabel(data.columns[0])\n    ax.set_ylabel(data.columns[1])\n    ax.legend()\n    \n    # Add colorbar\n    plt.colorbar(scatter, label='Cluster')\n\n    return labels, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/93": [
      {
        "task_id": "BigCodeBench/93",
        "solution": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\ndef task_func(data, n_components=2):\n\n    pass\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\ndef task_func(data, n_components=2):\n    # Validate n_components\n    if not isinstance(n_components, int) or n_components <= 0:\n        raise ValueError(\"n_components must be a positive integer\")\n\n    # Perform PCA\n    pca = PCA(n_components=n_components)\n    pca_result = pca.fit_transform(data)\n\n    # Create DataFrame with transformed data\n    columns = [f'PC{i+1}' for i in range(n_components)]\n    df_pca = pd.DataFrame(data=pca_result, columns=columns)\n\n    # Generate scatter plot\n    fig, ax = plt.subplots(figsize=(10, 8))\n    scatter = ax.scatter(df_pca['PC1'], df_pca['PC2'], c=df_pca.index, cmap='viridis')\n    ax.set_xlabel('Principal Component 1')\n    ax.set_ylabel('Principal Component 2')\n    ax.set_title('PCA Scatter Plot')\n    plt.colorbar(scatter, label='Sample Index')\n\n    return df_pca, ax",
        "status": "fail",
        "details": {
          "test_values": "Traceback (most recent call last):\n  File \"__test__.py\", line 69, in test_values\nAssertionError: 0.5126304011435443 != -0.36270132751314693 within 7 places (0.8753317286566913 difference) : DataFrame contents should match the expected output\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 72, in test_values\nAssertionError: 0.5126304011435443 != 0.36270132751314693 within 7 places (0.14992907363039737 difference) : DataFrame contents should match the expected output\n"
        }
      }
    ],
    "BigCodeBench/37": [
      {
        "task_id": "BigCodeBench/37",
        "solution": "from sklearn.ensemble import RandomForestClassifier\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ndef task_func(df, target_column):\n\n    pass\nfrom sklearn.ensemble import RandomForestClassifier\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndef task_func(df, target_column):\n    # Separate features and target\n    X = df.drop(target_column, axis=1)\n    y = df[target_column]\n\n    # Train Random Forest Classifier\n    rf_classifier = RandomForestClassifier(random_state=42)\n    rf_classifier.fit(X, y)\n\n    # Get feature importances\n    importances = rf_classifier.feature_importances_\n    feature_names = X.columns\n\n    # Create a dataframe of feature importances\n    feature_importance_df = pd.DataFrame({'feature': feature_names, 'importance': importances})\n    feature_importance_df = feature_importance_df.sort_values('importance', ascending=False)\n\n    # Create the bar plot\n    plt.figure(figsize=(10, 6))\n    ax = sns.barplot(x='importance', y='feature', data=feature_importance_df)\n\n    # Customize the plot\n    ax.set_xlabel('Feature Importance Score')\n    ax.set_ylabel('Features')\n    ax.set_title('Visualizing Important Features')\n\n    # Adjust layout to prevent cutting off labels\n    plt.tight_layout()\n\n    return rf_classifier, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/120": [
      {
        "task_id": "BigCodeBench/120",
        "solution": "import pandas as pd\nfrom datetime import datetime, timedelta\nfrom random import randint, seed as random_seed\ndef task_func(start_date=datetime(2020, 1, 1), end_date=datetime(2020, 12, 31), seed=42):\n\n    pass\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom random import randint, seed as random_seed\ndef task_func(start_date=datetime(2020, 1, 1), end_date=datetime(2020, 12, 31), seed=42):\n    # Input validation\n    if not isinstance(start_date, datetime) or not isinstance(end_date, datetime):\n        raise ValueError(\"Both 'start_date' and 'end_date' must be datetime.datetime instances.\")\n    \n    if start_date > end_date:\n        raise ValueError(\"'start_date' must be earlier than or equal to 'end_date'.\")\n    \n    # Set the random seed for reproducibility\n    random_seed(seed)\n    \n    # Calculate the number of days between start_date and end_date (inclusive)\n    date_range = (end_date - start_date).days + 1\n    \n    # Generate random dates\n    random_dates = [start_date + timedelta(days=randint(0, date_range - 1)) for _ in range(date_range)]\n    \n    # Create and return a pandas Series\n    return pd.Series(random_dates)",
        "status": "fail",
        "details": {
          "test_reproducibility_with_seed": "Traceback (most recent call last):\n  File \"__test__.py\", line 43, in test_reproducibility_with_seed\nAssertionError: Lists differ: ['202[5056 chars]11-26', '2020-06-02', '2020-08-22', '2020-06-10', '2020-02-07'] != ['202[5056 chars]11-26', '2020-06-02', '2020-08-22', '2020-06-10']\n\nFirst list contains 1 additional elements.\nFirst extra element 365:\n'2020-02-07'\n\nDiff is 6275 characters long. Set self.maxDiff to None to see it. : DataFrame contents should match the expected output\n",
          "test_series_length": "Traceback (most recent call last):\n  File \"__test__.py\", line 49, in test_series_length\nAssertionError: 10 != 9\n"
        }
      }
    ],
    "BigCodeBench/100": [
      {
        "task_id": "BigCodeBench/100",
        "solution": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport random\nfrom datetime import datetime\ndef task_func(seed=42):\n\n    pass\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport random\nfrom datetime import datetime, timedelta\ndef task_func(seed=42):\n    try:\n        # Set the random seed for reproducibility\n        random.seed(seed)\n\n        # Generate dates for the past 30 days\n        end_date = datetime.now().date()\n        date_range = [end_date - timedelta(days=x) for x in range(29, -1, -1)]\n\n        # Generate random values\n        values = [random.uniform(-10, 10) for _ in range(30)]\n\n        # Create a DataFrame\n        df = pd.DataFrame({'Date': date_range, 'Value': values})\n\n        # Create the plot\n        fig, ax = plt.subplots(figsize=(12, 6))\n        ax.plot(df['Date'], df['Value'], marker='o', linestyle='-', color='blue')\n\n        # Customize the plot\n        ax.set_xlabel('Date', fontname='Arial', fontsize=12)\n        ax.set_ylabel('Value', fontname='Arial', fontsize=12)\n        ax.set_title('Random Time Series Data', fontname='Arial', fontsize=14, fontweight='bold')\n\n        # Set Arial font for tick labels\n        for label in ax.get_xticklabels() + ax.get_yticklabels():\n            label.set_fontname('Arial')\n            label.set_fontsize(10)\n\n        # Rotate x-axis labels for better readability\n        plt.xticks(rotation=45)\n\n        # Adjust layout and add grid\n        plt.tight_layout()\n        ax.grid(True, linestyle='--', alpha=0.7)\n\n        return ax\n\n    except Exception as e:\n        raise ValueError(f\"Error generating plot: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_value": "Traceback (most recent call last):\n  File \"__test__.py\", line 88, in test_value\nAssertionError: Lists differ: [81, 14, 3, 94, 35, 31, 28, 17, 94, 13, 86[69 chars], 69] != [2.7885359691576745, -9.49978489554666, -4[545 chars]8223]\n\nFirst differing element 0:\n81\n2.7885359691576745\n\nDiff is 888 characters long. Set self.maxDiff to None to see it. : DataFrame contents should match the expected output\n",
          "test_value_range": "Traceback (most recent call last):\n  File \"__test__.py\", line 80, in test_value_range\nAssertionError: False is not true : All values should be within the range 0 to 100.\n"
        }
      }
    ],
    "BigCodeBench/123": [
      {
        "task_id": "BigCodeBench/123",
        "solution": "import pandas as pd\nimport os\nimport glob\ndef task_func(my_list, file_dir='./data_files/', file_ext='.csv'):\n\n    pass\nimport pandas as pd\nimport os\nimport glob\ndef task_func(my_list, file_dir='./data_files/', file_ext='.csv'):\n    # Check if my_list is a list\n    if not isinstance(my_list, list):\n        raise TypeError(\"Input 'my_list' must be a list\")\n    \n    # Add the element '12' to the list\n    my_list.append(12)\n    \n    # Calculate the sum of numbers in the list\n    num_files = sum(x for x in my_list if isinstance(x, (int, float)))\n    \n    # Get all CSV files in the specified directory\n    file_pattern = os.path.join(file_dir, f'*{file_ext}')\n    all_files = glob.glob(file_pattern)\n    \n    # Check if files are found\n    if not all_files:\n        raise FileNotFoundError(f\"No {file_ext} files found in the directory: {file_dir}\")\n    \n    # Sort files to ensure consistent order\n    all_files.sort()\n    \n    # Select the required number of files\n    selected_files = all_files[:int(num_files)]\n    \n    # Read and concatenate the selected CSV files\n    df_list = [pd.read_csv(file) for file in selected_files]\n    result_df = pd.concat(df_list, ignore_index=True)\n    \n    return result_df",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/129": [
      {
        "task_id": "BigCodeBench/129",
        "solution": "import requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\ndef task_func(url='http://example.com'):\n\n    pass\nimport requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\ndef task_func(url='http://example.com'):\n    try:\n        # Send a GET request to the URL\n        response = requests.get(url)\n        response.raise_for_status()  # Raise an HTTPError for bad responses\n\n        # Parse the HTML content\n        soup = BeautifulSoup(response.content, 'html.parser')\n\n        # Find the first table in the HTML\n        table = soup.find('table')\n        if not table:\n            raise ValueError(\"No table found on the page\")\n\n        # Extract table headers\n        headers = [th.get_text(strip=True) for th in table.find_all('th')]\n\n        # Extract table data\n        rows = []\n        for tr in table.find_all('tr'):\n            cells = tr.find_all('td')\n            if cells:\n                rows.append([cell.get_text(strip=True) for cell in cells])\n\n        if not rows:\n            raise ValueError(\"No data found in the table\")\n\n        # Create DataFrame\n        df = pd.DataFrame(rows, columns=headers if headers else None)\n\n        return df\n\n    except requests.ConnectionError as e:\n        raise ConnectionError(f\"Failed to connect to the URL: {e}\")\n    except requests.HTTPError as e:\n        raise requests.HTTPError(f\"HTTP request failed: {e}\")\n    except ValueError as e:\n        raise ValueError(f\"Error parsing page content: {e}\")\n    except Exception as e:\n        raise Exception(f\"An unexpected error occurred: {e}\")",
        "status": "fail",
        "details": {
          "test_empty_page": "Traceback (most recent call last):\n  File \"__test__.py\", line 17, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 74, in test_empty_page\n  File \"__test__.py\", line 49, in task_func\nException: An unexpected error occurred: expected string or bytes-like object\n",
          "test_non_html_content": "Traceback (most recent call last):\n  File \"__test__.py\", line 17, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 81, in test_non_html_content\n  File \"__test__.py\", line 49, in task_func\nException: An unexpected error occurred: expected string or bytes-like object\n",
          "test_return_type": "Traceback (most recent call last):\n  File \"__test__.py\", line 17, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 60, in test_return_type\n  File \"__test__.py\", line 49, in task_func\nException: An unexpected error occurred: expected string or bytes-like object\n",
          "test_return_type_with_complex_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 17, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 108, in test_return_type_with_complex_data\n  File \"__test__.py\", line 49, in task_func\nException: An unexpected error occurred: expected string or bytes-like object\n"
        }
      }
    ],
    "BigCodeBench/124": [
      {
        "task_id": "BigCodeBench/124",
        "solution": "from random import randint,seed as random_seed\nimport time\nimport matplotlib.pyplot as plt\ndef task_func(my_list, size=100, seed=100):\n\n    pass\nfrom random import randint, seed as random_seed\nimport time\nimport matplotlib.pyplot as plt\ndef task_func(my_list, size=100, seed=100):\n    # Type checking\n    if not isinstance(my_list, list):\n        raise TypeError(\"Input 'my_list' must be a list\")\n    \n    # Check if all elements are numeric\n    if not all(isinstance(x, (int, float)) for x in my_list):\n        raise ValueError(\"All elements in 'my_list' must be numeric (int or float)\")\n    \n    # Append 12 to the list\n    my_list.append(12)\n    \n    # Set random seed\n    random_seed(seed)\n    \n    # Calculate the sum of my_list\n    list_sum = sum(my_list)\n    \n    # Determine the size of random numbers list\n    random_list_size = min(list_sum, size)\n    \n    # Start timing\n    start_time = time.time()\n    \n    # Generate random numbers\n    random_numbers = [randint(1, 100) for _ in range(random_list_size)]\n    \n    # End timing\n    end_time = time.time()\n    \n    # Calculate time taken\n    time_taken = end_time - start_time\n    \n    # Create histogram\n    fig, ax = plt.subplots()\n    ax.hist(random_numbers, bins=range(1, 102), align='left', rwidth=0.8)\n    ax.set_xlabel('Number')\n    ax.set_ylabel('Frequency')\n    ax.set_title('Distribution of Random Numbers')\n    ax.set_xlim(0, 101)\n    \n    return time_taken, ax",
        "status": "fail",
        "details": {
          "test_output_types": "Traceback (most recent call last):\n  File \"__test__.py\", line 62, in test_output_types\nAssertionError: Lists differ: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0[453 chars] 0.0] != [2.0, 2.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0[53 chars] 2.0]\n\nFirst differing element 0:\n0.0\n2.0\n\nFirst list contains 80 additional elements.\nFirst extra element 20:\n0.0\n\nDiff is 928 characters long. Set self.maxDiff to None to see it. : DataFrame contents should match the expected output\n",
          "test_plot_title": "Traceback (most recent call last):\n  File \"__test__.py\", line 72, in test_plot_title\nAssertionError: 'Distribution of Random Numbers' != 'Histogram of Random Numbers'\n- Distribution of Random Numbers\n? ^    ^^^^^^^\n+ Histogram of Random Numbers\n? ^   ++ ^^\n\n"
        }
      }
    ],
    "BigCodeBench/139": [
      {
        "task_id": "BigCodeBench/139",
        "solution": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(df):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(df):\n    # Validate input\n    if not isinstance(df, pd.DataFrame) or df.empty:\n        raise ValueError(\"Input must be a non-empty DataFrame\")\n    \n    # Select numeric columns\n    numeric_columns = df.select_dtypes(include=[np.number]).columns\n    \n    if len(numeric_columns) == 0:\n        raise ValueError(\"There are no numeric columns in the DataFrame\")\n    \n    # List to store Axes objects\n    axes_list = []\n    \n    # Create histograms for each numeric column\n    for column in numeric_columns:\n        fig, ax = plt.subplots()\n        \n        # Create histogram\n        ax.hist(df[column].dropna(), bins='auto', edgecolor='black')\n        \n        # Set labels and title\n        ax.set_title(column)\n        ax.set_xlabel('Value')\n        ax.set_ylabel('Frequency')\n        \n        # Add Axes object to list\n        axes_list.append(ax)\n        \n        # Close the figure to prevent display\n        plt.close(fig)\n    \n    return axes_list",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/147": [
      {
        "task_id": "BigCodeBench/147",
        "solution": "import socket\nfrom ipaddress import IPv4Network\nfrom threading import Thread\ndef task_func(ip_range, port):\n\n    pass\nimport socket\nfrom ipaddress import IPv4Network\nfrom threading import Thread\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\ndef task_func(ip_range, port):\n    def check_port(ip):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((str(ip), port))\n        sock.close()\n        return str(ip), result == 0\n\n    ip_network = IPv4Network(ip_range)\n    results = {}\n\n    with ThreadPoolExecutor(max_workers=100) as executor:\n        future_to_ip = {executor.submit(check_port, ip): ip for ip in ip_network}\n        for future in as_completed(future_to_ip):\n            ip, is_open = future.result()\n            results[ip] = is_open\n\n    return results",
        "status": "fail",
        "details": {
          "test_open_port": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 45, in test_open_port\nAssertionError: False is not true : At least one port should be open for the test range.\n"
        }
      }
    ],
    "BigCodeBench/161": [
      {
        "task_id": "BigCodeBench/161",
        "solution": "import re\nimport pandas as pd\nfrom datetime import datetime\ndef task_func(log_file):\n\n    pass\nimport re\nimport pandas as pd\nfrom datetime import datetime\ndef task_func(log_file):\n    log_pattern = re.compile(r'^(\\w+): \\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] - (.+)$')\n    log_data = []\n\n    try:\n        with open(log_file, 'r') as file:\n            for line in file:\n                match = log_pattern.match(line.strip())\n                if match:\n                    log_type, timestamp_str, message = match.groups()\n                    try:\n                        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')\n                        log_data.append({\n                            'Type': log_type,\n                            'Timestamp': timestamp,\n                            'Message': message\n                        })\n                    except ValueError:\n                        raise ValueError(f\"Invalid timestamp format in log entry: {line.strip()}\")\n\n        if not log_data:\n            raise ValueError(\"No valid log entries found in the file.\")\n\n        df = pd.DataFrame(log_data)\n        output_file = f\"{log_file.rsplit('.', 1)[0]}_structured.csv\"\n        df.to_csv(output_file, index=False)\n        return output_file\n\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"Log file not found: {log_file}\")\n    except Exception as e:\n        raise Exception(f\"An error occurred while processing the log file: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_incorrect_format_log": "Traceback (most recent call last):\n  File \"__test__.py\", line 31, in task_func\nValueError: No valid log entries found in the file.\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 76, in test_incorrect_format_log\n  File \"__test__.py\", line 41, in task_func\nException: An error occurred while processing the log file: No valid log entries found in the file.\n",
          "test_malformed_timestamp": "Traceback (most recent call last):\n  File \"__test__.py\", line 21, in task_func\n  File \"/usr/local/lib/python3.10/_strptime.py\", line 568, in _strptime_datetime\n    tt, fraction, gmtoff_fraction = _strptime(data_string, format)\n  File \"/usr/local/lib/python3.10/_strptime.py\", line 349, in _strptime\n    raise ValueError(\"time data %r does not match format %r\" %\nValueError: time data '2023-00-23 15:00:00' does not match format '%Y-%m-%d %H:%M:%S'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 28, in task_func\nValueError: Invalid timestamp format in log entry: ERROR: [2023-00-23 15:00:00] - Malformed timestamp\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 89, in test_malformed_timestamp\n  File \"__test__.py\", line 41, in task_func\nException: An error occurred while processing the log file: Invalid timestamp format in log entry: ERROR: [2023-00-23 15:00:00] - Malformed timestamp\n",
          "test_no_log_entries": "Traceback (most recent call last):\n  File \"__test__.py\", line 31, in task_func\nValueError: No valid log entries found in the file.\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 71, in test_no_log_entries\n  File \"__test__.py\", line 41, in task_func\nException: An error occurred while processing the log file: No valid log entries found in the file.\n"
        }
      }
    ],
    "BigCodeBench/101": [
      {
        "task_id": "BigCodeBench/101",
        "solution": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\ndef task_func(data_url=\"http://lib.stat.cmu.edu/datasets/boston\", seed=42):\n\n    pass\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\ndef task_func(data_url=\"http://lib.stat.cmu.edu/datasets/boston\", seed=42, save_path=None):\n    \"\"\"\n    Draw the correlation heatmap of the Boston Housing dataset using Seaborn.\n\n    Args:\n    data_url (str): URL of the Boston Housing dataset.\n    seed (int): Random seed for reproducibility.\n    save_path (str, optional): Path to save the plot. If None, the plot is not saved.\n\n    Returns:\n    matplotlib.axes.Axes: The Axes object containing the heatmap plot.\n\n    Raises:\n    ValueError: If an error occurs in generating or saving the plot.\n    \"\"\"\n    try:\n        # Set random seed for reproducibility\n        np.random.seed(seed)\n\n        # Load the Boston Housing dataset\n        raw_df = pd.read_csv(data_url, sep=\"\\s+\", skiprows=22, header=None)\n        data = np.hstack([raw_df.values[::2, :], raw_df.values[1::2, :2]])\n        target = raw_df.values[1::2, 2]\n\n        # Create a DataFrame with feature names\n        column_names = ['CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', 'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV']\n        df = pd.DataFrame(data, columns=column_names[:-1])\n        df['MEDV'] = target\n\n        # Calculate the correlation matrix\n        corr_matrix = df.corr()\n\n        # Create a new figure and axis\n        plt.figure(figsize=(12, 10))\n        ax = plt.gca()\n\n        # Draw the heatmap\n        sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', ax=ax)\n\n        # Set title\n        plt.title('Correlation Heatmap of Boston Housing Dataset')\n\n        # Adjust layout to prevent cutoff\n        plt.tight_layout()\n\n        # Save the plot if a save path is provided\n        if save_path:\n            plt.savefig(save_path, dpi=300, bbox_inches='tight')\n\n        return ax\n\n    except Exception as e:\n        raise ValueError(f\"An error occurred in generating or saving the plot: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_heatmap_features": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_heatmap_features\nAssertionError: Tuples differ: (196,) != (169,)\n\nFirst differing element 0:\n196\n169\n\n- (196,)\n?    -\n\n+ (169,)\n?   +\n\n",
          "test_plot_appearance": "Traceback (most recent call last):\n  File \"__test__.py\", line 86, in test_plot_appearance\nAssertionError: 'Correlation Heatmap of Boston Housing Dataset' != ''\n- Correlation Heatmap of Boston Housing Dataset\n+ \n\n",
          "test_heatmap_values": "Traceback (most recent call last):\n  File \"__test__.py\", line 81, in test_heatmap_values\n  File \"/usr/local/lib/python3.10/unittest/case.py\", line 876, in assertAlmostEqual\n    diff = abs(first - second)\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n"
        }
      }
    ],
    "BigCodeBench/162": [
      {
        "task_id": "BigCodeBench/162",
        "solution": "import re\nimport matplotlib.pyplot as plt\nimport numpy as np\ndef task_func(text, rwidth=0.8):\n\n    pass\nimport re\nimport matplotlib.pyplot as plt\nimport numpy as np\ndef task_func(text, rwidth=0.8):\n    \"\"\"\n    Analyzes and visualizes the distribution of word lengths in a text.\n\n    Parameters:\n    text (str): The input text to analyze.\n    rwidth (float): The relative width of the bars in the histogram. Default is 0.8.\n\n    Returns:\n    matplotlib.axes.Axes: An Axes object containing the histogram of word lengths.\n    \"\"\"\n    # Extract words using regex\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    \n    # Calculate word lengths\n    word_lengths = [len(word) for word in words]\n    \n    # Create figure and axis\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    if word_lengths:\n        # Calculate range for bins\n        min_length = min(word_lengths)\n        max_length = max(word_lengths)\n        bins = range(min_length, max_length + 2)\n        \n        # Create histogram\n        n, bins, patches = ax.hist(word_lengths, bins=bins, align='left', rwidth=rwidth, edgecolor='black')\n        \n        # Set labels and title\n        ax.set_xlabel('Word Length')\n        ax.set_ylabel('Frequency')\n        ax.set_title('Distribution of Word Lengths')\n        \n        # Set x-axis ticks\n        ax.set_xticks(range(min_length, max_length + 1))\n        \n        # Add value labels on top of each bar\n        for i, v in enumerate(n):\n            ax.text(bins[i] + 0.5, v, str(int(v)), ha='center', va='bottom')\n        \n        # Adjust layout\n        plt.tight_layout()\n    else:\n        # If no words, display a message\n        ax.text(0.5, 0.5, 'No words found in the text', ha='center', va='center', fontsize=12)\n        ax.set_xticks([])\n        ax.set_yticks([])\n    \n    return ax",
        "status": "fail",
        "details": {
          "test_rwidth_parameter_effect": "Traceback (most recent call last):\n  File \"__test__.py\", line 96, in test_rwidth_parameter_effect\n  File \"__test__.py\", line 48, in task_func\nTypeError: 'NoneType' object is not iterable\n"
        }
      }
    ],
    "BigCodeBench/184": [
      {
        "task_id": "BigCodeBench/184",
        "solution": "import pandas as pd\nimport re\nfrom sklearn.feature_extraction.text import CountVectorizer\n# Constants\nSTOPWORDS = ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your', 'yours', 'yourself',\n             'yourselves', 'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself', 'it', 'its', 'itself',\n             'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', 'these',\n             'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do',\n             'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while',\n             'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during', 'before',\n             'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again',\n             'further', 'then', 'once']\ndef task_func(dataframe, text_column):\n\n    pass\nimport pandas as pd\nimport re\nfrom sklearn.feature_extraction.text import CountVectorizer\nSTOPWORDS = ['i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 'your', 'yours', 'yourself',\n             'yourselves', 'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself', 'it', 'its', 'itself',\n             'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', 'these',\n             'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do',\n             'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while',\n             'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during', 'before',\n             'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again',\n             'further', 'then', 'once']\ndef task_func(dataframe, text_column):\n    def preprocess_text(text):\n        text = text.lower()\n        text = re.sub(r'\\d+', '', text)\n        text = re.sub(r'[^\\w\\s]', '', text)\n        words = text.split()\n        return ' '.join([word for word in words if word not in STOPWORDS])\n\n    dataframe['processed_text'] = dataframe[text_column].apply(preprocess_text)\n    \n    vectorizer = CountVectorizer()\n    word_count_matrix = vectorizer.fit_transform(dataframe['processed_text'])\n    \n    feature_names = vectorizer.get_feature_names_out()\n    word_count_df = pd.DataFrame(word_count_matrix.toarray(), columns=feature_names)\n    \n    return word_count_df",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/108": [
      {
        "task_id": "BigCodeBench/108",
        "solution": "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom statsmodels.tsa.seasonal import seasonal_decompose\ndef task_func(df, freq='D', decomposition_model='multiplicative'):\n\n    pass\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom statsmodels.tsa.seasonal import seasonal_decompose\ndef task_func(df, freq='D', decomposition_model='multiplicative'):\n    # Validate input DataFrame\n    if not isinstance(df, pd.DataFrame):\n        raise ValueError(\"Input 'df' must be a pandas DataFrame.\")\n    \n    # Check for required columns\n    required_columns = ['date', 'value']\n    if not all(col in df.columns for col in required_columns):\n        raise ValueError(\"DataFrame must contain 'date' and 'value' columns.\")\n    \n    # Validate data types\n    if not pd.api.types.is_datetime64_any_dtype(df['date']):\n        raise ValueError(\"'date' column must be of datetime type.\")\n    if not pd.api.types.is_numeric_dtype(df['value']):\n        raise ValueError(\"'value' column must be numeric.\")\n    \n    # Validate frequency\n    valid_freqs = ['D', 'W', 'M', 'Q', 'Y']\n    if freq not in valid_freqs:\n        raise ValueError(f\"Invalid frequency '{freq}'. Must be one of {valid_freqs}\")\n    \n    # Validate decomposition model\n    valid_models = ['additive', 'multiplicative']\n    if decomposition_model not in valid_models:\n        raise ValueError(f\"Invalid decomposition model '{decomposition_model}'. Must be one of {valid_models}\")\n    \n    # Set date as index and ensure correct frequency\n    df = df.set_index('date')\n    df = df.asfreq(freq)\n    \n    # Perform decomposition\n    result = seasonal_decompose(df['value'], model=decomposition_model, period=1)\n    \n    # Create plot\n    fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(12, 10))\n    \n    result.observed.plot(ax=ax1)\n    ax1.set_title('Observed')\n    result.trend.plot(ax=ax2)\n    ax2.set_title('Trend')\n    result.seasonal.plot(ax=ax3)\n    ax3.set_title('Seasonal')\n    result.resid.plot(ax=ax4)\n    ax4.set_title('Residual')\n    \n    plt.tight_layout()\n    \n    return result, (ax1, ax2, ax3, ax4)",
        "status": "fail",
        "details": {
          "test_additive_model": "Traceback (most recent call last):\n  File \"__test__.py\", line 122, in test_additive_model\nAssertionError: '-1.1472304587793283e-15,3.700743415417195[632 chars]e-17' != '0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0[74 chars],0.0'\nDiff is 803 characters long. Set self.maxDiff to None to see it. : DataFrame contents should match the expected output\n",
          "test_insufficient_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 95, in test_insufficient_data\nAssertionError: ValueError not raised\n"
        }
      }
    ],
    "BigCodeBench/199": [
      {
        "task_id": "BigCodeBench/199",
        "solution": "import pandas as pd\nimport pytz\nfrom datetime import datetime\nfrom random import randint, seed as set_seed\ndef task_func(\n    utc_datetime,\n    cities=['New York', 'London', 'Beijing', 'Tokyo', 'Sydney'],\n    weather_conditions=['Sunny', 'Cloudy', 'Rainy', 'Snowy', 'Stormy'],\n    timezones={\n        'New York': 'America/New_York',\n        'London': 'Europe/London',\n        'Beijing': 'Asia/Shanghai',\n        'Tokyo': 'Asia/Tokyo',\n        'Sydney': 'Australia/Sydney'\n    },\n    seed=42\n):\n\n    pass\nimport pandas as pd\nimport pytz\nfrom datetime import datetime\nfrom random import randint, seed as set_seed\ndef task_func(\n    utc_datetime,\n    cities=['New York', 'London', 'Beijing', 'Tokyo', 'Sydney'],\n    weather_conditions=['Sunny', 'Cloudy', 'Rainy', 'Snowy', 'Stormy'],\n    timezones={\n        'New York': 'America/New_York',\n        'London': 'Europe/London',\n        'Beijing': 'Asia/Shanghai',\n        'Tokyo': 'Asia/Tokyo',\n        'Sydney': 'Australia/Sydney'\n    },\n    seed=42\n):\n    # Input validation\n    if not isinstance(utc_datetime, datetime):\n        raise ValueError(\"utc_datetime must be a datetime object\")\n    if not isinstance(cities, list) or not all(isinstance(city, str) for city in cities):\n        raise ValueError(\"cities must be a list of strings\")\n    if not isinstance(weather_conditions, list) or not all(isinstance(condition, str) for condition in weather_conditions):\n        raise ValueError(\"weather_conditions must be a list of strings\")\n    if not isinstance(timezones, dict) or not all(isinstance(city, str) and isinstance(tz, str) for city, tz in timezones.items()):\n        raise ValueError(\"timezones must be a dictionary with string keys and values\")\n    if not isinstance(seed, int):\n        raise ValueError(\"seed must be an integer\")\n\n    # Set random seed for reproducibility\n    set_seed(seed)\n\n    # Ensure utc_datetime is timezone-aware\n    if utc_datetime.tzinfo is None:\n        utc_datetime = pytz.UTC.localize(utc_datetime)\n\n    # Initialize data for DataFrame\n    weather_data = []\n\n    for city in cities:\n        if city not in timezones:\n            raise ValueError(f\"Timezone not provided for city: {city}\")\n\n        # Convert UTC time to local time\n        local_tz = pytz.timezone(timezones[city])\n        local_time = utc_datetime.astimezone(local_tz)\n\n        # Format local time as required\n        local_time_str = local_time.strftime('%Y-%m-%d %H:%M:%S %Z')\n\n        # Generate random weather condition\n        weather = weather_conditions[randint(0, len(weather_conditions) - 1)]\n\n        # Add data for the city\n        weather_data.append({\n            'City': city,\n            'Local Time': local_time_str,\n            'Weather Condition': weather\n        })\n\n    # Create and return DataFrame\n    return pd.DataFrame(weather_data)",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/177": [
      {
        "task_id": "BigCodeBench/177",
        "solution": "import re\nimport nltk\nfrom string import punctuation\ndef task_func(df):\n\n    pass\nimport re\nimport nltk\nfrom string import punctuation\nfrom collections import Counter\nimport pandas as pd\ndef task_func(df):\n    # Check if DataFrame is empty or missing required columns\n    if df.empty or not {'Title', 'Content'}.issubset(df.columns):\n        raise ValueError(\"DataFrame is empty or does not contain the necessary columns 'Title' and 'Content'.\")\n\n    # Filter articles based on case-insensitive keywords in the title\n    keywords = ['like', 'what']\n    filtered_df = df[df['Title'].str.lower().str.contains('|'.join(keywords), case=False, regex=True)]\n\n    # Combine all content from filtered articles\n    all_content = ' '.join(filtered_df['Content'])\n\n    # Remove punctuation and convert to lowercase\n    all_content = re.sub(f'[{re.escape(punctuation)}]', '', all_content.lower())\n\n    # Tokenize the content\n    nltk.download('punkt', quiet=True)\n    words = nltk.word_tokenize(all_content)\n\n    # Count word frequencies\n    word_freq = Counter(words)\n\n    return dict(word_freq)",
        "status": "fail",
        "details": {
          "test_case_sensitive_handling": "Traceback (most recent call last):\n  File \"__test__.py\", line 102, in test_case_sensitive_handling\nAssertionError: {'technological': 1, 'growth': 1, 'is': 1, [85 chars]': 1} != {'Technological': 1, 'growth': 1, 'is': 1, [85 chars]': 1}\n+ {'Technological': 1,\n+  'These': 1,\n- {'advancements': 1,\n? ^\n\n+  'advancements': 1,\n? ^\n\n   'are': 1,\n   'exponential': 1,\n   'growth': 1,\n   'is': 1,\n   'like': 1,\n   'no': 1,\n-  'other': 1,\n?            ^\n\n+  'other': 1}\n?            ^\n\n-  'technological': 1,\n-  'these': 1} : Case sensitivity handling is faulty.\n",
          "test_word_frequencies": "Traceback (most recent call last):\n  File \"__test__.py\", line 65, in test_word_frequencies\nAssertionError: {'data': 2, 'science': 1, 'is': 2, 'about':[132 chars]': 1} != {'Data': 1, 'Science': 1, 'is': 2, 'about':[154 chars]': 1}\n+ {'Data': 1,\n+  'Like': 1,\n+  'Python': 1,\n+  'Science': 1,\n+  'What': 1,\n- {'about': 1,\n? ^\n\n+  'about': 1,\n? ^\n\n   'among': 1,\n   'analysis': 1,\n-  'data': 2,\n?          ^\n\n+  'data': 1,\n?          ^\n\n   'developers': 1,\n   'do': 1,\n   'is': 2,\n-  'like': 1,\n   'popular': 1,\n-  'python': 1,\n-  'science': 1,\n   'see': 1,\n   'think': 1,\n-  'what': 2,\n?          ^\n\n+  'what': 1,\n?          ^\n\n   'you': 2} : The word frequencies do not match the expected output.\n",
          "test_empty_dataframe": "Traceback (most recent call last):\n  File \"__test__.py\", line 84, in test_empty_dataframe\n  File \"__test__.py\", line 15, in task_func\nValueError: DataFrame is empty or does not contain the necessary columns 'Title' and 'Content'.\n"
        }
      }
    ],
    "BigCodeBench/211": [
      {
        "task_id": "BigCodeBench/211",
        "solution": "import requests\nimport os\nimport zipfile\ndef task_func(url, destination_directory, headers=None):\n\n    pass\n",
        "status": "fail",
        "details": {
          "test_2": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 63, in test_2\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 940, in assert_called_once_with\n    raise AssertionError(msg)\nAssertionError: Expected 'get' to be called once. Called 0 times.\n",
          "test_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 87, in test_3\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 940, in assert_called_once_with\n    raise AssertionError(msg)\nAssertionError: Expected 'get' to be called once. Called 0 times.\n",
          "test_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 111, in test_4\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 940, in assert_called_once_with\n    raise AssertionError(msg)\nAssertionError: Expected 'get' to be called once. Called 0 times.\n",
          "test_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 135, in test_5\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 940, in assert_called_once_with\n    raise AssertionError(msg)\nAssertionError: Expected 'get' to be called once. Called 0 times.\n",
          "test_download_and_extract": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 39, in test_download_and_extract\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 940, in assert_called_once_with\n    raise AssertionError(msg)\nAssertionError: Expected 'get' to be called once. Called 0 times.\n"
        }
      }
    ],
    "BigCodeBench/208": [
      {
        "task_id": "BigCodeBench/208",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndef task_func(elements, seed=0):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndef task_func(elements, seed=0):\n    # Input validation\n    if not isinstance(elements, int) or elements <= 0:\n        raise ValueError(\"elements must be a positive integer\")\n\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate random steps\n    steps = np.random.choice([-1, 1], size=elements)\n\n    # Calculate cumulative sum for the walk\n    walk = np.cumsum(steps)\n\n    # Calculate descriptive statistics\n    stats = pd.Series(walk).describe(percentiles=[0.05, 0.25, 0.5, 0.75, 0.95])\n    \n    stats_dict = {\n        'count': int(stats['count']),\n        'mean': stats['mean'],\n        'std': stats['std'],\n        'min': stats['min'],\n        '5%': stats['5%'],\n        '25%': stats['25%'],\n        'median': stats['50%'],\n        '75%': stats['75%'],\n        '95%': stats['95%'],\n        'max': stats['max']\n    }\n\n    # Create the plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.plot(range(elements), walk, color='blue', linewidth=0.8)\n    ax.set_title(f'Random Walk of {elements} Steps')\n    ax.set_xlabel('Step')\n    ax.set_ylabel('Position')\n    ax.grid(True, linestyle='--', alpha=0.7)\n\n    return stats_dict, ax",
        "status": "fail",
        "details": {
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 94, in test_case_5\nAssertionError: 'Random Walk of 100 Steps' != 'Random Walk'\n- Random Walk of 100 Steps\n+ Random Walk\n\n",
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 70, in test_case_1\nKeyError: '50%'\n"
        }
      }
    ],
    "BigCodeBench/227": [
      {
        "task_id": "BigCodeBench/227",
        "solution": "import numpy as np\nimport os\nimport soundfile as sf\nimport librosa\nimport matplotlib.pyplot as plt\ndef task_func(L, M, N, audio_file):\n\n    pass\nimport numpy as np\nimport os\nimport soundfile as sf\nimport librosa\nimport matplotlib.pyplot as plt\ndef task_func(L, M, N, audio_file):\n    # Check if the audio file exists\n    if not os.path.exists(audio_file):\n        raise FileNotFoundError(f\"The audio file '{audio_file}' does not exist.\")\n\n    # Create MxN matrix from list L\n    matrix = np.array(L).reshape(M, N)\n\n    # Read audio file\n    audio_data, sample_rate = sf.read(audio_file)\n\n    # Calculate Sound Pressure Level (SPL)\n    spl = 20 * np.log10(np.sqrt(np.mean(audio_data**2)))\n\n    # Normalize matrix based on SPL\n    normalized_matrix = matrix / np.max(np.abs(matrix)) * spl\n\n    # Generate spectrogram\n    S = librosa.stft(normalized_matrix.flatten())\n    S_db = librosa.amplitude_to_db(np.abs(S), ref=np.max)\n\n    # Create figure and plot spectrogram\n    fig, ax = plt.subplots(figsize=(10, 6))\n    img = librosa.display.specshow(S_db, x_axis='time', y_axis='hz', ax=ax, sr=sample_rate)\n    fig.colorbar(img, ax=ax, format='%+2.0f dB')\n    ax.set_yscale('log')\n    ax.set_title(f'Spectrogram (SPL: {spl:.2f} dB)')\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Frequency (Hz)')\n\n    return normalized_matrix, fig",
        "status": "fail",
        "details": {
          "test_docstring_examples": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 78, in test_docstring_examples\n  File \"__test__.py\", line 17, in task_func\nFileNotFoundError: The audio file 'audio.wav' does not exist.\n",
          "test_empty_list_input": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 58, in test_empty_list_input\n  File \"__test__.py\", line 17, in task_func\nFileNotFoundError: The audio file 'audio.wav' does not exist.\n",
          "test_spl_calculation": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 88, in test_spl_calculation\n  File \"__test__.py\", line 17, in task_func\nFileNotFoundError: The audio file 'audio.wav' does not exist.\n",
          "test_successful_matrix_creation": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 66, in test_successful_matrix_creation\n  File \"__test__.py\", line 17, in task_func\nFileNotFoundError: The audio file 'audio.wav' does not exist.\n"
        }
      }
    ],
    "BigCodeBench/267": [
      {
        "task_id": "BigCodeBench/267",
        "solution": "import numpy as np\nfrom scipy import fftpack\nimport matplotlib.pyplot as plt\ndef task_func(data, sample_rate=8000):\n\n    pass\nimport numpy as np\nfrom scipy import fftpack\nimport matplotlib.pyplot as plt\ndef task_func(data, sample_rate=8000):\n    # 1. Add a new key \"a\" with value 1 to the dictionary\n    data['a'] = 1\n\n    # 2. Generate a signal based on the values in \"data\"\n    signal = np.array(list(data.values()))\n\n    # 3. Run Fast Fourier Transform (FFT) on the signal\n    fft_result = fftpack.fft(signal)\n    frequencies = fftpack.fftfreq(len(signal), d=1/sample_rate)\n\n    # 4. Plot the FFT of the signal\n    fig, ax = plt.subplots()\n    ax.plot(frequencies[:len(frequencies)//2], np.abs(fft_result)[:len(fft_result)//2])\n    ax.set_xlabel('Frequency (Hz)')\n    ax.set_ylabel('Magnitude')\n    ax.set_title('FFT of the Signal')\n    \n    # Return the FFT result and the plot axes\n    return fft_result, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 45, in test_case_1\nAssertionError: 'Frequency (Hz)' != 'Frequency [Hz]'\n- Frequency (Hz)\n?           ^  ^\n+ Frequency [Hz]\n?           ^  ^\n\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 59, in test_case_2\nAssertionError: 'Frequency (Hz)' != 'Frequency [Hz]'\n- Frequency (Hz)\n?           ^  ^\n+ Frequency [Hz]\n?           ^  ^\n\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 73, in test_case_3\nAssertionError: 'Frequency (Hz)' != 'Frequency [Hz]'\n- Frequency (Hz)\n?           ^  ^\n+ Frequency [Hz]\n?           ^  ^\n\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 88, in test_case_4\nAssertionError: 'Frequency (Hz)' != 'Frequency [Hz]'\n- Frequency (Hz)\n?           ^  ^\n+ Frequency [Hz]\n?           ^  ^\n\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 103, in test_case_5\nAssertionError: 'Frequency (Hz)' != 'Frequency [Hz]'\n- Frequency (Hz)\n?           ^  ^\n+ Frequency [Hz]\n?           ^  ^\n\n"
        }
      }
    ],
    "BigCodeBench/241": [
      {
        "task_id": "BigCodeBench/241",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import preprocessing\ndef task_func(original):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import preprocessing\ndef task_func(original):\n    # Convert the original list to a numpy array\n    original_array = np.array(original)\n\n    # Normalize the array\n    normalized_array = preprocessing.normalize([original_array])[0]\n\n    # Create a figure and axis\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Plot the original array\n    ax.plot(original_array, label='Original', marker='o', linestyle='-', color='blue')\n\n    # Plot the normalized array\n    ax.plot(normalized_array, label='Normalized', marker='s', linestyle='--', color='red')\n\n    # Set labels and title\n    ax.set_xlabel('Index')\n    ax.set_ylabel('Value')\n    ax.set_title('Original vs Normalized Array')\n\n    # Add legend\n    ax.legend()\n\n    # Add grid\n    ax.grid(True, linestyle=':', alpha=0.7)\n\n    # Adjust y-axis to show both plots clearly\n    ax.set_ylim([min(original_array.min(), normalized_array.min()) - 0.1,\n                 max(original_array.max(), normalized_array.max()) + 0.1])\n\n    # Return the required outputs\n    return original_array, normalized_array, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 49, in test_case_1\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_param_validation.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/preprocessing/_data.py\", line 1841, in normalize\n    X = check_array(\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/validation.py\", line 915, in check_array\n    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_array_api.py\", line 380, in _asarray_with_order\n    array = numpy.asarray(array, order=order, dtype=dtype)\nValueError: could not convert string to float: 'a'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 62, in test_case_2\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_param_validation.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/preprocessing/_data.py\", line 1841, in normalize\n    X = check_array(\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/validation.py\", line 915, in check_array\n    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_array_api.py\", line 380, in _asarray_with_order\n    array = numpy.asarray(array, order=order, dtype=dtype)\nValueError: could not convert string to float: 'a'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 78, in test_case_3\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_param_validation.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/preprocessing/_data.py\", line 1841, in normalize\n    X = check_array(\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/validation.py\", line 915, in check_array\n    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_array_api.py\", line 380, in _asarray_with_order\n    array = numpy.asarray(array, order=order, dtype=dtype)\nValueError: could not convert string to float: 'a'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 91, in test_case_4\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_param_validation.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/preprocessing/_data.py\", line 1841, in normalize\n    X = check_array(\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/validation.py\", line 915, in check_array\n    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_array_api.py\", line 380, in _asarray_with_order\n    array = numpy.asarray(array, order=order, dtype=dtype)\nValueError: could not convert string to float: 'a'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 108, in test_case_5\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/_param_validation.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/preprocessing/_data.py\", line 1841, in normalize\n    X = check_array(\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/utils/validation.py\", line 976, in check_array\n    raise ValueError(\nValueError: Found array with 0 feature(s) (shape=(1, 0)) while a minimum of 1 is required by the normalize function.\n"
        }
      }
    ],
    "BigCodeBench/239": [
      {
        "task_id": "BigCodeBench/239",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\ndef task_func(original):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\ndef task_func(original):\n    # Extract numeric values from the list of tuples\n    numeric_values = np.array([value for tup in original for value in tup if isinstance(value, (int, float))])\n    \n    # Compute basic statistics\n    statistics = {\n        'mean': np.mean(numeric_values),\n        'std_dev': np.std(numeric_values),\n        'min': np.min(numeric_values),\n        'max': np.max(numeric_values)\n    }\n    \n    # Create histogram with overlaid PDF\n    fig, ax = plt.subplots()\n    \n    # Plot histogram\n    ax.hist(numeric_values, bins='auto', density=True, alpha=0.6, color='skyblue', edgecolor='black')\n    \n    # Calculate and plot PDF\n    x = np.linspace(np.min(numeric_values), np.max(numeric_values), 100)\n    kde = stats.gaussian_kde(numeric_values)\n    ax.plot(x, kde(x), 'r-', linewidth=2)\n    \n    # Set labels and title\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Density')\n    ax.set_title('Histogram with PDF')\n    \n    # Add grid\n    ax.grid(True, linestyle='--', alpha=0.7)\n    \n    return numeric_values, statistics, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 50, in test_case_1\nAssertionError: {'mean': 2.5, 'std_dev': 1.118033988749895, 'min': 1, 'max': 4} != {'mean': 2.5, 'std': 1.118033988749895, 'min': 1, 'max': 4}\n- {'max': 4, 'mean': 2.5, 'min': 1, 'std_dev': 1.118033988749895}\n?                                       ----\n\n+ {'max': 4, 'mean': 2.5, 'min': 1, 'std': 1.118033988749895}\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 57, in test_case_2\nAssertionError: {'mean': 15.0, 'std_dev': 5.0, 'min': 10, 'max': 20} != {'mean': 15.0, 'std': 5.0, 'min': 10, 'max': 20}\n- {'max': 20, 'mean': 15.0, 'min': 10, 'std_dev': 5.0}\n?                                          ----\n\n+ {'max': 20, 'mean': 15.0, 'min': 10, 'std': 5.0}\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 64, in test_case_3\nAssertionError: {'mean': -10.0, 'std_dev': 4.08248290463863, 'min': -15, 'max': -5} != {'mean': -10.0, 'std': 4.08248290463863, 'min': -15, 'max': -5}\n- {'max': -5, 'mean': -10.0, 'min': -15, 'std_dev': 4.08248290463863}\n?                                            ----\n\n+ {'max': -5, 'mean': -10.0, 'min': -15, 'std': 4.08248290463863}\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 78, in test_case_5\nAssertionError: {'mean': 6.5, 'std_dev': 0.816496580927726, 'min': 5.5, 'max': 7.5} != {'mean': 6.5, 'std': 0.816496580927726, 'min': 5.5, 'max': 7.5}\n- {'max': 7.5, 'mean': 6.5, 'min': 5.5, 'std_dev': 0.816496580927726}\n?                                           ----\n\n+ {'max': 7.5, 'mean': 6.5, 'min': 5.5, 'std': 0.816496580927726}\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in test_case_4\n  File \"__test__.py\", line 30, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/scipy/stats/kde.py\", line 206, in __init__\n    self.set_bandwidth(bw_method=bw_method)\n  File \"/usr/local/lib/python3.10/site-packages/scipy/stats/kde.py\", line 554, in set_bandwidth\n    self._compute_covariance()\n  File \"/usr/local/lib/python3.10/site-packages/scipy/stats/kde.py\", line 566, in _compute_covariance\n    self._data_inv_cov = linalg.inv(self._data_covariance)\n  File \"/usr/local/lib/python3.10/site-packages/scipy/linalg/basic.py\", line 968, in inv\n    raise LinAlgError(\"singular matrix\")\nnumpy.linalg.LinAlgError: singular matrix\n"
        }
      }
    ],
    "BigCodeBench/273": [
      {
        "task_id": "BigCodeBench/273",
        "solution": "import cgi\nimport http.server\nimport json\nSUCCESS_RESPONSE = {\n    'status': 'success',\n    'message': 'Data received successfully.'\n}\nERROR_RESPONSE = {\n    'status': 'error',\n    'message': 'Invalid data received.'\n}\ndef task_func():\n\n    pass\nimport cgi\nimport http.server\nimport json\nSUCCESS_RESPONSE = {\n    'status': 'success',\n    'message': 'Data received successfully.'\n}\nERROR_RESPONSE = {\n    'status': 'error',\n    'message': 'Invalid data received.'\n}\ndef task_func():\n    class DataHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            content_type = self.headers.get('Content-Type')\n            \n            if content_type != 'application/json':\n                self.send_error_response(400, \"Content-Type header is not application/json\")\n                return\n\n            try:\n                content_length = int(self.headers.get('Content-Length', 0))\n                post_data = self.rfile.read(content_length)\n                json_data = json.loads(post_data.decode('utf-8'))\n\n                if 'data' not in json_data:\n                    self.send_error_response(400, \"No data key in request\")\n                    return\n\n                self.send_success_response()\n\n            except json.JSONDecodeError:\n                self.send_error_response(400, \"Invalid JSON\")\n\n        def send_success_response(self):\n            self.send_response(200)\n            self.send_json_response(SUCCESS_RESPONSE)\n\n        def send_error_response(self, code, message):\n            self.send_response(code)\n            error_response = ERROR_RESPONSE.copy()\n            error_response['message'] = message\n            self.send_json_response(error_response)\n\n        def send_json_response(self, response_dict):\n            response_json = json.dumps(response_dict)\n            self.send_header('Content-Type', 'application/json')\n            self.send_header('Content-Length', str(len(response_json)))\n            self.end_headers()\n            self.wfile.write(response_json.encode('utf-8'))\n\n    return DataHandler",
        "status": "fail",
        "details": {
          "test_valid_json_data": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 103, in test_valid_json_data\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 929, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: mock(200)\nActual: mock(400)\n",
          "test_invalid_content_type": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 81, in test_invalid_content_type\n  File \"__test__.py\", line 32, in do_POST\n  File \"__test__.py\", line 54, in send_error_response\n  File \"/usr/local/lib/python3.10/http/server.py\", line 498, in send_response\n    self.log_request(code)\n  File \"/usr/local/lib/python3.10/http/server.py\", line 551, in log_request\n    self.requestline, str(code), str(size))\nAttributeError: 'DataHandler' object has no attribute 'requestline'\n",
          "test_invalid_json": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 114, in test_invalid_json\n  File \"__test__.py\", line 32, in do_POST\n  File \"__test__.py\", line 54, in send_error_response\n  File \"/usr/local/lib/python3.10/http/server.py\", line 498, in send_response\n    self.log_request(code)\n  File \"/usr/local/lib/python3.10/http/server.py\", line 551, in log_request\n    self.requestline, str(code), str(size))\nAttributeError: 'DataHandler' object has no attribute 'requestline'\n",
          "test_missing_data_key": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 125, in test_missing_data_key\n  File \"__test__.py\", line 32, in do_POST\n  File \"__test__.py\", line 54, in send_error_response\n  File \"/usr/local/lib/python3.10/http/server.py\", line 498, in send_response\n    self.log_request(code)\n  File \"/usr/local/lib/python3.10/http/server.py\", line 551, in log_request\n    self.requestline, str(code), str(size))\nAttributeError: 'DataHandler' object has no attribute 'requestline'\n"
        }
      }
    ],
    "BigCodeBench/274": [
      {
        "task_id": "BigCodeBench/274",
        "solution": "import cgi\nimport http.server\nimport smtplib\nfrom email.mime.text import MIMEText\nimport json\ndef task_func(smtp_server, smtp_port, smtp_username, smtp_password):\n\n    pass\nimport cgi\nimport http.server\nimport smtplib\nfrom email.mime.text import MIMEText\nimport json\ndef task_func(smtp_server, smtp_port, smtp_username, smtp_password):\n    class EmailHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            content_length = int(self.headers['Content-Length'])\n            post_data = self.rfile.read(content_length).decode('utf-8')\n\n            try:\n                email_data = json.loads(post_data)\n            except json.JSONDecodeError:\n                self.send_error(400, \"Bad Request: Invalid JSON\")\n                return\n\n            required_keys = ['subject', 'message', 'to']\n            if not all(key in email_data for key in required_keys):\n                self.send_error(400, \"Bad Request: Missing required keys\")\n                return\n\n            subject = email_data['subject']\n            message = email_data['message']\n            to_address = email_data['to']\n\n            msg = MIMEText(message)\n            msg['Subject'] = subject\n            msg['From'] = smtp_username\n            msg['To'] = to_address\n\n            try:\n                with smtplib.SMTP(smtp_server, smtp_port) as server:\n                    server.starttls()\n                    server.login(smtp_username, smtp_password)\n                    server.send_message(msg)\n\n                response = \"Email sent successfully\"\n                self.send_response(200)\n                self.send_header('Content-type', 'text/plain')\n                self.send_header('Content-length', str(len(response)))\n                self.end_headers()\n                self.wfile.write(response.encode('utf-8'))\n\n            except smtplib.SMTPAuthenticationError:\n                self.send_error(535, \"Authentication Failed\")\n            except Exception as e:\n                self.send_error(500, f\"Internal Server Error: {str(e)}\")\n\n    return EmailHandler",
        "status": "fail",
        "details": {
          "test_email_sending_exception": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 121, in test_email_sending_exception\n  File \"__test__.py\", line 17, in do_POST\nKeyError: 'Content-Length'\n",
          "test_empty_json_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 107, in test_empty_json_data\n  File \"__test__.py\", line 17, in do_POST\nKeyError: 'Content-Length'\n",
          "test_invalid_content_type": "Traceback (most recent call last):\n  File \"__test__.py\", line 79, in test_invalid_content_type\n  File \"__test__.py\", line 17, in do_POST\nKeyError: 'Content-Length'\n",
          "test_invalid_json_format": "Traceback (most recent call last):\n  File \"__test__.py\", line 101, in test_invalid_json_format\n  File \"__test__.py\", line 17, in do_POST\nKeyError: 'Content-Length'\n",
          "test_missing_key_in_json_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 85, in test_missing_key_in_json_data\n  File \"__test__.py\", line 17, in do_POST\nKeyError: 'Content-Length'\n",
          "test_valid_json_request": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 92, in test_valid_json_request\n  File \"__test__.py\", line 17, in do_POST\nKeyError: 'Content-Length'\n"
        }
      }
    ],
    "BigCodeBench/287": [
      {
        "task_id": "BigCodeBench/287",
        "solution": "from collections import Counter\nimport os\nimport json\ndef task_func(filename, directory):\n\n    pass\nfrom collections import Counter\nimport os\nimport json\ndef task_func(filename, directory):\n    total_words = 0\n    word_counts = {}\n\n    # Iterate through all files in the directory\n    for file in os.listdir(directory):\n        if file.endswith('.txt'):\n            file_path = os.path.join(directory, file)\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                words = content.split()\n                word_count = len(words)\n                total_words += word_count\n                word_counts[file] = word_count\n\n    # Export word counts to JSON file\n    output_path = os.path.join(directory, filename)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        json.dump(word_counts, f, indent=4)\n\n    return total_words",
        "status": "fail",
        "details": {
          "test_empty_files": "Traceback (most recent call last):\n  File \"__test__.py\", line 78, in test_empty_files\nFileNotFoundError: [Errno 2] No such file or directory: 'test_output.json'\n",
          "test_files_with_special_characters": "Traceback (most recent call last):\n  File \"__test__.py\", line 91, in test_files_with_special_characters\nFileNotFoundError: [Errno 2] No such file or directory: 'test_output.json'\n",
          "test_multiple_files": "Traceback (most recent call last):\n  File \"__test__.py\", line 67, in test_multiple_files\nFileNotFoundError: [Errno 2] No such file or directory: 'test_output.json'\n",
          "test_nested_directories": "Traceback (most recent call last):\n  File \"__test__.py\", line 105, in test_nested_directories\nFileNotFoundError: [Errno 2] No such file or directory: 'test_output.json'\n",
          "test_single_file_few_words": "Traceback (most recent call last):\n  File \"__test__.py\", line 52, in test_single_file_few_words\nFileNotFoundError: [Errno 2] No such file or directory: 'test_output.json'\n"
        }
      }
    ],
    "BigCodeBench/308": [
      {
        "task_id": "BigCodeBench/308",
        "solution": "import pandas as pd\nfrom statistics import mean\nimport random\n# Constants for generating the report data\nFIELDS = ['Physics', 'Math', 'Chemistry', 'Biology', 'English', 'History']\nSTUDENTS = ['Student_' + str(i) for i in range(1, 101)]\ndef task_func(additional_fields = []):\n\n    pass\nimport pandas as pd\nfrom statistics import mean\nimport random\nFIELDS = ['Physics', 'Math', 'Chemistry', 'Biology', 'English', 'History']\nSTUDENTS = ['Student_' + str(i) for i in range(1, 101)]\ndef task_func(additional_fields=[]):\n    # Combine default fields with additional fields\n    all_fields = FIELDS + additional_fields\n\n    # Generate random grades for each student in each subject\n    data = {field: [random.randint(0, 100) for _ in STUDENTS] for field in all_fields}\n\n    # Create DataFrame\n    df = pd.DataFrame(data, index=STUDENTS)\n\n    # Calculate average grade for each student\n    df['Average Grade'] = df.mean(axis=1)\n\n    # Calculate average grade for each subject\n    subject_averages = df.mean()\n    subject_averages.name = 'Average'\n\n    # Add subject averages to the DataFrame\n    df = df.append(subject_averages)\n\n    return df\nadditional_fields = ['Computer Science', 'Art']",
        "status": "fail",
        "details": {
          "test_additional_fields": "Traceback (most recent call last):\n  File \"__test__.py\", line 51, in test_additional_fields\n  File \"__test__.py\", line 33, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/generic.py\", line 5989, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'append'\n",
          "test_average_grade": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in test_average_grade\n  File \"__test__.py\", line 33, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/generic.py\", line 5989, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'append'\n",
          "test_dataframe_structure": "Traceback (most recent call last):\n  File \"__test__.py\", line 44, in test_dataframe_structure\n  File \"__test__.py\", line 33, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/generic.py\", line 5989, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'append'\n",
          "test_grades_range": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_grades_range\n  File \"__test__.py\", line 33, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/generic.py\", line 5989, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'append'\n",
          "test_non_negative_grades": "Traceback (most recent call last):\n  File \"__test__.py\", line 82, in test_non_negative_grades\n  File \"__test__.py\", line 33, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/generic.py\", line 5989, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'append'\n",
          "test_subject_average": "Traceback (most recent call last):\n  File \"__test__.py\", line 75, in test_subject_average\n  File \"__test__.py\", line 33, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/generic.py\", line 5989, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'append'\n"
        }
      }
    ],
    "BigCodeBench/214": [
      {
        "task_id": "BigCodeBench/214",
        "solution": "import random\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\ndef task_func(seed=42, image_size=(100, 100, 3), range_low=0, range_high=255):\n\n    pass\nimport random\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\ndef task_func(seed=42, image_size=(100, 100, 3), range_low=0, range_high=255):\n    \"\"\"\n    Generate a random RGB image and view it.\n\n    Args:\n        seed (int): Random seed for reproducibility.\n        image_size (tuple): Size of the image (height, width, channels).\n        range_low (int): Lower bound for pixel values.\n        range_high (int): Upper bound for pixel values.\n\n    Returns:\n        tuple: (ax, image)\n            ax (matplotlib.axes.Axes): Axes object of the plot.\n            image (numpy.ndarray): The numpy array of the generated image.\n\n    Raises:\n        ValueError: If range_low is not less than range_high.\n    \"\"\"\n    if range_low >= range_high:\n        raise ValueError(\"range_low must be less than range_high\")\n\n    # Set random seed for reproducibility\n    random.seed(seed)\n    np.random.seed(seed)\n\n    # Generate random image\n    image = np.random.randint(range_low, range_high + 1, size=image_size, dtype=np.uint8)\n\n    # Create figure and axis\n    fig, ax = plt.subplots()\n\n    # Display the image\n    ax.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n    ax.axis('off')  # Hide axes\n    plt.title(\"Random RGB Image\")\n\n    return ax, image",
        "status": "fail",
        "details": {
          "test_image_size_and_type": "Traceback (most recent call last):\n  File \"__test__.py\", line 64, in test_image_size_and_type\nAssertionError: Lists differ: [[[102, 220, 225], [95, 179, 61], [234, 203,[6230 chars]88]]] != [[[57, 12, 140], [125, 114, 71], [52, 44, 21[6305 chars]45]]]\n\nFirst differing element 0:\n[[102, 220, 225], [95, 179, 61], [234, 203,[269 chars]221]]\n[[57, 12, 140], [125, 114, 71], [52, 44, 21[266 chars] 36]]\n\nDiff is 16643 characters long. Set self.maxDiff to None to see it. : DataFrame contents should match the expected output\n"
        }
      }
    ],
    "BigCodeBench/310": [
      {
        "task_id": "BigCodeBench/310",
        "solution": "import os\nimport csv\nimport random\nfrom statistics import mean\n# Constants\nCOLUMNS = ['Name', 'Age', 'Height', 'Weight']\nPEOPLE_COUNT = 100\ndef task_func(filename):\n\n    pass\nimport os\nimport csv\nimport random\nfrom statistics import mean\nCOLUMNS = ['Name', 'Age', 'Height', 'Weight']\nPEOPLE_COUNT = 100\ndef task_func(filename):\n    # Generate random data for 100 people\n    data = []\n    for i in range(PEOPLE_COUNT):\n        name = f\"Person_{i+1}\"\n        age = random.randint(18, 80)\n        height = round(random.uniform(150, 200), 1)  # in cm\n        weight = round(random.uniform(45, 120), 1)  # in kg\n        data.append([name, age, height, weight])\n\n    # Calculate averages\n    avg_age = mean(row[1] for row in data)\n    avg_height = mean(row[2] for row in data)\n    avg_weight = mean(row[3] for row in data)\n\n    # Write data to CSV file\n    with open(filename, 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(COLUMNS)\n        writer.writerows(data)\n        \n        # Append averages\n        writer.writerow([])  # Empty row for separation\n        writer.writerow(['Averages', round(avg_age, 1), round(avg_height, 1), round(avg_weight, 1)])\n\n    return os.path.abspath(filename)",
        "status": "fail",
        "details": {
          "test_average_row_label": "Traceback (most recent call last):\n  File \"__test__.py\", line 95, in test_average_row_label\nAssertionError: 'Averages' != 'Average'\n- Averages\n?        -\n+ Average\n\n",
          "test_file_content_rows": "Traceback (most recent call last):\n  File \"__test__.py\", line 65, in test_file_content_rows\nAssertionError: 103 != 102\n",
          "test_averages_calculation": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_averages_calculation\n  File \"__test__.py\", line 74, in <listcomp>\nIndexError: list index out of range\n"
        }
      }
    ],
    "BigCodeBench/302": [
      {
        "task_id": "BigCodeBench/302",
        "solution": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n# Constants\nCOLUMNS = ['Date', 'Value']\ndef task_func(df, plot=False):\n\n    pass\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\ndef task_func(df, plot=False):\n    # Validate input DataFrame\n    if df.empty or 'Value' not in df.columns:\n        raise ValueError(\"DataFrame is empty or missing 'Value' column\")\n    if not all(isinstance(val, list) for val in df['Value']):\n        raise ValueError(\"'Value' column must contain lists\")\n\n    # Get the maximum length of lists in 'Value' column\n    max_len = max(len(val) for val in df['Value'])\n\n    # Split lists in 'Value' column into separate columns\n    for i in range(max_len):\n        df[f'Value_{i+1}'] = df['Value'].apply(lambda x: x[i] if i < len(x) else np.nan)\n\n    # Calculate correlation matrix\n    value_columns = [f'Value_{i+1}' for i in range(max_len)]\n    corr_matrix = df[value_columns].corr()\n\n    if plot:\n        # Create heatmap\n        plt.figure(figsize=(10, 8))\n        ax = sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', vmin=-1, vmax=1)\n        plt.title(\"Correlation Heatmap\")\n        plt.tight_layout()\n        return corr_matrix, ax\n    else:\n        return corr_matrix",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/324": [
      {
        "task_id": "BigCodeBench/324",
        "solution": "import subprocess\nimport time\nimport threading\ndef task_func(file_list):\n\n    pass\nimport subprocess\nimport time\nimport threading\ndef task_func(file_list):\n    def run_subprocess(file, results, index):\n        process = subprocess.Popen(['python', file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        process.wait()\n        results[index] = process.returncode\n\n    threads = []\n    results = [None] * len(file_list)\n\n    for i, file in enumerate(file_list):\n        thread = threading.Thread(target=run_subprocess, args=(file, results, i))\n        threads.append(thread)\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n    return results",
        "status": "fail",
        "details": {
          "test_multiple_processes_with_different_exit_codes": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 64, in test_multiple_processes_with_different_exit_codes\nAssertionError: Lists differ: [<MagicMock name='Popen().returncode' id='[130 chars]28'>] != [0, 1, None]\n\nFirst differing element 0:\n<MagicMock name='Popen().returncode' id='46916724676528'>\n0\n\n+ [0, 1, None]\n- [<MagicMock name='Popen().returncode' id='46916724676528'>,\n-  <MagicMock name='Popen().returncode' id='46916724676528'>,\n-  <MagicMock name='Popen().returncode' id='46916724676528'>]\n",
          "test_process_still_running": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 58, in test_process_still_running\nAssertionError: Lists differ: [<MagicMock name='Popen().returncode' id='46916725067680'>] != [None]\n\nFirst differing element 0:\n<MagicMock name='Popen().returncode' id='46916725067680'>\nNone\n\n- [<MagicMock name='Popen().returncode' id='46916725067680'>]\n+ [None]\n",
          "test_valid_directory_and_files": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 51, in test_valid_directory_and_files\nAssertionError: Lists differ: [<MagicMock name='Popen().returncode' id='[71 chars]24'>] != [0, 0]\n\nFirst differing element 0:\n<MagicMock name='Popen().returncode' id='46916725163824'>\n0\n\n+ [0, 0]\n- [<MagicMock name='Popen().returncode' id='46916725163824'>,\n-  <MagicMock name='Popen().returncode' id='46916725163824'>]\n",
          "test_valid_files": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 43, in test_valid_files\nAssertionError: Lists differ: [<MagicMock name='Popen().returncode' id='[71 chars]68'>] != [0, 0]\n\nFirst differing element 0:\n<MagicMock name='Popen().returncode' id='46916725293168'>\n0\n\n+ [0, 0]\n- [<MagicMock name='Popen().returncode' id='46916725293168'>,\n-  <MagicMock name='Popen().returncode' id='46916725293168'>]\n"
        }
      }
    ],
    "BigCodeBench/313": [
      {
        "task_id": "BigCodeBench/313",
        "solution": "import re\nimport os\nimport shutil\nfrom datetime import datetime\ndef task_func(directory):\n\n    pass\nimport re\nimport os\nimport shutil\nfrom datetime import datetime\ndef task_func(directory):\n    if not os.path.isdir(directory):\n        raise ValueError(f\"The directory '{directory}' does not exist.\")\n\n    organized_files = {}\n    \n    for filename in os.listdir(directory):\n        file_path = os.path.join(directory, filename)\n        if os.path.isfile(file_path):\n            match = re.search(r'(?<!\\[)[^\\[\\]]+(?!\\])', filename)\n            if match:\n                subdirectory_name = match.group().strip()\n                subdirectory_path = os.path.join(directory, subdirectory_name)\n                \n                if not os.path.exists(subdirectory_path):\n                    os.makedirs(subdirectory_path)\n                \n                new_file_path = os.path.join(subdirectory_path, filename)\n                shutil.move(file_path, new_file_path)\n                \n                if subdirectory_name not in organized_files:\n                    organized_files[subdirectory_name] = []\n                organized_files[subdirectory_name].append(filename)\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    organized_directory = f\"{directory}_organized_{timestamp}\"\n    os.rename(directory, organized_directory)\n\n    return (organized_directory, organized_files)",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/shutil.py\", line 816, in move\n    os.rename(src, real_dst)\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmpnemwelic/test/test_file1.txt' -> '/tmp/tmpnemwelic/test/test_file1.txt/test_file1.txt'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 71, in test_case_1\n  File \"__test__.py\", line 30, in task_func\n  File \"/usr/local/lib/python3.10/shutil.py\", line 836, in move\n    copy_function(src, real_dst)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 434, in copy2\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 256, in copyfile\n    with open(dst, 'wb') as fdst:\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmpnemwelic/test/test_file1.txt/test_file1.txt'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/shutil.py\", line 816, in move\n    os.rename(src, real_dst)\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmptp4zmgfr/test/test_file1.txt' -> '/tmp/tmptp4zmgfr/test/test_file1.txt/test_file1.txt'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 81, in test_case_2\n  File \"__test__.py\", line 30, in task_func\n  File \"/usr/local/lib/python3.10/shutil.py\", line 836, in move\n    copy_function(src, real_dst)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 434, in copy2\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 256, in copyfile\n    with open(dst, 'wb') as fdst:\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmptp4zmgfr/test/test_file1.txt/test_file1.txt'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/shutil.py\", line 816, in move\n    os.rename(src, real_dst)\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmpoqu8q7r2/test/test_file1.txt' -> '/tmp/tmpoqu8q7r2/test/test_file1.txt/test_file1.txt'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 89, in test_case_3\n  File \"__test__.py\", line 30, in task_func\n  File \"/usr/local/lib/python3.10/shutil.py\", line 836, in move\n    copy_function(src, real_dst)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 434, in copy2\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 256, in copyfile\n    with open(dst, 'wb') as fdst:\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmpoqu8q7r2/test/test_file1.txt/test_file1.txt'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/shutil.py\", line 816, in move\n    os.rename(src, real_dst)\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmpnlmy2491/test/test_file1.txt' -> '/tmp/tmpnlmy2491/test/test_file1.txt/test_file1.txt'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 94, in test_case_4\n  File \"__test__.py\", line 30, in task_func\n  File \"/usr/local/lib/python3.10/shutil.py\", line 836, in move\n    copy_function(src, real_dst)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 434, in copy2\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 256, in copyfile\n    with open(dst, 'wb') as fdst:\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmpnlmy2491/test/test_file1.txt/test_file1.txt'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/shutil.py\", line 816, in move\n    os.rename(src, real_dst)\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmptebhvcku/test/test_file1.txt' -> '/tmp/tmptebhvcku/test/test_file1.txt/test_file1.txt'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 100, in test_case_5\n  File \"__test__.py\", line 30, in task_func\n  File \"/usr/local/lib/python3.10/shutil.py\", line 836, in move\n    copy_function(src, real_dst)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 434, in copy2\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 256, in copyfile\n    with open(dst, 'wb') as fdst:\nNotADirectoryError: [Errno 20] Not a directory: '/tmp/tmptebhvcku/test/test_file1.txt/test_file1.txt'\n"
        }
      }
    ],
    "BigCodeBench/326": [
      {
        "task_id": "BigCodeBench/326",
        "solution": "import subprocess\nimport os\nimport sys\nimport glob\ndef task_func(directory_path):\n\n    pass\nimport subprocess\nimport os\nimport sys\nimport glob\ndef task_func(directory_path):\n    results = []\n    \n    # Check if the directory exists\n    if not os.path.isdir(directory_path):\n        print(f\"Error: The directory '{directory_path}' does not exist.\")\n        return results\n\n    # Find all .bat files in the directory\n    bat_files = glob.glob(os.path.join(directory_path, \"*.bat\"))\n\n    for bat_file in bat_files:\n        file_name = os.path.basename(bat_file)\n        try:\n            # Run the .bat file\n            if sys.platform == \"win32\":\n                # On Windows, use shell=True to properly execute .bat files\n                process = subprocess.Popen(bat_file, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            else:\n                # On non-Windows systems, we'll use 'cmd' to execute .bat files\n                process = subprocess.Popen([\"cmd\", \"/c\", bat_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n            # Wait for the process to complete and get the exit code\n            process.communicate()\n            exit_code = process.returncode\n\n            results.append((file_name, exit_code))\n\n        except Exception as e:\n            print(f\"Error executing {file_name}: {str(e)}\")\n            results.append((file_name, None))\n\n    return results",
        "status": "fail",
        "details": {
          "test_exception_handling": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 92, in test_exception_handling\nAssertionError: Lists differ: [] != [('file1.bat', None)]\n\nSecond list contains 1 additional elements.\nFirst extra element 0:\n('file1.bat', None)\n\n- []\n+ [('file1.bat', None)]\n",
          "test_multiple_bat_files_mixed_results": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 85, in test_multiple_bat_files_mixed_results\nAssertionError: Lists differ: [] != [('file1.bat', 0), ('file2.bat', 1), ('file3.bat', None)]\n\nSecond list contains 3 additional elements.\nFirst extra element 0:\n('file1.bat', 0)\n\n- []\n+ [('file1.bat', 0), ('file2.bat', 1), ('file3.bat', None)]\n",
          "test_single_bat_file_failure": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 72, in test_single_bat_file_failure\nAssertionError: Lists differ: [] != [('file1.bat', 1)]\n\nSecond list contains 1 additional elements.\nFirst extra element 0:\n('file1.bat', 1)\n\n- []\n+ [('file1.bat', 1)]\n",
          "test_single_bat_file_success": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 63, in test_single_bat_file_success\nAssertionError: Lists differ: [] != [('file1.bat', 0)]\n\nSecond list contains 1 additional elements.\nFirst extra element 0:\n('file1.bat', 0)\n\n- []\n+ [('file1.bat', 0)]\n"
        }
      }
    ],
    "BigCodeBench/367": [
      {
        "task_id": "BigCodeBench/367",
        "solution": "from datetime import datetime\nfrom collections import defaultdict\nimport matplotlib.pyplot as plt\ndef task_func(activities):\n\n    pass\nfrom datetime import datetime\nfrom collections import defaultdict\nimport matplotlib.pyplot as plt\ndef task_func(activities):\n    # Validate input\n    if not all(isinstance(activity, datetime) for activity in activities):\n        raise TypeError(\"All activities must be datetime objects\")\n\n    # Count activities for each day\n    day_counts = defaultdict(int)\n    for activity in activities:\n        day_name = activity.strftime('%A')\n        day_counts[day_name] += 1\n\n    # Prepare data for plotting\n    days_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    counts = [day_counts[day] for day in days_order]\n\n    # Create and customize the bar chart\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.bar(days_order, counts)\n    ax.set_xlabel('Day of the Week')\n    ax.set_ylabel('Number of Activities')\n    ax.set_title('Weekly Activity')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n\n    return ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/360": [
      {
        "task_id": "BigCodeBench/360",
        "solution": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\ndef task_func(file_location, sheet_name):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\ndef task_func(file_location, sheet_name):\n    # Check if file exists\n    if not os.path.exists(file_location):\n        raise FileNotFoundError(f\"The file '{file_location}' does not exist.\")\n\n    # Load the Excel file\n    try:\n        df = pd.read_excel(file_location, sheet_name=sheet_name)\n    except ValueError:\n        raise ValueError(f\"The sheet '{sheet_name}' does not exist in the workbook.\")\n\n    # Calculate mean and standard deviation for each column\n    stats = {col: {'mean': df[col].mean(), 'std': df[col].std()} for col in df.columns}\n\n    # Create bar chart\n    fig, ax = plt.subplots(figsize=(10, 6))\n    x = np.arange(len(df.columns))\n    width = 0.35\n\n    means = [stats[col]['mean'] for col in df.columns]\n    stds = [stats[col]['std'] for col in df.columns]\n\n    ax.bar(x - width/2, means, width, label='Mean', yerr=stds, capsize=5)\n    ax.bar(x + width/2, stds, width, label='Standard Deviation')\n\n    ax.set_xlabel('Columns')\n    ax.set_ylabel('Values')\n    ax.set_title('Mean and Standard Deviation')\n    ax.set_xticks(x)\n    ax.set_xticklabels(df.columns, rotation=45, ha='right')\n    ax.legend()\n\n    plt.tight_layout()\n\n    return stats, fig",
        "status": "fail",
        "details": {
          "test_correct_mean_and_std_values": "Traceback (most recent call last):\n  File \"__test__.py\", line 88, in test_correct_mean_and_std_values\nAssertionError: {'A':[19 chars]d': 14.142135623730951}, 'B': {'mean': 30.0, '[21 chars]951}} != {'A':[19 chars]d': 10.0}, 'B': {'mean': 30.0, 'std': 10.0}}\n+ {'A': {'mean': 20.0, 'std': 10.0}, 'B': {'mean': 30.0, 'std': 10.0}}\n- {'A': {'mean': 20.0, 'std': 14.142135623730951},\n-  'B': {'mean': 30.0, 'std': 14.142135623730951}}\n",
          "test_value": "Traceback (most recent call last):\n  File \"__test__.py\", line 98, in test_value\nAssertionError: {'A':[19 chars]d': 10.0}, 'B': {'mean': 30.0, 'std': 10.0}} != {'A':[19 chars]d': 14.142135623730951}, 'B': {'mean': 30.0, '[21 chars]951}}\n- {'A': {'mean': 20.0, 'std': 10.0}, 'B': {'mean': 30.0, 'std': 10.0}}\n+ {'A': {'mean': 20.0, 'std': 14.142135623730951},\n+  'B': {'mean': 30.0, 'std': 14.142135623730951}}\n"
        }
      }
    ],
    "BigCodeBench/346": [
      {
        "task_id": "BigCodeBench/346",
        "solution": "import subprocess\nimport os\nimport sys\nimport time\ndef task_func(script_path, wait=True, *args):\n\n    pass\nimport subprocess\nimport os\nimport sys\nimport time\ndef task_func(script_path, wait=True, *args):\n    # Check if the script exists\n    if not os.path.isfile(script_path):\n        raise ValueError(f\"Script does not exist: {script_path}\")\n\n    # Prepare the command\n    command = [sys.executable, script_path] + list(args)\n\n    try:\n        if wait:\n            # Run the script and wait for it to complete\n            result = subprocess.run(command, check=True, capture_output=True, text=True)\n            return result.returncode\n        else:\n            # Run the script without waiting\n            subprocess.Popen(command)\n            return None\n    except subprocess.CalledProcessError as e:\n        print(f\"Script output:\\n{e.stdout}\")\n        print(f\"Script error:\\n{e.stderr}\")\n        raise",
        "status": "fail",
        "details": {
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 76, in test_case_2\n  File \"__test__.py\", line 23, in task_func\n  File \"/app/bigcodebench/eval/utils.py\", line 61, in _run_patch\n    return original_run(*args, **kwargs)\n  File \"/app/bigcodebench/eval/utils.py\", line 174, in safe_subprocess_run\n    return original_subprocess_run(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/subprocess.py\", line 526, in run\n    raise CalledProcessError(retcode, process.args,\nsubprocess.CalledProcessError: Command '['/usr/local/bin/python3', '/tmp/tmpecnjej8_/test/script2.py']' returned non-zero exit status 1.\n"
        }
      }
    ],
    "BigCodeBench/341": [
      {
        "task_id": "BigCodeBench/341",
        "solution": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ndef task_func(df, col):\n\n    pass\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ndef task_func(df, col):\n    # Validate input\n    if not isinstance(df, pd.DataFrame):\n        raise ValueError(\"Input 'df' must be a pandas DataFrame\")\n    if df.empty:\n        raise ValueError(\"Input DataFrame 'df' cannot be empty\")\n    if col not in df.columns:\n        raise ValueError(f\"Column '{col}' not found in DataFrame\")\n\n    # Create figure with two subplots\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12))\n\n    # Subplot 1: Histogram with KDE for numerical data\n    if pd.api.types.is_numeric_dtype(df[col]):\n        sns.histplot(data=df, x=col, kde=True, ax=ax1)\n    else:\n        sns.histplot(data=df, x=col, ax=ax1)\n    ax1.set_title(f'Histogram of {col}')\n    ax1.set_xlabel(col)\n    ax1.set_ylabel('Count')\n\n    # Subplot 2: Box plot\n    sns.boxplot(data=df, y=col, ax=ax2)\n    ax2.set_title(f'Box Plot of {col}')\n    ax2.set_ylabel(col)\n\n    # Adjust layout\n    plt.tight_layout()\n\n    return fig",
        "status": "fail",
        "details": {
          "test_categorical_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_categorical_data\nAssertionError: False is not true\n"
        }
      }
    ],
    "BigCodeBench/368": [
      {
        "task_id": "BigCodeBench/368",
        "solution": "import os\nimport shutil\nimport random\ndef task_func(src_dir: str, dest_dir: str, seed:int = 100) -> str:\n\n    pass\nimport os\nimport shutil\nimport random\ndef task_func(src_dir: str, dest_dir: str, seed: int = 100) -> str:\n    random.seed(seed)\n\n    if not os.path.isdir(src_dir):\n        raise ValueError(f\"Source directory '{src_dir}' does not exist.\")\n\n    if not os.path.exists(dest_dir):\n        os.makedirs(dest_dir)\n\n    files = [f for f in os.listdir(src_dir) if os.path.isfile(os.path.join(src_dir, f))]\n\n    if not files:\n        raise ValueError(f\"No files found in the source directory '{src_dir}'.\")\n\n    file_to_move = random.choice(files)\n    src_path = os.path.join(src_dir, file_to_move)\n    dest_path = os.path.join(dest_dir, file_to_move)\n\n    shutil.move(src_path, dest_path)\n\n    return file_to_move",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 82, in test_case_3\n  File \"__test__.py\", line 22, in task_func\nValueError: No files found in the source directory '/tmp/tmpr4qf_m3g/test/src_test_dir_3'.\n"
        }
      }
    ],
    "BigCodeBench/399": [
      {
        "task_id": "BigCodeBench/399",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nimport math\ndef task_func(frequency, sample_size=10000):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\ndef task_func(frequency, sample_size=10000):\n    \"\"\"\n    Create a diagram of sine and cosine waves with a given frequency and return the plot.\n\n    Parameters:\n    frequency (float): The frequency of the waves in Hz.\n    sample_size (int): The number of points to sample (default is 10000).\n\n    Returns:\n    matplotlib.figure.Figure: The figure object containing the plot.\n    matplotlib.axes.Axes: The axes object of the plot.\n\n    Raises:\n    ValueError: If the frequency is negative.\n    ValueError: If the sample size is non-positive.\n    \"\"\"\n    if frequency < 0:\n        raise ValueError(\"Frequency must be non-negative.\")\n    if sample_size <= 0:\n        raise ValueError(\"Sample size must be positive.\")\n\n    # Generate time values for one complete cycle\n    t = np.linspace(0, 1/frequency, sample_size)\n\n    # Calculate sine and cosine values\n    sine_wave = np.sin(2 * np.pi * frequency * t)\n    cosine_wave = np.cos(2 * np.pi * frequency * t)\n\n    # Create the plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.plot(t, sine_wave, label='Sine Wave')\n    ax.plot(t, cosine_wave, label='Cosine Wave')\n\n    # Customize the plot\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Amplitude')\n    ax.set_title(f'Sine and Cosine Waves (Frequency: {frequency} Hz)')\n    ax.legend()\n    ax.grid(True)\n\n    # Set y-axis limits to show full amplitude range\n    ax.set_ylim(-1.1, 1.1)\n\n    # Add vertical lines to mark periods\n    for i in range(1, int(1/frequency) + 1):\n        ax.axvline(x=i/frequency, color='gray', linestyle='--', alpha=0.5)\n\n    return fig, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 63, in test_case_1\nAssertionError: 3 != 2\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_case_2\n  File \"__test__.py\", line 32, in task_func\nZeroDivisionError: division by zero\n"
        }
      }
    ],
    "BigCodeBench/374": [
      {
        "task_id": "BigCodeBench/374",
        "solution": "import regex as re\nimport glob\nimport os\nfrom openpyxl import load_workbook\ndef task_func(directory_path='./xlsx_files/'):\n\n    pass\nimport regex as re\nimport glob\nimport os\nfrom openpyxl import load_workbook\ndef task_func(directory_path='./xlsx_files/'):\n    # Ensure the directory path ends with a slash\n    directory_path = os.path.join(directory_path, '')\n\n    # Get all .xlsx files in the specified directory\n    xlsx_files = glob.glob(os.path.join(directory_path, '*.xlsx'))\n\n    processed_files = 0\n\n    for file_path in xlsx_files:\n        workbook = load_workbook(file_path)\n        modified = False\n\n        for sheet_name in workbook.sheetnames:\n            sheet = workbook[sheet_name]\n            for row in sheet.iter_rows():\n                for cell in row:\n                    if isinstance(cell.value, str):\n                        new_value = re.sub(r'(?<!\\\\)\"', r'\\\\\"', cell.value)\n                        if new_value != cell.value:\n                            cell.value = new_value\n                            modified = True\n\n        if modified:\n            workbook.save(file_path)\n            processed_files += 1\n\n    return processed_files",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 101, in test_case_1\nAssertionError: 2 != 3\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 127, in test_case_4\nAssertionError: FileNotFoundError not raised\n"
        }
      }
    ],
    "BigCodeBench/401": [
      {
        "task_id": "BigCodeBench/401",
        "solution": "from flask import Flask\nimport os\nfrom flask_mail import Mail\ndef task_func(app_name):\n\n    pass\nfrom flask import Flask\nimport os\nfrom flask_mail import Mail\ndef task_func(app_name):\n    app = Flask(app_name)\n\n    # Set up mail configuration\n    mail_config = {\n        'MAIL_SERVER': os.environ.get('MAIL_SERVER', 'localhost'),\n        'MAIL_PORT': int(os.environ.get('MAIL_PORT', 25)),\n        'MAIL_USE_TLS': os.environ.get('MAIL_USE_TLS', 'False').lower() == 'true',\n        'MAIL_USERNAME': os.environ.get('MAIL_USERNAME'),\n        'MAIL_PASSWORD': os.environ.get('MAIL_PASSWORD')\n    }\n\n    # Update app configuration with mail settings\n    app.config.update(mail_config)\n\n    # Initialize Flask-Mail\n    mail = Mail(app)\n\n    return mail, mail_config",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/409": [
      {
        "task_id": "BigCodeBench/409",
        "solution": "import os\nimport pandas as pd\nimport numpy as np\ndef task_func(excel_file_path, file_name, column_name):\n\n    pass\nimport os\nimport pandas as pd\nimport numpy as np\ndef task_func(excel_file_path, file_name, column_name):\n    # Construct the full file path\n    full_path = os.path.join(excel_file_path, file_name)\n    \n    # Check if the file exists\n    if not os.path.exists(full_path):\n        raise FileNotFoundError(f\"The file '{full_path}' does not exist.\")\n    \n    try:\n        # Read the Excel file\n        df = pd.read_excel(full_path)\n        \n        # Check if the specified column exists\n        if column_name not in df.columns:\n            raise ValueError(f\"The column '{column_name}' was not found in the Excel file.\")\n        \n        # Extract the data from the specified column\n        data = df[column_name]\n        \n        # Calculate mean, median, and standard deviation\n        mean = np.mean(data)\n        median = np.median(data)\n        std_dev = np.std(data)\n        \n        # Create and return the result dictionary\n        result = {\n            \"mean\": mean,\n            \"median\": median,\n            \"standard_deviation\": std_dev\n        }\n        \n        return result\n    \n    except pd.errors.EmptyDataError:\n        raise ValueError(\"The Excel file is empty.\")\n    except pd.errors.ParserError:\n        raise ValueError(\"Unable to parse the Excel file. Please ensure it's a valid Excel file.\")\n    except Exception as e:\n        raise Exception(f\"An unexpected error occurred: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_empty_excel_file": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in tearDown\nOSError: [Errno 39] Directory not empty: './test_data/'\n",
          "test_file_with_different_data_types": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in tearDown\nOSError: [Errno 39] Directory not empty: './test_data/'\n",
          "test_invalid_column_name": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in tearDown\nOSError: [Errno 39] Directory not empty: './test_data/'\n",
          "test_non_existent_file": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in tearDown\nOSError: [Errno 39] Directory not empty: './test_data/'\n",
          "test_normal_functionality": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in tearDown\nOSError: [Errno 39] Directory not empty: './test_data/'\n"
        }
      }
    ],
    "BigCodeBench/424": [
      {
        "task_id": "BigCodeBench/424",
        "solution": "import cv2\nimport numpy as np\nimport os\nfrom sklearn.cluster import KMeans\ndef task_func(image_path='image.jpg', n_clusters=3, random_seed=42):\n\n    pass\nimport cv2\nimport numpy as np\nimport os\nfrom sklearn.cluster import KMeans\ndef task_func(image_path='image.jpg', n_clusters=3, random_seed=42):\n    # Validate input parameters\n    if not os.path.exists(image_path):\n        raise FileNotFoundError(f\"Image file not found: {image_path}\")\n    if not isinstance(n_clusters, int) or n_clusters <= 0:\n        raise ValueError(\"n_clusters must be a positive integer\")\n\n    # Read the image\n    image = cv2.imread(image_path)\n    if image is None:\n        raise ValueError(f\"Unable to read image: {image_path}\")\n    \n    # Convert to RGB\n    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n    # Reshape the image to a 2D array of pixels\n    pixels = image_rgb.reshape(-1, 3)\n\n    # Perform K-means clustering\n    kmeans = KMeans(n_clusters=n_clusters, random_state=random_seed)\n    kmeans.fit(pixels)\n\n    # Create segmented image\n    segmented_image = kmeans.cluster_centers_[kmeans.labels_].reshape(image_rgb.shape).astype(np.uint8)\n\n    # Save each region as a separate image\n    labels_2d = kmeans.labels_.reshape(image_rgb.shape[:2])\n    for i in range(n_clusters):\n        region = np.where(labels_2d == i, 255, 0).astype(np.uint8)\n        cv2.imwrite(f\"region_{i+1}.png\", region)\n\n    return image_rgb, segmented_image",
        "status": "fail",
        "details": {
          "test_normal_functionality": "Traceback (most recent call last):\n  File \"__test__.py\", line 78, in test_normal_functionality\nAssertionError: False is not true : The arrays should be equal\n",
          "test_single_cluster_returns_original_image": "Traceback (most recent call last):\n  File \"__test__.py\", line 103, in test_single_cluster_returns_original_image\n  File \"/usr/local/lib/python3.10/site-packages/numpy/testing/_private/utils.py\", line 934, in assert_array_equal\n    assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,\n  File \"/usr/local/lib/python3.10/site-packages/numpy/testing/_private/utils.py\", line 844, in assert_array_compare\n    raise AssertionError(msg)\nAssertionError: \nArrays are not equal\nThe original and segmented images should be identical when n_clusters is set to 1.\nMismatched elements: 296 / 300 (98.7%)\nMax absolute difference: 255\nMax relative difference: 1.04508197\n x: array([[[255, 252, 253],\n        [251, 246, 243],\n        [255, 254, 248],...\n y: array([[[247, 247, 244],\n        [247, 247, 244],\n        [247, 247, 244],...\n"
        }
      }
    ],
    "BigCodeBench/443": [
      {
        "task_id": "BigCodeBench/443",
        "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\ndef task_func(\n    P: np.ndarray,\n    T: np.ndarray,\n    n_clusters: int = 3,\n    random_state: int = 0,\n    n_init: int = 10,\n) -> (np.ndarray, plt.Axes):\n\n    pass\nimport numpy as np\nfrom sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\ndef task_func(\n    P: np.ndarray,\n    T: np.ndarray,\n    n_clusters: int = 3,\n    random_state: int = 0,\n    n_init: int = 10,\n) -> (np.ndarray, plt.Axes):\n    # Calculate the product of matrix P and tensor T\n    result = np.tensordot(P, T, axes=([1], [0]))\n    \n    # Flatten the result\n    flattened_result = result.reshape(-1, result.shape[-1])\n    \n    # Apply KMeans clustering\n    kmeans = KMeans(n_clusters=n_clusters, random_state=random_state, n_init=n_init)\n    cluster_result = kmeans.fit_predict(flattened_result)\n    \n    # Visualize the clustering result\n    fig, ax = plt.subplots(figsize=(10, 8))\n    \n    scatter = ax.scatter(flattened_result[:, 0], flattened_result[:, 1], c=cluster_result, cmap='viridis')\n    \n    plt.colorbar(scatter, ax=ax, label='Cluster')\n    \n    ax.set_xlabel('Dimension 1')\n    ax.set_ylabel('Dimension 2')\n    ax.set_title('KMeans Clustering Visualization')\n    \n    return cluster_result, ax",
        "status": "fail",
        "details": {
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 80, in test_case_2\nAssertionError: False is not true\n"
        }
      }
    ],
    "BigCodeBench/445": [
      {
        "task_id": "BigCodeBench/445",
        "solution": "import numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nimport matplotlib.pyplot as plt\ndef task_func(points, seed=0):\n\n    pass\nimport numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nimport matplotlib.pyplot as plt\ndef task_func(points, seed=0):\n    \"\"\"\n    Calculate and plot the Voronoi diagram for a set of 2D points.\n\n    Args:\n        points (np.ndarray): Array of 2D points with shape (n, 2).\n        seed (int, optional): Random seed for jittering. Defaults to 0.\n\n    Returns:\n        tuple: (vor, ax)\n            vor (Voronoi): Voronoi object representing the diagram.\n            ax (matplotlib.axes.Axes): Axes of the plotted diagram.\n\n    Raises:\n        TypeError: If points is not a numpy array or seed is not an integer.\n        ValueError: If points does not have shape (n, 2).\n    \"\"\"\n    # Input validation\n    if not isinstance(points, np.ndarray):\n        raise TypeError(\"Input 'points' must be a numpy array.\")\n    if points.ndim != 2 or points.shape[1] != 2:\n        raise ValueError(\"Input 'points' must have shape (n, 2).\")\n    if not isinstance(seed, int):\n        raise TypeError(\"Input 'seed' must be an integer.\")\n\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n\n    # Apply jittering to avoid degeneracies\n    jitter = np.random.normal(0, 0.01, size=points.shape)\n    jittered_points = points + jitter\n\n    # Calculate Voronoi diagram\n    vor = Voronoi(jittered_points)\n\n    # Create plot\n    fig, ax = plt.subplots()\n\n    # Plot Voronoi diagram\n    voronoi_plot_2d(vor, ax=ax, show_vertices=False, line_colors='orange',\n                    line_width=2, line_alpha=0.6, point_size=2)\n\n    # Plot original points\n    ax.plot(points[:, 0], points[:, 1], 'ko', markersize=5)\n\n    # Set axis limits\n    margin = 0.1\n    ax.set_xlim(points[:, 0].min() - margin, points[:, 0].max() + margin)\n    ax.set_ylim(points[:, 1].min() - margin, points[:, 1].max() + margin)\n\n    # Set labels and title\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_title('Voronoi Diagram')\n\n    return vor, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/454": [
      {
        "task_id": "BigCodeBench/454",
        "solution": "import os\nimport shutil\nimport glob\ndef task_func(src_dir, dest_dir, ext):\n\n    pass\nimport os\nimport shutil\nimport glob\ndef task_func(src_dir, dest_dir, ext):\n    # Validate source and destination directories\n    if not os.path.isdir(src_dir):\n        raise FileNotFoundError(f\"Source directory does not exist: {src_dir}\")\n    if not os.path.isdir(dest_dir):\n        raise FileNotFoundError(f\"Destination directory does not exist: {dest_dir}\")\n\n    # Ensure the extension starts with a dot\n    ext = f\".{ext.lstrip('.')}\"\n\n    # Find all files with the specified extension in the source directory\n    source_files = glob.glob(os.path.join(src_dir, f\"*{ext}\"))\n\n    moved_files = []\n\n    for source_file in source_files:\n        filename = os.path.basename(source_file)\n        dest_file = os.path.join(dest_dir, filename)\n\n        # Check if the file already exists in the destination\n        if not os.path.exists(dest_file):\n            try:\n                shutil.move(source_file, dest_file)\n                moved_files.append(dest_file)\n            except IOError as e:\n                print(f\"Error moving file {filename}: {e}\")\n\n    return moved_files",
        "status": "fail",
        "details": {
          "test_move_specified_extension_files": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 84, in test_move_specified_extension_files\n  File \"__test__.py\", line 13, in task_func\nFileNotFoundError: Source directory does not exist: /fake/source\n"
        }
      }
    ],
    "BigCodeBench/458": [
      {
        "task_id": "BigCodeBench/458",
        "solution": "import json\nimport re\nimport pandas as pd\ndef task_func(json_str):\n\n    pass\nimport json\nimport re\nimport pandas as pd\ndef task_func(json_str):\n    # Return an empty DataFrame if the input string is empty or whitespace\n    if not json_str.strip():\n        return pd.DataFrame()\n\n    try:\n        # Load JSON string into a dictionary\n        data_dict = json.loads(json_str)\n    except json.JSONDecodeError:\n        # Return an empty DataFrame if JSON is invalid\n        return pd.DataFrame()\n\n    def double_value(value):\n        \"\"\"Double numerical values, including those in strings.\"\"\"\n        if isinstance(value, (int, float)):\n            return value * 2\n        elif isinstance(value, str):\n            match = re.search(r'-?\\d+\\.?\\d*', value)\n            if match:\n                num = float(match.group())\n                return value.replace(match.group(), str(num * 2))\n        return value\n\n    # Normalize the dictionary by doubling numerical values\n    normalized_dict = {}\n    for key, value in data_dict.items():\n        if isinstance(value, list):\n            normalized_dict[key] = [double_value(item) for item in value]\n        else:\n            normalized_dict[key] = double_value(value)\n\n    # Create a DataFrame from the normalized dictionary\n    df = pd.DataFrame([normalized_dict])\n\n    # Convert columns to float where possible\n    for column in df.columns:\n        df[column] = pd.to_numeric(df[column], errors='ignore')\n\n    return df",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 57, in test_case_1\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 1163, in assert_frame_equal\n    raise_assert_detail(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 599, in raise_assert_detail\n    raise AssertionError(msg)\nAssertionError: DataFrame are different\n\nDataFrame shape mismatch\n[left]:  (1, 3)\n[right]: (3, 3)\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_case_2\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 1163, in assert_frame_equal\n    raise_assert_detail(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 599, in raise_assert_detail\n    raise AssertionError(msg)\nAssertionError: DataFrame are different\n\nDataFrame shape mismatch\n[left]:  (1, 0)\n[right]: (0, 0)\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 72, in test_case_3\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 1163, in assert_frame_equal\n    raise_assert_detail(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 599, in raise_assert_detail\n    raise AssertionError(msg)\nAssertionError: DataFrame are different\n\nDataFrame shape mismatch\n[left]:  (1, 4)\n[right]: (3, 4)\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 80, in test_case_5\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 1163, in assert_frame_equal\n    raise_assert_detail(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 599, in raise_assert_detail\n    raise AssertionError(msg)\nAssertionError: DataFrame are different\n\nDataFrame shape mismatch\n[left]:  (1, 2)\n[right]: (3, 2)\n"
        }
      }
    ],
    "BigCodeBench/477": [
      {
        "task_id": "BigCodeBench/477",
        "solution": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\ndef task_func(N=100, CATEGORIES=[\"A\", \"B\", \"C\", \"D\", \"E\"], seed=42):\n\n    pass\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\ndef task_func(N=100, CATEGORIES=[\"A\", \"B\", \"C\", \"D\", \"E\"], seed=42):\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Generate random x and y values\n    x = np.random.rand(N)\n    y = np.random.rand(N)\n    \n    # Generate categories\n    if N >= len(CATEGORIES):\n        # Ensure each category appears at least once\n        categories = CATEGORIES.copy()\n        categories.extend(np.random.choice(CATEGORIES, N - len(CATEGORIES)))\n        np.random.shuffle(categories)\n    else:\n        # Randomly sample without replacement\n        categories = np.random.choice(CATEGORIES, N, replace=False)\n    \n    # Create DataFrame\n    df = pd.DataFrame({\n        'x': x,\n        'y': y,\n        'category': categories\n    })\n    \n    # Create scatter plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    for category in set(categories):\n        subset = df[df['category'] == category]\n        ax.scatter(subset['x'], subset['y'], label=category, alpha=0.7)\n    \n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_title('Scatter Plot of X vs Y, Colored by Category')\n    ax.legend()\n    \n    return df, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/486": [
      {
        "task_id": "BigCodeBench/486",
        "solution": "from datetime import datetime\nimport pandas as pd\nimport numpy as np\ndef task_func(start_time, end_time, step, trend, seed=42):\n\n    pass\nfrom datetime import datetime\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(start_time, end_time, step, trend, seed=42):\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Convert epoch to datetime\n    start_datetime = datetime.fromtimestamp(start_time)\n    end_datetime = datetime.fromtimestamp(end_time)\n    \n    # Generate timestamp range\n    timestamps = pd.date_range(start=start_datetime, end=end_datetime, freq=f'{step}S')\n    \n    # Generate random values from normal distribution\n    values = np.random.normal(loc=0, scale=1, size=len(timestamps))\n    \n    # Add linear trend\n    trend_values = np.linspace(0, trend * len(timestamps), len(timestamps))\n    values += trend_values\n    \n    # Create DataFrame\n    df = pd.DataFrame({'Time': timestamps, 'Value': values})\n    \n    # Create plot\n    fig, ax = plt.subplots(figsize=(12, 6))\n    ax.plot(df['Time'], df['Value'])\n    \n    # Set labels and title\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Value')\n    ax.set_title('Time Series with Linear Trend')\n    \n    # Rotate x-axis labels for better readability\n    plt.xticks(rotation=45)\n    \n    # Adjust layout to prevent cutting off labels\n    plt.tight_layout()\n    \n    return ax",
        "status": "fail",
        "details": {
          "test_case_6": "Traceback (most recent call last):\n  File \"__test__.py\", line 115, in test_case_6\nAssertionError: Exception not raised\n",
          "test_case_8": "Traceback (most recent call last):\n  File \"__test__.py\", line 125, in test_case_8\nAssertionError: False is not true\n"
        }
      }
    ],
    "BigCodeBench/492": [
      {
        "task_id": "BigCodeBench/492",
        "solution": "import pandas as pd\nfrom datetime import datetime\nimport random\ndef task_func(\n    epoch_milliseconds,\n    random_seed=0,\n    products=[\"Product1\", \"Product2\", \"Product3\", \"Product4\", \"Product5\"],\n):\n\n    pass\nimport pandas as pd\nfrom datetime import datetime\nimport random\ndef task_func(\n    epoch_milliseconds,\n    random_seed=0,\n    products=[\"Product1\", \"Product2\", \"Product3\", \"Product4\", \"Product5\"],\n):\n    # Set random seed for reproducibility\n    random.seed(random_seed)\n\n    # Validate input parameters\n    try:\n        start_date = datetime.fromtimestamp(epoch_milliseconds / 1000.0)\n    except (ValueError, OSError):\n        raise ValueError(\"Invalid epoch_milliseconds\")\n\n    if not isinstance(products, list) or len(products) != 5:\n        raise ValueError(\"products must be a list of exactly 5 items\")\n\n    # Get current date\n    end_date = datetime.now()\n\n    # Generate date range\n    date_range = pd.date_range(start=start_date, end=end_date, freq='D')\n\n    # Initialize lists to store data\n    data = []\n\n    # Generate sales data for each day and product\n    for date in date_range:\n        for product in products:\n            data.append({\n                'Product': product,\n                'Date': date,\n                'Sales': random.randint(10, 50)\n            })\n\n    # Create DataFrame\n    df = pd.DataFrame(data)\n\n    return df",
        "status": "fail",
        "details": {
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 104, in test_case_5\nAssertionError: ValueError not raised\n",
          "test_case_7": "Traceback (most recent call last):\n  File \"__test__.py\", line 112, in test_case_7\nAssertionError: ValueError not raised\n"
        }
      }
    ],
    "BigCodeBench/461": [
      {
        "task_id": "BigCodeBench/461",
        "solution": "import subprocess\nimport psutil\nimport time\nimport os\ndef task_func(script_path: str, timeout=10) -> dict:\n\n    pass\nimport subprocess\nimport psutil\nimport time\nimport os\ndef task_func(script_path: str, timeout=10) -> dict:\n    if not os.path.isfile(script_path):\n        raise FileNotFoundError(f\"Script file does not exist: {script_path}\")\n\n    result = {\"CPU Usage\": 0.0, \"Memory Usage\": 0}\n    start_time = time.time()\n\n    try:\n        process = subprocess.Popen(['bash', script_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n        ps_process = psutil.Process(process.pid)\n\n        while process.poll() is None:\n            if time.time() - start_time > timeout:\n                process.terminate()\n                process.wait(timeout=1)\n                if process.poll() is None:\n                    process.kill()\n                raise TimeoutError(f\"Script execution timed out after {timeout} seconds\")\n\n            try:\n                cpu_usage = ps_process.cpu_percent(interval=0.1)\n                memory_usage = ps_process.memory_info().rss\n\n                result[\"CPU Usage\"] += cpu_usage\n                result[\"Memory Usage\"] += memory_usage\n\n            except (psutil.NoSuchProcess, psutil.ZombieProcess):\n                break\n\n            time.sleep(0.1)\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Error executing script: {e}\")\n    finally:\n        if process.poll() is None:\n            process.terminate()\n            process.wait(timeout=1)\n            if process.poll() is None:\n                process.kill()\n\n    return result",
        "status": "fail",
        "details": {
          "test_case_7": "Traceback (most recent call last):\n  File \"__test__.py\", line 101, in test_case_7\n  File \"__test__.py\", line 29, in task_func\nTimeoutError: Script execution timed out after 0 seconds\n"
        }
      }
    ],
    "BigCodeBench/501": [
      {
        "task_id": "BigCodeBench/501",
        "solution": "import xlwt\nimport os\nimport pandas as pd\ndef task_func(json_str, filename, sheet_name=\"sheet1\"):\n\n    pass\nimport xlwt\nimport os\nimport pandas as pd\nimport json\ndef task_func(json_str, filename, sheet_name=\"sheet1\"):\n    # Validate input type\n    if not isinstance(json_str, (str, bytes, bytearray)):\n        raise TypeError(\"json_str must be a string, bytes, or bytearray\")\n\n    try:\n        # Parse JSON string\n        data = json.loads(json_str)\n    except json.JSONDecodeError:\n        raise ValueError(\"Invalid JSON string\")\n\n    # Ensure data is a list (array)\n    if not isinstance(data, list):\n        raise ValueError(\"JSON must represent an array\")\n\n    # Create DataFrame from JSON data\n    df = pd.DataFrame(data)\n\n    # Create a new Excel workbook and add a worksheet\n    workbook = xlwt.Workbook()\n    worksheet = workbook.add_sheet(sheet_name)\n\n    # Write column headers if DataFrame is not empty\n    if not df.empty:\n        for col, header in enumerate(df.columns):\n            worksheet.write(0, col, str(header))\n\n        # Write data rows\n        for row in range(len(df)):\n            for col in range(len(df.columns)):\n                worksheet.write(row + 1, col, str(df.iloc[row, col]))\n\n    # Ensure the filename has .xls extension\n    if not filename.lower().endswith('.xls'):\n        filename += '.xls'\n\n    # Get the absolute path for the file\n    abs_path = os.path.abspath(filename)\n\n    try:\n        # Save the workbook\n        workbook.save(abs_path)\n    except Exception as e:\n        raise Exception(f\"Error writing to Excel file: {str(e)}\")\n\n    return abs_path",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/503": [
      {
        "task_id": "BigCodeBench/503",
        "solution": "import numpy as np\nimport pandas as pd\nfrom datetime import datetime\ndef task_func(\n    days_in_past=7, stock_names=[\"AAPL\", \"GOOGL\", \"MSFT\", \"AMZN\", \"FB\"], random_seed=0\n):\n\n    pass\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\ndef task_func(\n    days_in_past=7, stock_names=[\"AAPL\", \"GOOGL\", \"MSFT\", \"AMZN\", \"FB\"], random_seed=0\n):\n    # Set random seed for reproducibility\n    np.random.seed(random_seed)\n    \n    # Generate date range\n    end_date = datetime.now().date()\n    start_date = end_date - timedelta(days=days_in_past-1)\n    date_range = pd.date_range(start=start_date, end=end_date, freq='D')\n    \n    # Generate random stock prices\n    prices = np.random.random((days_in_past, len(stock_names)))\n    \n    # Create DataFrame\n    df = pd.DataFrame(prices, columns=stock_names, index=date_range)\n    \n    return df",
        "status": "fail",
        "details": {
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 92, in test_case_4\nAssertionError: ValueError not raised\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 98, in test_case_5\nAssertionError: ValueError not raised\n"
        }
      }
    ],
    "BigCodeBench/509": [
      {
        "task_id": "BigCodeBench/509",
        "solution": "import pandas as pd\nimport csv\nfrom difflib import ndiff\ndef task_func(file_path1, file_path2, delimiter=',', quotechar='\"'):\n\n    pass\nimport pandas as pd\nimport csv\nfrom difflib import ndiff\ndef task_func(file_path1, file_path2, delimiter=',', quotechar='\"'):\n    try:\n        # Read the contents of both files\n        with open(file_path1, 'r', newline='', encoding='utf-8') as file1, open(file_path2, 'r', newline='', encoding='utf-8') as file2:\n            reader1 = csv.reader(file1, delimiter=delimiter, quotechar=quotechar)\n            reader2 = csv.reader(file2, delimiter=delimiter, quotechar=quotechar)\n            \n            lines1 = [delimiter.join(row) for row in reader1]\n            lines2 = [delimiter.join(row) for row in reader2]\n\n        # Check if either file is empty\n        if not lines1 or not lines2:\n            raise ValueError(\"One or both files are empty.\")\n\n        # Use ndiff to compare the files\n        diff = list(ndiff(lines1, lines2))\n\n        # Initialize lists to store difference data\n        line_numbers = []\n        statuses = []\n        contents = []\n\n        # Process the differences\n        line_number = 0\n        for line in diff:\n            if line.startswith('  '):  # No change\n                line_number += 1\n                line_numbers.append(line_number)\n                statuses.append(' ')\n                contents.append(line[2:])\n            elif line.startswith('- '):  # Line in file1 but not in file2\n                line_number += 1\n                line_numbers.append(line_number)\n                statuses.append('-')\n                contents.append(line[2:])\n            elif line.startswith('+ '):  # Line in file2 but not in file1\n                line_numbers.append(line_number + 1)\n                statuses.append('+')\n                contents.append(line[2:])\n\n        # Create a DataFrame with the differences\n        df = pd.DataFrame({\n            'Line Number': line_numbers,\n            'Status': statuses,\n            'Content': contents\n        })\n\n        return df\n\n    except FileNotFoundError:\n        raise FileNotFoundError(\"One or both of the specified files could not be found.\")\n    except ValueError as ve:\n        raise ve\n    except Exception as e:\n        raise Exception(f\"An error occurred while processing the files: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_difference_report": "Traceback (most recent call last):\n  File \"__test__.py\", line 118, in test_difference_report\nAssertionError: Lists differ: ['1, ,name,age', '2,-,Alice,30', '3,+,Alic[15 chars],25'] != [\"1, ,('name', 'age')\", \"2,-,('Alice', '30[43 chars]5')\"]\n\nFirst differing element 0:\n'1, ,name,age'\n\"1, ,('name', 'age')\"\n\n- ['1, ,name,age', '2,-,Alice,30', '3,+,Alice,31', '3, ,Bob,25']\n+ [\"1, ,('name', 'age')\",\n+  \"2,-,('Alice', '30')\",\n+  \"3,+,('Alice', '31')\",\n+  \"4, ,('Bob', '25')\"]\n"
        }
      }
    ],
    "BigCodeBench/511": [
      {
        "task_id": "BigCodeBench/511",
        "solution": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(column, data):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(column, data):\n    # Create DataFrame from input data\n    df = pd.DataFrame(data)\n    \n    # Initialize statistics dictionary\n    stats = {\n        'sum': 0,\n        'mean': np.nan,\n        'min': np.nan,\n        'max': np.nan\n    }\n    \n    # Calculate statistics if data is not empty and column exists\n    if not df.empty and column in df.columns:\n        stats['sum'] = df[column].sum()\n        stats['mean'] = df[column].mean()\n        stats['min'] = df[column].min()\n        stats['max'] = df[column].max()\n    \n    # Create pie chart\n    fig, ax = plt.subplots()\n    if not df.empty and 'Age' in df.columns:\n        age_counts = df['Age'].value_counts().sort_index()\n        ax.pie(age_counts.values, labels=age_counts.index, autopct='%1.1f%%')\n        ax.set_title('Age Distribution')\n    else:\n        ax.text(0.5, 0.5, 'No Age data available', ha='center', va='center')\n        ax.axis('off')\n    \n    return stats, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 54, in test_case_1\nAssertionError: {'sum': 0, 'mean': nan, 'min': nan, 'max': nan} != {'sum': 500000, 'mean': 100000.0, 'min': 50000, 'max': 150000}\n- {'max': nan, 'mean': nan, 'min': nan, 'sum': 0}\n+ {'max': 150000, 'mean': 100000.0, 'min': 50000, 'sum': 500000}\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 67, in test_case_2\nAssertionError: {'sum': 0, 'mean': nan, 'min': nan, 'max': nan} != {'sum': 41, 'mean': 8.2, 'min': 3, 'max': 13}\n- {'max': nan, 'mean': nan, 'min': nan, 'sum': 0}\n?         ^^^          ^^^         ^^^         ^\n\n+ {'max': 13, 'mean': 8.2, 'min': 3, 'sum': 41}\n?         ^^          ^^^         ^         ^^\n\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 78, in test_case_3\nAssertionError: {'sum': 0, 'mean': nan, 'min': nan, 'max': nan} != {'sum': 185, 'mean': 37.0, 'min': 27, 'max': 47}\n- {'max': nan, 'mean': nan, 'min': nan, 'sum': 0}\n?         ^^^          ^^^         ^^^         ^\n\n+ {'max': 47, 'mean': 37.0, 'min': 27, 'sum': 185}\n?         ^^          ^^^^         ^^         ^^^\n\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 90, in test_case_5\nAssertionError: {'sum': 0, 'mean': nan, 'min': nan, 'max': nan} != {'sum': 30, 'mean': 30.0, 'min': 30, 'max': 30}\n- {'max': nan, 'mean': nan, 'min': nan, 'sum': 0}\n?         ^^^          ^^^         ^^^\n\n+ {'max': 30, 'mean': 30.0, 'min': 30, 'sum': 30}\n?         ^^          ^^^^         ^^         +\n\n",
          "test_case_6": "Traceback (most recent call last):\n  File \"__test__.py\", line 98, in test_case_6\nAssertionError: KeyError not raised\n",
          "test_case_7": "Traceback (most recent call last):\n  File \"__test__.py\", line 111, in test_case_7\nAssertionError: 0 != 5 : The number of pie slices does not match the number of data points.\n"
        }
      }
    ],
    "BigCodeBench/513": [
      {
        "task_id": "BigCodeBench/513",
        "solution": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(column, data):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(column, data):\n    # Check if data is empty\n    if not data:\n        raise ValueError(\"Data list is empty\")\n\n    # Convert data to DataFrame\n    df = pd.DataFrame(data)\n\n    # Check if specified column exists\n    if column not in df.columns:\n        raise KeyError(f\"Column '{column}' not found in data\")\n\n    # Validate non-negative values for steps, calories burned, and distance walked\n    for col in ['Steps', 'Calories Burned', 'Distance Walked']:\n        if col in df.columns and (df[col] < 0).any():\n            raise ValueError(f\"Negative values found in '{col}' column\")\n\n    # Calculate statistics\n    stats = {\n        'sum': df[column].sum(),\n        'mean': df[column].mean(),\n        'min': df[column].min(),\n        'max': df[column].max()\n    }\n\n    # Create line chart\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.plot(df['Date'], df[column], marker='o')\n    ax.set_xlabel('Date')\n    ax.set_ylabel(column)\n    ax.set_title(f'Line Chart of {column}')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n\n    return stats, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 55, in test_case_1\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Steps' not found in data\"\n",
          "test_case_11": "Traceback (most recent call last):\n  File \"__test__.py\", line 137, in test_case_11\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Steps' not found in data\"\n",
          "test_case_12": "Traceback (most recent call last):\n  File \"__test__.py\", line 147, in test_case_12\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Distance Walked' not found in data\"\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_case_2\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Calories Burned' not found in data\"\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_case_3\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Distance Walked' not found in data\"\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 84, in test_case_4\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Steps' not found in data\"\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 94, in test_case_5\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Calories Burned' not found in data\"\n",
          "test_case_7": "Traceback (most recent call last):\n  File \"__test__.py\", line 108, in test_case_7\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Steps' not found in data\"\n",
          "test_case_8": "Traceback (most recent call last):\n  File \"__test__.py\", line 112, in test_case_8\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Steps' not found in data\"\n",
          "test_case_9": "Traceback (most recent call last):\n  File \"__test__.py\", line 121, in test_case_9\n  File \"__test__.py\", line 20, in task_func\nKeyError: \"Column 'Steps' not found in data\"\n"
        }
      }
    ],
    "BigCodeBench/526": [
      {
        "task_id": "BigCodeBench/526",
        "solution": "import json\nimport pandas as pd\nimport numpy as np\nfrom collections import defaultdict\ndef task_func(input_file=\"data.json\"):\n\n    pass\nimport json\nimport pandas as pd\nimport numpy as np\nfrom collections import defaultdict\ndef task_func(input_file=\"data.json\"):\n    # Read JSON file\n    with open(input_file, 'r') as file:\n        data = json.load(file)\n\n    # Initialize defaultdict to store numeric values for each key\n    numeric_values = defaultdict(list)\n\n    # Collect numeric values for each key\n    for item in data:\n        for key, value in item.items():\n            if isinstance(value, (int, float)):\n                numeric_values[key].append(value)\n\n    # Calculate mean and median for each key\n    results = {}\n    for key, values in numeric_values.items():\n        if values:\n            results[key] = {\n                'mean': np.mean(values),\n                'median': np.median(values)\n            }\n\n    # Convert results to DataFrame and sort by index\n    df = pd.DataFrame.from_dict(results, orient='index')\n    df.sort_index(inplace=True)\n\n    return df",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 75, in test_case_3\nAssertionError: Lists differ: ['a'] != ['a', 'b']\n\nSecond list contains 1 additional elements.\nFirst extra element 1:\n'b'\n\n- ['a']\n+ ['a', 'b']\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 87, in test_case_5\nAssertionError: Lists differ: ['a', 'c'] != ['a', 'b', 'c']\n\nFirst differing element 1:\n'c'\n'b'\n\nSecond list contains 1 additional elements.\nFirst extra element 2:\n'c'\n\n- ['a', 'c']\n+ ['a', 'b', 'c']\n?       +++++\n\n",
          "test_case_8": "Traceback (most recent call last):\n  File \"__test__.py\", line 126, in test_case_8\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexing.py\", line 1096, in __getitem__\n    return self.obj._get_value(*key, takeable=self._takeable)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3870, in _get_value\n    series = self._get_item_cache(col)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 4255, in _get_item_cache\n    loc = self.columns.get_loc(item)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/range.py\", line 349, in get_loc\n    raise KeyError(key)\nKeyError: 'mean'\n"
        }
      }
    ],
    "BigCodeBench/502": [
      {
        "task_id": "BigCodeBench/502",
        "solution": "from datetime import datetime, timedelta\nimport pandas as pd\nimport random\nimport seaborn as sns\ndef task_func(days_in_past=7, random_seed=0):\n\n    pass\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport random\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ndef task_func(days_in_past=7, random_seed=0):\n    # Set random seed for reproducibility\n    random.seed(random_seed)\n    \n    # Generate date range\n    end_date = datetime.now().date()\n    start_date = end_date - timedelta(days=days_in_past-1)\n    date_range = pd.date_range(start=start_date, end=end_date)\n    \n    # List of activities\n    activities = [\"Running\", \"Swimming\", \"Cycling\", \"Yoga\", \"Weight Training\"]\n    \n    # Generate data\n    data = []\n    for date in date_range:\n        for activity in activities:\n            duration = random.randint(0, 120)\n            data.append({\n                'Date': date,\n                'Activity': activity,\n                'Duration': duration\n            })\n    \n    # Create DataFrame\n    df = pd.DataFrame(data)\n    \n    # Create plot\n    plt.figure(figsize=(12, 6))\n    ax = sns.lineplot(data=df, x='Date', y='Duration', hue='Activity', marker='o')\n    \n    # Customize plot\n    plt.title('Daily Activity Durations')\n    plt.xlabel('Date')\n    plt.ylabel('Duration (minutes)')\n    plt.xticks(rotation=45)\n    plt.legend(title='Activity', bbox_to_anchor=(1.05, 1), loc='upper left')\n    plt.tight_layout()\n    \n    return ax, df",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/528": [
      {
        "task_id": "BigCodeBench/528",
        "solution": "import csv\nfrom collections import Counter\nimport pandas as pd\nimport matplotlib.pyplot as plt\ndef task_func(file_path):\n\n    pass\nimport csv\nfrom collections import Counter\nimport pandas as pd\nimport matplotlib.pyplot as plt\ndef task_func(file_path):\n    # Verify file extension\n    if not file_path.lower().endswith('.csv'):\n        raise ValueError(\"File must have a .csv extension\")\n\n    # Read CSV and count duplicates\n    try:\n        with open(file_path, 'r', newline='') as csvfile:\n            reader = csv.reader(csvfile)\n            row_counts = Counter(tuple(row) for row in reader)\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n    except csv.Error as e:\n        raise ValueError(f\"Error reading CSV file: {e}\")\n\n    # Filter duplicates\n    duplicates = {row: count for row, count in row_counts.items() if count > 1}\n\n    if not duplicates:\n        raise ValueError(\"No duplicate rows found in the CSV file\")\n\n    # Convert to DataFrame\n    df = pd.DataFrame(list(duplicates.items()), columns=['Row', 'Count'])\n    df['Row'] = df['Row'].apply(lambda x: ', '.join(x))\n    df = df.sort_values('Count', ascending=False)\n\n    # Create bar chart\n    fig, ax = plt.subplots(figsize=(12, 6))\n    ax.bar(df['Row'], df['Count'])\n    ax.set_xlabel('Duplicate Rows')\n    ax.set_ylabel('Count')\n    ax.set_title('Duplicate Rows in CSV File')\n    plt.xticks(rotation=90, ha='right')\n    plt.tight_layout()\n\n    return duplicates, ax",
        "status": "fail",
        "details": {
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 82, in test_case_2\nAssertionError: 'Duplicate Rows in CSV File' != 'Duplicate Entries'\n- Duplicate Rows in CSV File\n+ Duplicate Entries\n\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 88, in test_case_3\n  File \"__test__.py\", line 31, in task_func\nValueError: No duplicate rows found in the CSV file\n"
        }
      }
    ],
    "BigCodeBench/418": [
      {
        "task_id": "BigCodeBench/418",
        "solution": "from tensorflow import keras\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\ndef task_func(X, Y):\n\n    pass\nfrom tensorflow import keras\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\ndef task_func(X, Y):\n    # Split the data into training and test sets\n    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=42)\n\n    # Create a Keras Sequential model with one hidden layer\n    model = keras.Sequential([\n        keras.layers.Dense(64, activation='sigmoid', input_shape=(X.shape[1],)),\n        keras.layers.Dense(1, activation='sigmoid')\n    ])\n\n    # Compile the model\n    optimizer = keras.optimizers.SGD(learning_rate=0.01)\n    model.compile(optimizer=optimizer, loss='binary_crossentropy')\n\n    # Fit the model to the training data in non-verbose mode\n    model.fit(X_train, Y_train, epochs=100, batch_size=32, verbose=0)\n\n    # Generate predictions for the test set\n    Y_pred = model.predict(X_test).ravel()\n\n    # Calculate ROC curve and AUC\n    fpr, tpr, _ = roc_curve(Y_test, Y_pred)\n    roc_auc = auc(fpr, tpr)\n\n    # Plot ROC curve\n    fig, ax = plt.subplots()\n    ax.plot(fpr, tpr, label=f'ROC curve (AUC = {roc_auc:.2f})')\n    ax.plot([0, 1], [0, 1], linestyle='--', color='r')\n    ax.set_xlim([0.0, 1.0])\n    ax.set_ylim([0.0, 1.05])\n    ax.set_xlabel('False positive rate')\n    ax.set_ylabel('True positive rate')\n    ax.set_title('ROC curve')\n    ax.legend(loc=\"lower right\")\n\n    return model, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/530": [
      {
        "task_id": "BigCodeBench/530",
        "solution": "import pandas as pd\nimport numpy as np\nfrom collections import Counter\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ndef task_func(df: pd.DataFrame) -> (Counter, plt.Axes):\n\n    pass\nimport pandas as pd\nimport numpy as np\nfrom collections import Counter\nimport seaborn as sns\nimport matplotlib.pyplot as plt\ndef task_func(df: pd.DataFrame) -> (Counter, plt.Axes):\n    # Validate input\n    if df.empty:\n        raise ValueError(\"DataFrame is empty\")\n    if (df['age'] < 0).any():\n        raise ValueError(\"Age must not be negative\")\n\n    # Round down ages to nearest integer\n    df['age'] = np.floor(df['age']).astype(int)\n\n    # Identify duplicate names\n    duplicates = df[df.duplicated(subset='name', keep=False)]\n\n    # If no duplicates, return empty Counter and None\n    if duplicates.empty:\n        return Counter(), None\n\n    # Get age distribution for duplicates\n    age_distribution = Counter(duplicates['age'])\n\n    # Create histogram plot\n    plt.figure(figsize=(10, 6))\n    min_age, max_age = duplicates['age'].min(), duplicates['age'].max()\n    bins = np.arange(min_age - 0.5, max_age + 1.5, 1)\n\n    ax = sns.histplot(data=duplicates, x='age', bins=bins, kde=False)\n    ax.set_xlabel('Age')\n    ax.set_ylabel('Count')\n    ax.set_title('Age Distribution for Duplicate Names')\n    ax.set_xticks(range(int(min_age), int(max_age) + 1))\n\n    plt.tight_layout()\n\n    return age_distribution, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/560": [
      {
        "task_id": "BigCodeBench/560",
        "solution": "from datetime import datetime\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndef task_func(data):\n\n    pass\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndef task_func(data):\n    # Convert input to DataFrame if it's not already\n    if not isinstance(data, pd.DataFrame):\n        data = pd.DataFrame(data)\n    \n    # Ensure 'date' column is in datetime format\n    data['date'] = pd.to_datetime(data['date'])\n    \n    # Extract year and month\n    year = data['date'].dt.year.iloc[0]\n    data['month'] = data['date'].dt.month\n    \n    # Group by month and calculate mean value\n    monthly_data = data.groupby('month')['value'].mean().reset_index()\n    \n    # Create the plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Plot bar chart\n    ax.bar(monthly_data['month'], monthly_data['value'])\n    \n    # Set x-axis ticks and labels\n    ax.set_xticks(range(1, 13))\n    ax.set_xticklabels(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n                        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])\n    \n    # Set labels and title\n    ax.set_xlabel('Month')\n    ax.set_ylabel('Value')\n    ax.set_title(f'Monthly Data for {year}')\n    \n    # Adjust layout\n    plt.tight_layout()\n    \n    return ax",
        "status": "fail",
        "details": {
          "test_basic_functionality": "Traceback (most recent call last):\n  File \"__test__.py\", line 49, in test_basic_functionality\n  File \"__test__.py\", line 13, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 817, in __init__\n    raise ValueError(\"DataFrame constructor not properly called!\")\nValueError: DataFrame constructor not properly called!\n",
          "test_full_year_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 56, in test_full_year_data\n  File \"__test__.py\", line 13, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 817, in __init__\n    raise ValueError(\"DataFrame constructor not properly called!\")\nValueError: DataFrame constructor not properly called!\n",
          "test_partial_year_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 60, in test_partial_year_data\n  File \"__test__.py\", line 13, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 817, in __init__\n    raise ValueError(\"DataFrame constructor not properly called!\")\nValueError: DataFrame constructor not properly called!\n"
        }
      }
    ],
    "BigCodeBench/553": [
      {
        "task_id": "BigCodeBench/553",
        "solution": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# Constants\nCOLUMNS = ['A', 'B', 'C', 'D', 'E']\ndef task_func(a, b):\n\n    pass\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nCOLUMNS = ['A', 'B', 'C', 'D', 'E']\ndef task_func(a, b):\n    # Determine the number of columns based on the length of list b\n    num_columns = len(b)\n    if num_columns > len(COLUMNS):\n        raise ValueError(f\"Length of list 'b' ({num_columns}) exceeds the number of predefined column names ({len(COLUMNS)}).\")\n    \n    # Generate random data\n    data = np.random.rand(len(a), num_columns)\n    \n    # Create DataFrame\n    df = pd.DataFrame(data, index=a, columns=COLUMNS[:num_columns])\n    \n    # Create bar chart\n    fig, ax = plt.subplots(figsize=(10, 6))\n    df.plot(kind='bar', ax=ax)\n    \n    # Customize the plot\n    ax.set_xlabel('Index')\n    ax.set_ylabel('Values')\n    ax.set_title('Bar Chart of Random Data')\n    ax.legend(title='Columns')\n    \n    # Rotate x-axis labels for better readability\n    plt.xticks(rotation=45, ha='right')\n    \n    # Adjust layout to prevent cutting off labels\n    plt.tight_layout()\n    \n    return ax",
        "status": "fail",
        "details": {
          "test_both_lists_empty": "Traceback (most recent call last):\n  File \"__test__.py\", line 59, in test_both_lists_empty\n  File \"__test__.py\", line 27, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_core.py\", line 975, in __call__\n    return plot_backend.plot(data, kind=kind, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/__init__.py\", line 71, in plot\n    plot_obj.generate()\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/core.py\", line 446, in generate\n    self._compute_plot_data()\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/core.py\", line 632, in _compute_plot_data\n    raise TypeError(\"no numeric data to plot\")\nTypeError: no numeric data to plot\n",
          "test_empty_a_list": "Traceback (most recent call last):\n  File \"__test__.py\", line 51, in test_empty_a_list\n  File \"__test__.py\", line 27, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_core.py\", line 975, in __call__\n    return plot_backend.plot(data, kind=kind, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/__init__.py\", line 71, in plot\n    plot_obj.generate()\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/core.py\", line 455, in generate\n    self._post_plot_logic(ax, self.data)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/core.py\", line 1750, in _post_plot_logic\n    s_edge = self.ax_pos[0] - 0.25 + self.lim_offset\nIndexError: index 0 is out of bounds for axis 0 with size 0\n",
          "test_empty_b_list": "Traceback (most recent call last):\n  File \"__test__.py\", line 55, in test_empty_b_list\n  File \"__test__.py\", line 27, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_core.py\", line 975, in __call__\n    return plot_backend.plot(data, kind=kind, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/__init__.py\", line 71, in plot\n    plot_obj.generate()\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/core.py\", line 446, in generate\n    self._compute_plot_data()\n  File \"/usr/local/lib/python3.10/site-packages/pandas/plotting/_matplotlib/core.py\", line 632, in _compute_plot_data\n    raise TypeError(\"no numeric data to plot\")\nTypeError: no numeric data to plot\n"
        }
      }
    ],
    "BigCodeBench/532": [
      {
        "task_id": "BigCodeBench/532",
        "solution": "import numpy as np\nfrom collections import Counter\nfrom scipy.stats import norm\nimport matplotlib.pyplot as plt\ndef task_func(df, bins=4):\n\n    pass\nimport numpy as np\nfrom collections import Counter\nfrom scipy.stats import norm\nimport matplotlib.pyplot as plt\ndef task_func(df, bins=4):\n    # Identify and count duplicate values\n    value_counts = df['value'].value_counts()\n    duplicates = Counter(value_counts[value_counts > 1].index)\n\n    # Create figure and axis\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Plot histogram\n    ax.hist(df['value'], bins=bins, density=True, alpha=0.6, color='green')\n\n    # Fit normal distribution\n    mu, std = norm.fit(df['value'])\n\n    # Generate points for normal distribution curve\n    xmin, xmax = ax.get_xlim()\n    x = np.linspace(xmin, xmax, 100)\n    p = norm.pdf(x, mu, std)\n\n    # Plot normal distribution curve\n    ax.plot(x, p, 'k', linewidth=2)\n\n    # Set labels and title\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Frequency')\n    ax.set_title('Distribution')\n\n    # Adjust layout to prevent clipping\n    plt.tight_layout()\n\n    return duplicates, ax",
        "status": "fail",
        "details": {
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 64, in test_case_2\nAssertionError: Counter({1: 1}) != Counter({1: 5})\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 76, in test_case_4\nAssertionError: Counter({5: 1, 1: 1, 2: 1, 3: 1}) != Counter({5: 4, 1: 4, 2: 3, 3: 2})\n"
        }
      }
    ],
    "BigCodeBench/567": [
      {
        "task_id": "BigCodeBench/567",
        "solution": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(data):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef task_func(data):\n    # Convert string data to numeric values\n    numeric_data = pd.to_numeric(data.split(), errors='coerce')\n    \n    # Remove any NaN values\n    numeric_data = numeric_data.dropna()\n    \n    # Calculate bin edges\n    bin_edges = np.arange(numeric_data.min(), numeric_data.max() + 2) - 0.5\n    \n    # Create the histogram\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.hist(numeric_data, bins=bin_edges, edgecolor='black')\n    \n    # Set labels and title\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Frequency')\n    ax.set_title('Histogram of Values')\n    \n    # Adjust layout to prevent cutoff\n    plt.tight_layout()\n    \n    return ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 37, in test_case_1\n  File \"__test__.py\", line 15, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'dropna'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 44, in test_case_2\n  File \"__test__.py\", line 15, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'dropna'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 51, in test_case_3\n  File \"__test__.py\", line 15, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'dropna'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in test_case_4\n  File \"__test__.py\", line 15, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'dropna'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 65, in test_case_5\n  File \"__test__.py\", line 15, in task_func\nAttributeError: 'numpy.ndarray' object has no attribute 'dropna'\n"
        }
      }
    ],
    "BigCodeBench/579": [
      {
        "task_id": "BigCodeBench/579",
        "solution": "import unicodedata\nimport csv\nfrom collections import Counter\nimport matplotlib.pyplot as plt\ndef task_func(csv_file):\n\n    pass\nimport unicodedata\nimport csv\nfrom collections import Counter\nimport matplotlib.pyplot as plt\ndef task_func(csv_file):\n    try:\n        # Read and normalize the CSV file content\n        with open(csv_file, 'r', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            normalized_text = ' '.join(\n                unicodedata.normalize('NFKD', cell)\n                .encode('ASCII', 'ignore')\n                .decode('ASCII')\n                .lower()\n                for row in reader\n                for cell in row\n            )\n\n        # Count words and get top 10\n        word_counts = Counter(normalized_text.split())\n        top_10 = word_counts.most_common(10)\n\n        # Create bar plot\n        fig, ax = plt.subplots(figsize=(10, 6))\n        words, counts = zip(*top_10)\n        ax.bar(words, counts)\n        ax.set_xlabel('Words')\n        ax.set_ylabel('Frequency')\n        ax.set_title('10 Most Common Words')\n        plt.xticks(rotation=45, ha='right')\n        plt.tight_layout()\n\n        return ax, top_10\n\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"The file '{csv_file}' was not found.\")\n    except IOError:\n        raise IOError(f\"An error occurred while reading the file '{csv_file}'.\")",
        "status": "fail",
        "details": {
          "test_normalized_text": "Traceback (most recent call last):\n  File \"__test__.py\", line 87, in test_normalized_text\n  File \"__test__.py\", line 38, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/pyplot.py\", line 2322, in tight_layout\n    return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/figure.py\", line 3494, in tight_layout\n    engine.execute(self)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/layout_engine.py\", line 175, in execute\n    kwargs = get_tight_layout_figure(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_tight_layout.py\", line 266, in get_tight_layout_figure\n    kwargs = _auto_adjust_subplotpars(fig, renderer,\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_tight_layout.py\", line 82, in _auto_adjust_subplotpars\n    bb += [martist._get_tightbbox_for_layout_only(ax, renderer)]\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/artist.py\", line 1415, in _get_tightbbox_for_layout_only\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axes/_base.py\", line 4387, in get_tightbbox\n    ba = martist._get_tightbbox_for_layout_only(axis, renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/artist.py\", line 1415, in _get_tightbbox_for_layout_only\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1320, in get_tightbbox\n    self._update_label_position(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 2308, in _update_label_position\n    bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 2104, in _get_tick_boxes_siblings\n    tlb, tlb2 = axis._get_ticklabel_bboxes(ticks_to_draw, renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1299, in _get_ticklabel_bboxes\n    return ([tick.label1.get_window_extent(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1299, in <listcomp>\n    return ([tick.label1.get_window_extent(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 959, in get_window_extent\n    bbox, info, descent = self._get_layout(self._renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 378, in _get_layout\n    _, lp_h, lp_d = _get_text_metrics_with_cache(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 97, in _get_text_metrics_with_cache\n    return _get_text_metrics_with_cache_impl(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 105, in _get_text_metrics_with_cache_impl\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py\", line 233, in get_text_width_height_descent\n    font = self._prepare_font(prop)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py\", line 267, in _prepare_font\n    font = get_font(_fontManager._find_fonts_by_props(font_prop))\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_api/deprecation.py\", line 297, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/font_manager.py\", line 1520, in get_font\n    return _get_font(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/font_manager.py\", line 1461, in _get_font\n    return ft2font.FT2Font(\nRuntimeError: In FT2Font: Can not load face (invalid stream operation; error code 0x55)\n",
          "test_plot_output": "Traceback (most recent call last):\n  File \"__test__.py\", line 80, in test_plot_output\n  File \"__test__.py\", line 38, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/pyplot.py\", line 2322, in tight_layout\n    return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/figure.py\", line 3494, in tight_layout\n    engine.execute(self)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/layout_engine.py\", line 175, in execute\n    kwargs = get_tight_layout_figure(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_tight_layout.py\", line 266, in get_tight_layout_figure\n    kwargs = _auto_adjust_subplotpars(fig, renderer,\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_tight_layout.py\", line 82, in _auto_adjust_subplotpars\n    bb += [martist._get_tightbbox_for_layout_only(ax, renderer)]\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/artist.py\", line 1415, in _get_tightbbox_for_layout_only\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axes/_base.py\", line 4387, in get_tightbbox\n    ba = martist._get_tightbbox_for_layout_only(axis, renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/artist.py\", line 1415, in _get_tightbbox_for_layout_only\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1320, in get_tightbbox\n    self._update_label_position(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 2308, in _update_label_position\n    bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 2104, in _get_tick_boxes_siblings\n    tlb, tlb2 = axis._get_ticklabel_bboxes(ticks_to_draw, renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1299, in _get_ticklabel_bboxes\n    return ([tick.label1.get_window_extent(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1299, in <listcomp>\n    return ([tick.label1.get_window_extent(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 959, in get_window_extent\n    bbox, info, descent = self._get_layout(self._renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 378, in _get_layout\n    _, lp_h, lp_d = _get_text_metrics_with_cache(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 97, in _get_text_metrics_with_cache\n    return _get_text_metrics_with_cache_impl(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 105, in _get_text_metrics_with_cache_impl\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py\", line 233, in get_text_width_height_descent\n    font = self._prepare_font(prop)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py\", line 267, in _prepare_font\n    font = get_font(_fontManager._find_fonts_by_props(font_prop))\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_api/deprecation.py\", line 297, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/font_manager.py\", line 1520, in get_font\n    return _get_font(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/font_manager.py\", line 1461, in _get_font\n    return ft2font.FT2Font(\nRuntimeError: In FT2Font: Can not load face (invalid stream operation; error code 0x55)\n",
          "test_valid_csv_file": "Traceback (most recent call last):\n  File \"__test__.py\", line 64, in test_valid_csv_file\n  File \"__test__.py\", line 38, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/pyplot.py\", line 2322, in tight_layout\n    return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/figure.py\", line 3494, in tight_layout\n    engine.execute(self)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/layout_engine.py\", line 175, in execute\n    kwargs = get_tight_layout_figure(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_tight_layout.py\", line 266, in get_tight_layout_figure\n    kwargs = _auto_adjust_subplotpars(fig, renderer,\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_tight_layout.py\", line 82, in _auto_adjust_subplotpars\n    bb += [martist._get_tightbbox_for_layout_only(ax, renderer)]\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/artist.py\", line 1415, in _get_tightbbox_for_layout_only\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axes/_base.py\", line 4387, in get_tightbbox\n    ba = martist._get_tightbbox_for_layout_only(axis, renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/artist.py\", line 1415, in _get_tightbbox_for_layout_only\n    return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1320, in get_tightbbox\n    self._update_label_position(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 2308, in _update_label_position\n    bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 2104, in _get_tick_boxes_siblings\n    tlb, tlb2 = axis._get_ticklabel_bboxes(ticks_to_draw, renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1299, in _get_ticklabel_bboxes\n    return ([tick.label1.get_window_extent(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/axis.py\", line 1299, in <listcomp>\n    return ([tick.label1.get_window_extent(renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 959, in get_window_extent\n    bbox, info, descent = self._get_layout(self._renderer)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 378, in _get_layout\n    _, lp_h, lp_d = _get_text_metrics_with_cache(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 97, in _get_text_metrics_with_cache\n    return _get_text_metrics_with_cache_impl(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/text.py\", line 105, in _get_text_metrics_with_cache_impl\n    return renderer_ref().get_text_width_height_descent(text, fontprop, ismath)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py\", line 233, in get_text_width_height_descent\n    font = self._prepare_font(prop)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/backends/backend_agg.py\", line 267, in _prepare_font\n    font = get_font(_fontManager._find_fonts_by_props(font_prop))\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/_api/deprecation.py\", line 297, in wrapper\n    return func(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/font_manager.py\", line 1520, in get_font\n    return _get_font(\n  File \"/usr/local/lib/python3.10/site-packages/matplotlib/font_manager.py\", line 1461, in _get_font\n    return ft2font.FT2Font(\nRuntimeError: In FT2Font: Can not load face (invalid stream operation; error code 0x55)\n"
        }
      }
    ],
    "BigCodeBench/574": [
      {
        "task_id": "BigCodeBench/574",
        "solution": "from scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\nimport numpy as np\ndef task_func(array_length=100, noise_level=0.2):\n\n    pass\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\nimport numpy as np\ndef task_func(array_length=100, noise_level=0.2):\n    # Generate x values\n    x = np.linspace(0, 2*np.pi, array_length)\n    \n    # Define the sine function to fit\n    def sine_func(x, A, B, C, D):\n        return A * np.sin(B * x + C) + D\n    \n    # Generate noisy sine wave data\n    true_A, true_B, true_C, true_D = 1.0, 1.0, 0.0, 0.0\n    y_true = sine_func(x, true_A, true_B, true_C, true_D)\n    noise = np.random.normal(0, noise_level, array_length)\n    y_noisy = y_true + noise\n    \n    # Fit the curve to the noisy data\n    popt, _ = curve_fit(sine_func, x, y_noisy, p0=[1, 1, 0, 0])\n    \n    # Generate the fitted curve\n    y_fit = sine_func(x, *popt)\n    \n    # Create the plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Plot the noisy data\n    ax.scatter(x, y_noisy, color='blue', alpha=0.5, label='Noisy Data')\n    \n    # Plot the fitted curve\n    ax.plot(x, y_fit, color='red', label='Fitted Curve')\n    \n    # Set labels and title\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    ax.set_title('Noisy Sine Wave with Fitted Curve')\n    \n    # Add legend\n    ax.legend()\n    \n    # Add text with fitted parameters\n    param_text = f'Fitted parameters:\\nA = {popt[0]:.2f}\\nB = {popt[1]:.2f}\\nC = {popt[2]:.2f}\\nD = {popt[3]:.2f}'\n    ax.text(0.05, 0.95, param_text, transform=ax.transAxes, verticalalignment='top', fontsize=10, bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))\n    \n    # Adjust layout\n    plt.tight_layout()\n    \n    return ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_case_1\nAssertionError: 1 != 2\n"
        }
      }
    ],
    "BigCodeBench/582": [
      {
        "task_id": "BigCodeBench/582",
        "solution": "import numpy as np\nfrom scipy import stats\nimport matplotlib.pyplot as plt\ndef task_func(size=1000):\n\n    pass\nimport numpy as np\nfrom scipy import stats\nimport matplotlib.pyplot as plt\ndef task_func(size=1000):\n    # Generate normally distributed random numbers\n    mu, sigma = 0, 1  # mean and standard deviation\n    data = np.random.normal(mu, sigma, size)\n\n    # Create a figure and axis\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Plot histogram\n    n, bins, patches = ax.hist(data, bins=30, density=True, alpha=0.7, color='skyblue', edgecolor='black')\n\n    # Calculate the PDF\n    xmin, xmax = ax.get_xlim()\n    x = np.linspace(xmin, xmax, 100)\n    p = stats.norm.pdf(x, mu, sigma)\n\n    # Plot the PDF\n    ax.plot(x, p, 'r-', lw=2, label='Normal PDF')\n\n    # Customize the plot\n    ax.set_title('Histogram and PDF of Normally Distributed Random Numbers')\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Density')\n    ax.legend()\n\n    # Adjust layout\n    plt.tight_layout()\n\n    return fig",
        "status": "fail",
        "details": {
          "test_histogram_pdf_overlay": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in test_histogram_pdf_overlay\nAssertionError: 30 != 28 : Number of histogram bins does not match expected\n"
        }
      }
    ],
    "BigCodeBench/590": [
      {
        "task_id": "BigCodeBench/590",
        "solution": "import urllib.request\nfrom pyquery import PyQuery as pq\nfrom datetime import datetime\nimport pandas as pd\ndef task_func(url):\n\n    pass\nimport urllib.request\nfrom pyquery import PyQuery as pq\nfrom datetime import datetime\nimport pandas as pd\nfrom urllib.error import URLError\ndef task_func(url):\n    \"\"\"\n    Extracts the text and href attributes of all anchor tags from a given URL's HTML content,\n    and returns this data in a pandas DataFrame along with the time of data extraction.\n\n    Args:\n        url (str): The URL from which to fetch HTML content.\n\n    Returns:\n        pandas.DataFrame: A DataFrame with columns 'text', 'href', and 'fetch_time'. Each row\n        corresponds to an anchor tag in the HTML, with 'text' and 'href' containing\n        the text and the hyperlink reference of the anchor tag, respectively.\n        'fetch_time' contains the timestamp of when the data was fetched in the format\n        'YYYY-MM-DD HH:MM:SS'.\n\n    Raises:\n        ValueError: If the provided URL is invalid or empty.\n        URLError: If there is an issue with network connectivity or the server.\n    \"\"\"\n    if not url or not url.startswith(('http://', 'https://')):\n        raise ValueError(\"Invalid or empty URL provided\")\n\n    try:\n        with urllib.request.urlopen(url) as response:\n            html_content = response.read()\n\n        doc = pq(html_content)\n        anchors = doc('a')\n\n        data = []\n        for anchor in anchors.items():\n            text = anchor.text()\n            href = anchor.attr('href')\n            if href:  # Only include anchors with non-empty href\n                data.append({'text': text, 'href': href})\n\n        fetch_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n\n        df = pd.DataFrame(data)\n        df['fetch_time'] = fetch_time\n\n        return df[['text', 'href', 'fetch_time']]\n\n    except URLError as e:\n        raise URLError(f\"Network error or server issue: {str(e)}\")\n    except Exception as e:\n        raise Exception(f\"An unexpected error occurred: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_dynamic_comparison": "Traceback (most recent call last):\n  File \"__test__.py\", line 102, in test_dynamic_comparison\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 1163, in assert_frame_equal\n    raise_assert_detail(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/_testing/asserters.py\", line 599, in raise_assert_detail\n    raise AssertionError(msg)\nAssertionError: DataFrame are different\n\nDataFrame shape mismatch\n[left]:  (266, 2)\n[right]: (267, 2)\n"
        }
      }
    ],
    "BigCodeBench/592": [
      {
        "task_id": "BigCodeBench/592",
        "solution": "import csv\nimport os\nfrom datetime import datetime\nfrom random import randint\n# Constants\nSENSORS = ['Temperature', 'Humidity', 'Pressure']\nOUTPUT_DIR = './output'\ndef task_func(hours, output_dir=OUTPUT_DIR):\n\n    pass\nimport csv\nimport os\nfrom datetime import datetime, timedelta\nfrom random import randint, uniform\nSENSORS = ['Temperature', 'Humidity', 'Pressure']\nOUTPUT_DIR = './output'\ndef task_func(hours, output_dir=OUTPUT_DIR):\n    # Ensure output directory exists\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Generate filename with timestamp\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"sensor_data_{timestamp}.csv\"\n    filepath = os.path.join(output_dir, filename)\n\n    # Generate sensor data\n    data = []\n    start_time = datetime.now()\n    for i in range(hours * 60):  # Generate data for every minute\n        current_time = start_time + timedelta(minutes=i)\n        temperature = round(uniform(20.0, 30.0), 1)  # Temperature between 20.0\u00b0C and 30.0\u00b0C\n        humidity = randint(30, 70)  # Humidity between 30% and 70%\n        pressure = randint(980, 1020)  # Pressure between 980 hPa and 1020 hPa\n        data.append([current_time.strftime(\"%Y-%m-%d %H:%M:%S\"), temperature, humidity, pressure])\n\n    # Write data to CSV file\n    with open(filepath, 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(['Time'] + SENSORS)\n        writer.writerows(data)\n\n    print(f\"Sensor data for {hours} hours has been saved to {filepath}\")",
        "status": "fail",
        "details": {
          "test_csv_file_creation": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in test_csv_file_creation\nAssertionError: False is not true\n",
          "test_file_path_return": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_file_path_return\nAssertionError: None != './output/sensor_data.csv'\n",
          "test_csv_file_header": "Traceback (most recent call last):\n  File \"__test__.py\", line 67, in test_csv_file_header\nFileNotFoundError: [Errno 2] No such file or directory: './output/sensor_data.csv'\n",
          "test_csv_file_rows": "Traceback (most recent call last):\n  File \"__test__.py\", line 62, in test_csv_file_rows\nFileNotFoundError: [Errno 2] No such file or directory: './output/sensor_data.csv'\n",
          "test_no_hours_data": "Traceback (most recent call last):\n  File \"__test__.py\", line 78, in test_no_hours_data\nFileNotFoundError: [Errno 2] No such file or directory: './output/sensor_data.csv'\n"
        }
      }
    ],
    "BigCodeBench/99": [
      {
        "task_id": "BigCodeBench/99",
        "solution": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn.datasets import load_iris\ndef task_func():\n\n    pass\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn.datasets import load_iris\ndef task_func():\n    # Set global font to Arial\n    plt.rcParams['font.family'] = 'Arial'\n\n    # Load the iris dataset\n    iris = load_iris()\n    iris_df = pd.DataFrame(iris.data, columns=iris.feature_names)\n    iris_df['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)\n\n    # Create the pair plot\n    g = sns.pairplot(iris_df, hue='species', height=2.5)\n\n    # Set the title\n    g.fig.suptitle('Iris Dataset Pair Plot', fontsize=16, y=1.02)\n\n    # Adjust feature names for better readability\n    for ax in g.axes.flatten():\n        if ax.get_xlabel():\n            ax.set_xlabel(ax.get_xlabel().replace(' (cm)', '\\n(cm)'), fontsize=10)\n        if ax.get_ylabel():\n            ax.set_ylabel(ax.get_ylabel().replace(' (cm)', '\\n(cm)'), fontsize=10)\n\n    # Adjust layout\n    plt.tight_layout()\n\n    return g.fig",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/593": [
      {
        "task_id": "BigCodeBench/593",
        "solution": "import csv\nimport os\nfrom datetime import datetime\nfrom random import randint\nimport matplotlib.pyplot as plt\nimport pandas as pd\n# Constants\nVEHICLE_TYPES = ['Car', 'Bus', 'Truck', 'Bike']\nOUTPUT_DIR = './output'\ndef task_func(hours, output_dir=OUTPUT_DIR):\n\n    pass\nimport csv\nimport os\nfrom datetime import datetime, timedelta\nfrom random import randint\nimport matplotlib.pyplot as plt\nimport pandas as pd\nVEHICLE_TYPES = ['Car', 'Bus', 'Truck', 'Bike']\nOUTPUT_DIR = './output'\ndef task_func(hours, output_dir=OUTPUT_DIR):\n    # Ensure output directory exists\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Generate traffic data\n    start_time = datetime.now().replace(minute=0, second=0, microsecond=0)\n    data = []\n    for i in range(hours):\n        current_time = start_time + timedelta(hours=i)\n        row = [current_time.strftime('%Y-%m-%d %H:%M:%S')]\n        row.extend([randint(0, 100) for _ in VEHICLE_TYPES])\n        data.append(row)\n\n    # Create CSV file\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    csv_filename = os.path.join(output_dir, f'traffic_data_{timestamp}.csv')\n    with open(csv_filename, 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(['Time'] + VEHICLE_TYPES)\n        writer.writerows(data)\n\n    # Read CSV file using pandas\n    df = pd.read_csv(csv_filename, parse_dates=['Time'])\n\n    # Create line plot\n    fig, ax = plt.subplots(figsize=(12, 6))\n    for vehicle_type in VEHICLE_TYPES:\n        ax.plot(df['Time'], df[vehicle_type], label=vehicle_type)\n\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Vehicle Count')\n    ax.set_title('Traffic Data by Vehicle Type')\n    ax.legend()\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n\n    # Save plot\n    plot_filename = os.path.join(output_dir, f'traffic_plot_{timestamp}.png')\n    plt.savefig(plot_filename)\n\n    return csv_filename, ax",
        "status": "fail",
        "details": {
          "test_dataframe_content": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 88, in test_dataframe_content\nAssertionError: './output/traffic_data_20240819_153602.csv' != './output/traffic_data.csv'\n- ./output/traffic_data_20240819_153602.csv\n?                      ----------------\n+ ./output/traffic_data.csv\n\n",
          "test_directory_creation": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 104, in test_directory_creation\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 929, in assert_called_with\n    raise AssertionError(_error_message()) from cause\nAssertionError: expected call not found.\nExpected: makedirs('./output')\nActual: makedirs('./output', exist_ok=True)\n",
          "test_empty_dataframe_on_zero_hours": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 96, in test_empty_dataframe_on_zero_hours\nAssertionError: <Axes: title={'center': 'Traffic Data by Vehicle Type'}, xlabel='Time', ylabel='Vehicle Count'> is not None\n",
          "test_plot_generation": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 109, in test_plot_generation\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 898, in assert_called\n    raise AssertionError(msg)\nAssertionError: Expected 'show' to have been called.\n"
        }
      }
    ],
    "BigCodeBench/594": [
      {
        "task_id": "BigCodeBench/594",
        "solution": "import csv\nimport os\nimport shutil\nfrom datetime import datetime\nfrom random import randint\n# Constants\nWEATHER_CONDITIONS = ['Sunny', 'Cloudy', 'Rainy', 'Snowy', 'Stormy']\nOUTPUT_DIR = './output'\ndef task_func(hours, output_dir=OUTPUT_DIR):\n\n    pass\nimport csv\nimport os\nimport shutil\nfrom datetime import datetime, timedelta\nfrom random import randint\nWEATHER_CONDITIONS = ['Sunny', 'Cloudy', 'Rainy', 'Snowy', 'Stormy']\nOUTPUT_DIR = './output'\ndef task_func(hours, output_dir=OUTPUT_DIR):\n    # Ensure output directory exists\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Generate filename with timestamp\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"weather_data_{timestamp}.csv\"\n    filepath = os.path.join(output_dir, filename)\n\n    # Generate weather data\n    start_time = datetime.now()\n    weather_data = [\n        (start_time + timedelta(hours=i), WEATHER_CONDITIONS[randint(0, len(WEATHER_CONDITIONS) - 1)])\n        for i in range(hours)\n    ]\n\n    # Write data to CSV file\n    with open(filepath, 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(['Time', 'Condition'])  # Header\n        for time, condition in weather_data:\n            writer.writerow([time.strftime(\"%Y-%m-%d %H:%M:%S\"), condition])\n\n    # Create backup directory and copy file\n    backup_dir = os.path.join(output_dir, 'backup')\n    os.makedirs(backup_dir, exist_ok=True)\n    backup_filepath = os.path.join(backup_dir, filename)\n    shutil.copy2(filepath, backup_filepath)\n\n    return filepath",
        "status": "fail",
        "details": {
          "test_backup_file_creation": "Traceback (most recent call last):\n  File \"__test__.py\", line 109, in test_backup_file_creation\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 940, in assert_called_once_with\n    raise AssertionError(msg)\nAssertionError: Expected 'copy' to be called once. Called 0 times.\n",
          "test_task_func_checks_backup_directory_exists": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 79, in test_task_func_checks_backup_directory_exists\nAssertionError: 'output/backup' != 'output'\n- output/backup\n+ output\n : Expected output/backup, got output\n",
          "test_task_func_copies_to_backup_directory": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 87, in test_task_func_copies_to_backup_directory\nTypeError: 'NoneType' object is not subscriptable\n",
          "test_task_func_writes_correct_header": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/shutil.py\", line 142, in _fastcopy_sendfile\n    sent = os.sendfile(outfd, infd, offset, blocksize)\nOSError: [Errno 9] Bad file descriptor: <MagicMock name='open().name' id='46916725241216'> -> <MagicMock name='open().name' id='46916725241216'>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 98, in test_task_func_writes_correct_header\n  File \"__test__.py\", line 46, in task_func\n  File \"/usr/local/lib/python3.10/shutil.py\", line 434, in copy2\n    copyfile(src, dst, follow_symlinks=follow_symlinks)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 267, in copyfile\n    _fastcopy_sendfile(fsrc, fdst)\n  File \"/usr/local/lib/python3.10/shutil.py\", line 159, in _fastcopy_sendfile\n    if offset == 0 and os.lseek(outfd, 0, os.SEEK_CUR) == 0:\nOSError: [Errno 29] Illegal seek\n"
        }
      }
    ],
    "BigCodeBench/636": [
      {
        "task_id": "BigCodeBench/636",
        "solution": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n# Constants\nCOLUMNS = ['Column1', 'Column2', 'Column3', 'Column4', 'Column5']\ndef task_func(rows):\n\n    pass\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nCOLUMNS = ['Column1', 'Column2', 'Column3', 'Column4', 'Column5']\ndef task_func(rows):\n    # Create a DataFrame with random integer values between 0 and 9\n    df = pd.DataFrame(np.random.randint(0, 10, size=(rows, len(COLUMNS))), columns=COLUMNS)\n    \n    # Count non-zero values in each column\n    non_zero_counts = (df != 0).sum()\n    \n    # Create a bar plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    non_zero_counts.plot(kind='bar', ax=ax, color='skyblue', edgecolor='navy')\n    \n    # Customize the plot\n    ax.set_title('Non-Zero Value Counts by Column', fontsize=16, fontweight='bold')\n    ax.set_xlabel('Columns', fontsize=12)\n    ax.set_ylabel('Count of Non-Zero Values', fontsize=12)\n    ax.set_ylim(0, rows)\n    ax.tick_params(axis='both', which='major', labelsize=10)\n    \n    # Add value labels on top of each bar\n    for i, v in enumerate(non_zero_counts):\n        ax.text(i, v + (rows * 0.01), str(v), ha='center', va='bottom', fontsize=10, fontweight='bold')\n    \n    # Add grid lines for better readability\n    ax.yaxis.grid(True, linestyle='--', alpha=0.7)\n    \n    # Remove top and right spines\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    \n    # Adjust layout\n    plt.tight_layout()\n    \n    return df, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 53, in test_case_1\nAssertionError: 5 != 0\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_case_4\n  File \"__test__.py\", line 15, in task_func\n  File \"mtrand.pyx\", line 748, in numpy.random.mtrand.RandomState.randint\n  File \"_bounded_integers.pyx\", line 1256, in numpy.random._bounded_integers._rand_int64\nValueError: negative dimensions are not allowed\n"
        }
      }
    ],
    "BigCodeBench/618": [
      {
        "task_id": "BigCodeBench/618",
        "solution": "from random import randint\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n# Constants\nTEAMS = ['Team A', 'Team B', 'Team C', 'Team D', 'Team E']\nPENALTY_COST = 1000  # in dollars\ndef task_func(goals, penalties):\n\n    pass\nfrom random import randint\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nTEAMS = ['Team A', 'Team B', 'Team C', 'Team D', 'Team E']\nPENALTY_COST = 1000\ndef task_func(goals, penalties):\n    # Generate match data\n    data = []\n    for _ in range(goals):\n        team = TEAMS[randint(0, len(TEAMS) - 1)]\n        goals_scored = randint(0, 5)\n        penalties_awarded = randint(0, penalties)\n        data.append({\n            'Team': team,\n            'Goals': goals_scored,\n            'Penalties': penalties_awarded,\n            'Penalty Cost': penalties_awarded * PENALTY_COST\n        })\n\n    # Create DataFrame\n    df = pd.DataFrame(data)\n\n    # Aggregate data by team\n    df_agg = df.groupby('Team').agg({\n        'Goals': 'sum',\n        'Penalty Cost': 'sum'\n    }).reset_index()\n\n    # Create plots\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\n    # Goals plot\n    sns_plot1 = sns.barplot(x='Team', y='Goals', data=df_agg, ax=ax1)\n    ax1.set_title('Total Goals by Team')\n    ax1.set_ylabel('Goals')\n    ax1.tick_params(axis='x', rotation=45)\n\n    # Penalty Cost plot\n    sns_plot2 = sns.barplot(x='Team', y='Penalty Cost', data=df_agg, ax=ax2)\n    ax2.set_title('Total Penalty Costs by Team')\n    ax2.set_ylabel('Penalty Cost ($)')\n    ax2.tick_params(axis='x', rotation=45)\n\n    plt.tight_layout()\n\n    return df, [sns_plot1, sns_plot2]",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in test_case_1\nAssertionError: Tuples differ: (5, 4) != (5, 3)\n\nFirst differing element 1:\n4\n3\n\n- (5, 4)\n?     ^\n\n+ (5, 3)\n?     ^\n\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 110, in test_case_5\nAssertionError: False is not true\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 80, in test_case_2\n  File \"__test__.py\", line 35, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 8252, in groupby\n    return DataFrameGroupBy(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/groupby/groupby.py\", line 931, in __init__\n    grouper, exclusions, obj = get_grouper(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/groupby/grouper.py\", line 985, in get_grouper\n    raise KeyError(gpr)\nKeyError: 'Team'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 99, in test_case_4\n  File \"__test__.py\", line 35, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 8252, in groupby\n    return DataFrameGroupBy(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/groupby/groupby.py\", line 931, in __init__\n    grouper, exclusions, obj = get_grouper(\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/groupby/grouper.py\", line 985, in get_grouper\n    raise KeyError(gpr)\nKeyError: 'Team'\n"
        }
      }
    ],
    "BigCodeBench/637": [
      {
        "task_id": "BigCodeBench/637",
        "solution": "from random import sample\nfrom typing import Tuple\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\ndef task_func(num_students):\n\n    pass\nfrom random import sample\nfrom typing import Tuple\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\ndef task_func(num_students: int) -> Tuple[pd.DataFrame, plt.Axes]:\n    # Define courses\n    courses = ['Math', 'Science', 'English', 'History', 'Art']\n    \n    # Generate random student names\n    names = [f'Student_{i}' for i in range(1, num_students + 1)]\n    \n    # Generate random grades for each student in each course\n    data = {\n        course: np.random.randint(0, 101, size=num_students)\n        for course in courses\n    }\n    \n    # Create DataFrame\n    df = pd.DataFrame(data, index=names)\n    \n    # Calculate average grade and number of passing students for each course\n    avg_grades = df.mean()\n    passing_counts = (df >= 60).sum()\n    \n    # Create a figure and axis for the plot\n    fig, ax = plt.subplots(figsize=(12, 6))\n    \n    # Set the width of each bar and the positions of the bars\n    width = 0.35\n    x = np.arange(len(courses))\n    \n    # Create the bars\n    ax.bar(x - width/2, avg_grades, width, label='Average Grade', color='skyblue')\n    ax.bar(x + width/2, passing_counts, width, label='Passing Students', color='lightgreen')\n    \n    # Customize the plot\n    ax.set_ylabel('Score / Count')\n    ax.set_title('Course-wise Average and Passing Grade Counts')\n    ax.set_xticks(x)\n    ax.set_xticklabels(courses)\n    ax.legend()\n    \n    # Add value labels on top of each bar\n    for i, v in enumerate(avg_grades):\n        ax.text(i - width/2, v, f'{v:.1f}', ha='center', va='bottom')\n    for i, v in enumerate(passing_counts):\n        ax.text(i + width/2, v, str(v), ha='center', va='bottom')\n    \n    # Adjust layout\n    plt.tight_layout()\n    \n    return df, ax",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/654": [
      {
        "task_id": "BigCodeBench/654",
        "solution": "import matplotlib.pyplot as plt\nimport scipy.optimize as optimize\nimport numpy as np\ndef task_func(array, target_value):\n\n    pass\nimport matplotlib.pyplot as plt\nimport scipy.optimize as optimize\nimport numpy as np\ndef task_func(array, target_value):\n    # Find indices where the first column matches the target value\n    indices = np.where(array[:, 0] == target_value)[0]\n    y_data = array[indices, 1]\n    \n    # Define exponential decay function\n    def exp_decay(x, a, b, c):\n        return a * np.exp(-b * x) + c\n    \n    # Initial parameter guess\n    p0 = [np.max(y_data), 0.1, np.min(y_data)]\n    \n    # Fit the exponential decay function\n    popt, _ = optimize.curve_fit(exp_decay, indices, y_data, p0=p0)\n    \n    # Create plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Plot original data points\n    ax.scatter(indices, y_data, color='blue', label='Data')\n    \n    # Plot fitted curve\n    x_fit = np.linspace(np.min(indices), np.max(indices), 100)\n    y_fit = exp_decay(x_fit, *popt)\n    ax.plot(x_fit, y_fit, 'r-', label='Fitted Curve')\n    \n    # Set labels and title\n    ax.set_xlabel('Index')\n    ax.set_ylabel('Value')\n    ax.set_title(f'Exponential Decay Fit for Target Value: {target_value}')\n    ax.legend()\n    \n    return (popt, ax)",
        "status": "fail",
        "details": {
          "test_functionality": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_functionality\n  File \"__test__.py\", line 20, in task_func\n  File \"<__array_function__ internals>\", line 5, in amax\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 2754, in amax\n    return _wrapreduction(a, np.maximum, 'max', axis, None, out,\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 86, in _wrapreduction\n    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)\nTypeError: cannot perform reduce with flexible type\n",
          "test_not_enough_points": "Traceback (most recent call last):\n  File \"__test__.py\", line 71, in test_not_enough_points\n  File \"__test__.py\", line 13, in task_func\nIndexError: index 1 is out of bounds for axis 1 with size 1\n",
          "test_return_types": "Traceback (most recent call last):\n  File \"__test__.py\", line 56, in test_return_types\n  File \"__test__.py\", line 20, in task_func\n  File \"<__array_function__ internals>\", line 5, in amax\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 2754, in amax\n    return _wrapreduction(a, np.maximum, 'max', axis, None, out,\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 86, in _wrapreduction\n    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)\nTypeError: cannot perform reduce with flexible type\n",
          "test_target_value_found": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_target_value_found\n  File \"__test__.py\", line 20, in task_func\n  File \"<__array_function__ internals>\", line 5, in amax\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 2754, in amax\n    return _wrapreduction(a, np.maximum, 'max', axis, None, out,\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 86, in _wrapreduction\n    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)\nTypeError: cannot perform reduce with flexible type\n",
          "test_target_value_not_found": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_target_value_not_found\n  File \"__test__.py\", line 20, in task_func\n  File \"<__array_function__ internals>\", line 5, in amax\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 2754, in amax\n    return _wrapreduction(a, np.maximum, 'max', axis, None, out,\n  File \"/usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py\", line 86, in _wrapreduction\n    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)\nTypeError: cannot perform reduce with flexible type\n"
        }
      }
    ],
    "BigCodeBench/655": [
      {
        "task_id": "BigCodeBench/655",
        "solution": "import re\nimport nltk\nfrom sklearn.decomposition import NMF\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n# Ensure nltk's stopwords are downloaded\nnltk.download('stopwords')\n# Constants\nALPHANUMERIC = re.compile('[\\W_]+')\nSTOPWORDS = nltk.corpus.stopwords.words('english')\ndef task_func(texts, num_topics):\n\n    pass\nimport re\nimport nltk\nfrom sklearn.decomposition import NMF\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nALPHANUMERIC = re.compile('[\\W_]+')\nSTOPWORDS = nltk.corpus.stopwords.words('english')\ndef task_func(texts, num_topics):\n    # Preprocess the texts\n    processed_texts = []\n    for text in texts:\n        # Remove non-alphanumeric characters and convert to lowercase\n        text = ALPHANUMERIC.sub(' ', text.lower())\n        # Remove stopwords\n        words = [word for word in text.split() if word not in STOPWORDS]\n        processed_texts.append(' '.join(words))\n\n    # Vectorize the processed texts using TF-IDF\n    vectorizer = TfidfVectorizer(max_df=0.95, min_df=2, stop_words='english')\n    tfidf_matrix = vectorizer.fit_transform(processed_texts)\n\n    # Apply NMF\n    nmf_model = NMF(n_components=num_topics, random_state=42)\n    nmf_output = nmf_model.fit_transform(tfidf_matrix)\n\n    # Get feature names (words) from the vectorizer\n    feature_names = vectorizer.get_feature_names_out()\n\n    # Extract topics\n    topics = []\n    for topic_idx, topic in enumerate(nmf_model.components_):\n        top_words_idx = topic.argsort()[:-11:-1]  # Get indices of top 10 words\n        top_words = [feature_names[i] for i in top_words_idx]\n        topics.append(top_words)\n\n    return topics",
        "status": "fail",
        "details": {
          "test_all_stopwords": "Traceback (most recent call last):\n  File \"__test__.py\", line 77, in test_all_stopwords\n  File \"__test__.py\", line 31, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 2139, in fit_transform\n    X = super().fit_transform(raw_documents)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/base.py\", line 1152, in wrapper\n    return fit_method(estimator, *args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 1389, in fit_transform\n    vocabulary, X = self._count_vocab(raw_documents, self.fixed_vocabulary_)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 1295, in _count_vocab\n    raise ValueError(\nValueError: empty vocabulary; perhaps the documents only contain stop words\n",
          "test_empty_texts": "Traceback (most recent call last):\n  File \"__test__.py\", line 67, in test_empty_texts\n  File \"__test__.py\", line 31, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 2139, in fit_transform\n    X = super().fit_transform(raw_documents)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/base.py\", line 1152, in wrapper\n    return fit_method(estimator, *args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 1389, in fit_transform\n    vocabulary, X = self._count_vocab(raw_documents, self.fixed_vocabulary_)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 1295, in _count_vocab\n    raise ValueError(\nValueError: empty vocabulary; perhaps the documents only contain stop words\n",
          "test_single_text": "Traceback (most recent call last):\n  File \"__test__.py\", line 72, in test_single_text\n  File \"__test__.py\", line 31, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 2139, in fit_transform\n    X = super().fit_transform(raw_documents)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/base.py\", line 1152, in wrapper\n    return fit_method(estimator, *args, **kwargs)\n  File \"/usr/local/lib/python3.10/site-packages/sklearn/feature_extraction/text.py\", line 1399, in fit_transform\n    raise ValueError(\"max_df corresponds to < documents than min_df\")\nValueError: max_df corresponds to < documents than min_df\n"
        }
      }
    ],
    "BigCodeBench/657": [
      {
        "task_id": "BigCodeBench/657",
        "solution": "import re\nimport nltk\nfrom gensim.models import Word2Vec\n# Constants\nALPHANUMERIC = re.compile('[\\W_]+')\ndef task_func(texts, stopwords=None):\n\n    pass\nimport re\nimport nltk\nfrom gensim.models import Word2Vec\nfrom nltk.corpus import stopwords as nltk_stopwords\nALPHANUMERIC = re.compile('[\\W_]+')\ndef task_func(texts, stopwords=None):\n    # Download NLTK stopwords if not already downloaded\n    nltk.download('stopwords', quiet=True)\n    \n    # If stopwords are not provided, use NLTK's English stopwords\n    if stopwords is None:\n        stopwords = set(nltk_stopwords.words('english'))\n\n    # Clean and tokenize the texts\n    cleaned_texts = []\n    for text in texts:\n        # Remove non-alphanumeric characters and convert to lowercase\n        cleaned_text = ALPHANUMERIC.sub(' ', text.lower())\n        \n        # Tokenize the text\n        tokens = cleaned_text.split()\n        \n        # Remove stopwords\n        tokens = [token for token in tokens if token not in stopwords]\n        \n        cleaned_texts.append(tokens)\n\n    # Train the Word2Vec model\n    model = Word2Vec(sentences=cleaned_texts, vector_size=100, window=5, min_count=1, workers=4)\n\n    return model",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in test_case_3\n  File \"__test__.py\", line 37, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/gensim/models/word2vec.py\", line 430, in __init__\n    self.train(\n  File \"/usr/local/lib/python3.10/site-packages/gensim/models/word2vec.py\", line 1045, in train\n    self._check_training_sanity(epochs=epochs, total_examples=total_examples, total_words=total_words)\n  File \"/usr/local/lib/python3.10/site-packages/gensim/models/word2vec.py\", line 1554, in _check_training_sanity\n    raise RuntimeError(\"you must first build vocabulary before training the model\")\nRuntimeError: you must first build vocabulary before training the model\n"
        }
      }
    ],
    "BigCodeBench/678": [
      {
        "task_id": "BigCodeBench/678",
        "solution": "import pandas as pd\nimport json\nimport os\nimport shutil\ndef task_func(path):\n\n    pass\nimport pandas as pd\nimport json\nimport os\nimport shutil\ndef task_func(path):\n    # Create the directory and 'processed' subdirectory if they don't exist\n    os.makedirs(os.path.join(path, 'processed'), exist_ok=True)\n    \n    # Get a sorted list of JSON files in the directory\n    json_files = sorted([f for f in os.listdir(path) if f.endswith('.json')])\n    \n    dfs = []\n    \n    for file in json_files:\n        file_path = os.path.join(path, file)\n        \n        # Read JSON file into a DataFrame\n        with open(file_path, 'r') as f:\n            data = json.load(f)\n        df = pd.DataFrame(data)\n        \n        # Add 'Source' column with the filename\n        df['Source'] = file\n        \n        dfs.append(df)\n        \n        # Move processed file to 'processed' subdirectory\n        shutil.move(file_path, os.path.join(path, 'processed', file))\n    \n    # Combine all DataFrames\n    if dfs:\n        final_df = pd.concat(dfs, ignore_index=True)\n    else:\n        final_df = pd.DataFrame()\n    \n    return final_df",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/720": [
      {
        "task_id": "BigCodeBench/720",
        "solution": "import os\nimport csv\nimport random\nfrom datetime import datetime\ndef task_func():\n\n    pass\nimport os\nimport csv\nimport random\nfrom datetime import datetime\ndef task_func():\n    # Define the file path\n    file_path = \"task_func_data/Output.txt\"\n    \n    # Create the directory if it doesn't exist\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    \n    # Generate random sensor data\n    num_entries = random.randint(5, 15)\n    sensor_data = []\n    for _ in range(num_entries):\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        temperature = round(random.uniform(15.0, 35.0), 1)\n        humidity = round(random.uniform(30.0, 80.0), 1)\n        sensor_data.append([timestamp, temperature, humidity])\n    \n    # Write data to CSV file in append mode\n    with open(file_path, 'a', newline='') as csvfile:\n        writer = csv.writer(csvfile)\n        if os.path.getsize(file_path) == 0:\n            writer.writerow(['Timestamp', 'Temperature (\u00b0C)', 'Humidity (%)'])\n        writer.writerows(sensor_data)\n    \n    # Store the absolute file path before deletion\n    result_path = os.path.abspath(file_path)\n    \n    # Delete the file\n    os.remove(file_path)\n    \n    # Return the path to the CSV file before deletion\n    return result_path",
        "status": "fail",
        "details": {
          "test_file_existence": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in tearDown\nFileNotFoundError: [Errno 2] No such file or directory: 'task_func_data/Output.txt'\n",
          "test_return_value": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in tearDown\nFileNotFoundError: [Errno 2] No such file or directory: 'task_func_data/Output.txt'\n",
          "test_data_appending": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in tearDown\nFileNotFoundError: [Errno 2] No such file or directory: 'task_func_data/Output.txt'\n",
          "test_file_content": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in tearDown\nFileNotFoundError: [Errno 2] No such file or directory: 'task_func_data/Output.txt'\n",
          "test_headers_only_once": "Traceback (most recent call last):\n  File \"__test__.py\", line 58, in tearDown\nFileNotFoundError: [Errno 2] No such file or directory: 'task_func_data/Output.txt'\n"
        }
      }
    ],
    "BigCodeBench/723": [
      {
        "task_id": "BigCodeBench/723",
        "solution": "import urllib.request\nfrom bs4 import BeautifulSoup\nimport csv\nimport os\n# Constants\nCSV_FILE_PATH = 'scraped_data.csv'\ndef task_func(url):\n\n    pass\nimport urllib.request\nfrom bs4 import BeautifulSoup\nimport csv\nimport os\nCSV_FILE_PATH = 'scraped_data.csv'\ndef task_func(url):\n    # Fetch the HTML content from the URL\n    try:\n        with urllib.request.urlopen(url) as response:\n            html_content = response.read()\n    except urllib.error.URLError as e:\n        print(f\"Error fetching URL: {e}\")\n        return None\n\n    # Parse the HTML content\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    # Extract data (example: title, headings, and paragraphs)\n    title = soup.title.string if soup.title else \"No title\"\n    headings = [h.text.strip() for h in soup.find_all(['h1', 'h2', 'h3'])]\n    paragraphs = [p.text.strip() for p in soup.find_all('p')]\n\n    # Prepare data for CSV\n    data = [\n        [\"Title\", title],\n        [\"Headings\"] + headings,\n        [\"Paragraphs\"] + paragraphs\n    ]\n\n    # Save data to CSV file\n    try:\n        with open(CSV_FILE_PATH, 'w', newline='', encoding='utf-8') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerows(data)\n        \n        print(f\"Data successfully saved to {CSV_FILE_PATH}\")\n        return CSV_FILE_PATH\n    except IOError as e:\n        print(f\"Error writing to CSV file: {e}\")\n        return None",
        "status": "fail",
        "details": {
          "test_correct_scraping": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 66, in test_correct_scraping\n  File \"__test__.py\", line 25, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n",
          "test_empty_table": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 79, in test_empty_table\n  File \"__test__.py\", line 25, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n",
          "test_overwrite_existing_csv": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 100, in test_overwrite_existing_csv\n  File \"__test__.py\", line 25, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n"
        }
      }
    ],
    "BigCodeBench/760": [
      {
        "task_id": "BigCodeBench/760",
        "solution": "import pandas as pd\nimport numpy as np\nimport codecs\nimport re\nimport datetime\ndef task_func(start_year=1980, end_year=2000, email_domain='example.com',\n           latin_names=['Sopet\u00f3n', 'M\u00e9ndez', 'G\u00f3mez', 'P\u00e9rez', 'Mu\u00f1oz'],\n           other_names=['Smith', 'Johnson', 'Williams', 'Brown', 'Jones'], \n           rng_seed=None):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport codecs\nimport re\nimport datetime\ndef task_func(start_year=1980, end_year=2000, email_domain='example.com',\n           latin_names=['Sopet\u00f3n', 'M\u00e9ndez', 'G\u00f3mez', 'P\u00e9rez', 'Mu\u00f1oz'],\n           other_names=['Smith', 'Johnson', 'Williams', 'Brown', 'Jones'], \n           rng_seed=None):\n    \n    # Set random seed for reproducibility\n    np.random.seed(rng_seed)\n    \n    # Generate 100 random records\n    num_records = 100\n    \n    # Generate IDs\n    ids = np.arange(1, num_records + 1)\n    \n    # Combine and correct Latin names\n    all_names = latin_names + other_names\n    all_names = [codecs.decode(name.encode('latin-1'), 'utf-8') for name in all_names]\n    \n    # Generate random names\n    names = np.random.choice(all_names, num_records)\n    \n    # Generate random dates of birth\n    start_date = datetime.date(start_year, 1, 1)\n    end_date = datetime.date(end_year, 12, 31)\n    days_between = (end_date - start_date).days\n    random_days = np.random.randint(0, days_between, num_records)\n    dates_of_birth = [start_date + datetime.timedelta(days=day) for day in random_days]\n    \n    # Generate emails\n    def create_email(name, dob):\n        name_part = re.sub(r'[^\\w]', '', name.lower())\n        year_part = f\"{dob.year:04d}\"  # Ensure the year is always four digits\n        return f\"{name_part}{year_part}@{email_domain}\"\n    \n    emails = [create_email(name, dob) for name, dob in zip(names, dates_of_birth)]\n    \n    # Create DataFrame\n    df = pd.DataFrame({\n        'ID': ids,\n        'Name': names,\n        'Date of Birth': dates_of_birth,\n        'Email': emails\n    })\n    \n    return df",
        "status": "fail",
        "details": {
          "test_custom_parameters": "Traceback (most recent call last):\n  File \"__test__.py\", line 82, in test_custom_parameters\n  File \"__test__.py\", line 33, in task_func\n  File \"__test__.py\", line 33, in <listcomp>\n  File \"/usr/local/lib/python3.10/encodings/utf_8.py\", line 16, in decode\n    return codecs.utf_8_decode(input, errors, True)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xf3 in position 5: invalid continuation byte\n",
          "test_dataframe_structure": "Traceback (most recent call last):\n  File \"__test__.py\", line 68, in test_dataframe_structure\n  File \"__test__.py\", line 33, in task_func\n  File \"__test__.py\", line 33, in <listcomp>\n  File \"/usr/local/lib/python3.10/encodings/utf_8.py\", line 16, in decode\n    return codecs.utf_8_decode(input, errors, True)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xf3 in position 5: invalid continuation byte\n",
          "test_randomness_and_encoding": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_randomness_and_encoding\n  File \"__test__.py\", line 33, in task_func\n  File \"__test__.py\", line 33, in <listcomp>\n  File \"/usr/local/lib/python3.10/encodings/utf_8.py\", line 16, in decode\n    return codecs.utf_8_decode(input, errors, True)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 1: invalid continuation byte\n",
          "test_rng": "Traceback (most recent call last):\n  File \"__test__.py\", line 95, in test_rng\n  File \"__test__.py\", line 33, in task_func\n  File \"__test__.py\", line 33, in <listcomp>\n  File \"/usr/local/lib/python3.10/encodings/utf_8.py\", line 16, in decode\n    return codecs.utf_8_decode(input, errors, True)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xf3 in position 5: invalid continuation byte\n"
        }
      }
    ],
    "BigCodeBench/752": [
      {
        "task_id": "BigCodeBench/752",
        "solution": "import pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\ndef task_func(data, target_column, test_size=0.2, random_state = 0) -> float:\n\n    pass\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nimport numpy as np\ndef task_func(data, target_column, test_size=0.2, random_state=0) -> float:\n    # Input validation\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\"Input data must be a DataFrame.\")\n    \n    if data.empty:\n        raise ValueError(\"Input data cannot be empty.\")\n    \n    if target_column not in data.columns:\n        raise ValueError(f\"Target column '{target_column}' is not in the DataFrame.\")\n    \n    if not data.select_dtypes(include=np.number).columns.equals(data.columns):\n        raise ValueError(\"All columns in the DataFrame must contain numeric values.\")\n    \n    if not isinstance(random_state, int):\n        raise ValueError(\"random_state must be an integer.\")\n    \n    if not 0 < test_size < 1:\n        raise ValueError(\"test_size must be between 0 and 1.\")\n\n    # Prepare data\n    X = data.drop(columns=[target_column])\n    y = data[target_column]\n\n    # Split data into training and test sets\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state)\n\n    # Train linear regression model\n    model = LinearRegression()\n    model.fit(X_train, y_train)\n\n    # Calculate and return model score on test set\n    return model.score(X_test, y_test)",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/763": [
      {
        "task_id": "BigCodeBench/763",
        "solution": "import numpy as np\nfrom collections import defaultdict\nimport json\nimport csv\n# Constants\ndef task_func(input_file, output_file):\n\n    pass\nimport numpy as np\nfrom collections import defaultdict\nimport json\nimport csv\ndef task_func(input_file, output_file):\n    # Read JSON file\n    with open(input_file, 'r') as f:\n        data = json.load(f)\n\n    # Initialize defaultdict to store values for each key\n    values_dict = defaultdict(list)\n\n    # Populate values_dict with data from JSON\n    for item in data:\n        for key, value in item.items():\n            if isinstance(value, (int, float)):\n                values_dict[key].append(value)\n\n    # Calculate mean and median for each key\n    result = {}\n    for key, values in values_dict.items():\n        result[key] = {\n            'mean': float(np.mean(values)),\n            'median': float(np.median(values))\n        }\n\n    # Write results to CSV file\n    with open(output_file, 'w', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerow(['Field', 'Mean', 'Median'])\n        for key, stats in result.items():\n            writer.writerow([key, stats['mean'], stats['median']])\n\n    return result",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 98, in test_case_1\n  File \"__test__.py\", line 92, in validate_data\nKeyError: 'key'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 101, in test_case_2\n  File \"__test__.py\", line 92, in validate_data\nKeyError: 'key'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 104, in test_case_3\n  File \"__test__.py\", line 92, in validate_data\nKeyError: 'key'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 107, in test_case_4\n  File \"__test__.py\", line 92, in validate_data\nKeyError: 'key'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 110, in test_case_5\n  File \"__test__.py\", line 92, in validate_data\nKeyError: 'key'\n"
        }
      }
    ],
    "BigCodeBench/765": [
      {
        "task_id": "BigCodeBench/765",
        "solution": "import os\nfrom pathlib import Path\nimport shutil\ndef task_func(kwargs, target_dir=\"non_none_files\"):\n\n    pass\nimport os\nfrom pathlib import Path\nimport shutil\ndef task_func(kwargs, target_dir=\"non_none_files\"):\n    copied_files = []\n    \n    # Create the target directory if it doesn't exist\n    target_path = Path(target_dir)\n    target_path.mkdir(parents=True, exist_ok=True)\n    \n    for file_path in kwargs.values():\n        path = Path(file_path)\n        \n        # Check if the file exists and has content\n        if path.is_file() and path.stat().st_size > 0:\n            # Generate the target file path\n            target_file = target_path / path.name\n            \n            # Copy the file to the target directory\n            shutil.copy2(path, target_file)\n            \n            # Add the full path of the copied file to the list\n            copied_files.append(str(target_file.resolve()))\n    \n    return {\n        \"copied_files\": copied_files\n    }",
        "status": "fail",
        "details": {
          "test_empty_dict": "Traceback (most recent call last):\n  File \"__test__.py\", line 89, in test_empty_dict\nAssertionError: 1 != 0\n",
          "test_files_do_not_exist": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_files_do_not_exist\nAssertionError: 1 != 0\n",
          "test_files_with_content": "Traceback (most recent call last):\n  File \"__test__.py\", line 55, in test_files_with_content\nAssertionError: 1 != 2\n",
          "test_files_with_no_content": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_files_with_no_content\n  File \"__test__.py\", line 18, in task_func\n  File \"/usr/local/lib/python3.10/pathlib.py\", line 960, in __new__\n    self = cls._from_parts(args)\n  File \"/usr/local/lib/python3.10/pathlib.py\", line 594, in _from_parts\n    drv, root, parts = self._parse_args(args)\n  File \"/usr/local/lib/python3.10/pathlib.py\", line 578, in _parse_args\n    a = os.fspath(a)\nTypeError: expected str, bytes or os.PathLike object, not NoneType\n",
          "test_mixed_case": "Traceback (most recent call last):\n  File \"__test__.py\", line 82, in test_mixed_case\n  File \"__test__.py\", line 18, in task_func\n  File \"/usr/local/lib/python3.10/pathlib.py\", line 960, in __new__\n    self = cls._from_parts(args)\n  File \"/usr/local/lib/python3.10/pathlib.py\", line 594, in _from_parts\n    drv, root, parts = self._parse_args(args)\n  File \"/usr/local/lib/python3.10/pathlib.py\", line 578, in _parse_args\n    a = os.fspath(a)\nTypeError: expected str, bytes or os.PathLike object, not NoneType\n"
        }
      }
    ],
    "BigCodeBench/187": [
      {
        "task_id": "BigCodeBench/187",
        "solution": "import numpy as np\nimport geopandas as gpd\nfrom shapely.geometry import Point\ndef task_func(dic={'Lon': (-180, 180), 'Lat': (-90, 90)}, cities=['New York', 'London', 'Beijing', 'Tokyo', 'Sydney']):\n\n    pass\nimport numpy as np\nimport geopandas as gpd\nfrom shapely.geometry import Point\ndef task_func(dic={'Lon': (-180, 180), 'Lat': (-90, 90)}, cities=['New York', 'London', 'Beijing', 'Tokyo', 'Sydney']):\n    # Validate input dictionary\n    if 'Lon' not in dic or 'Lat' not in dic:\n        raise ValueError(\"Both 'Lon' and 'Lat' keys must be present in the dictionary\")\n    if not isinstance(dic['Lon'], tuple) or not isinstance(dic['Lat'], tuple):\n        raise ValueError(\"Values for 'Lon' and 'Lat' must be tuples\")\n\n    # Generate random coordinates\n    longitudes = np.random.uniform(dic['Lon'][0], dic['Lon'][1], len(cities))\n    latitudes = np.random.uniform(dic['Lat'][0], dic['Lat'][1], len(cities))\n\n    # Create Point objects for each city\n    geometries = [Point(lon, lat) for lon, lat in zip(longitudes, latitudes)]\n\n    # Create GeoDataFrame\n    gdf = gpd.GeoDataFrame({\n        'City': cities,\n        'Coordinates': geometries\n    }, geometry='Coordinates')\n\n    return gdf",
        "status": "timeout",
        "details": {}
      }
    ],
    "BigCodeBench/777": [
      {
        "task_id": "BigCodeBench/777",
        "solution": "import re\nimport os\nimport zipfile\ndef task_func(directory, pattern=r'^(.*?)-\\d+\\.zip$'):\n\n    pass\nimport re\nimport os\nimport zipfile\ndef task_func(directory, pattern=r'^(.*?)-\\d+\\.zip$'):\n    extracted_dirs = set()\n    \n    if not os.path.isdir(directory):\n        raise ValueError(f\"The specified directory '{directory}' does not exist.\")\n\n    regex = re.compile(pattern)\n\n    for filename in os.listdir(directory):\n        if regex.match(filename):\n            zip_path = os.path.join(directory, filename)\n            prefix = filename.rsplit('-', 1)[0]\n            extract_dir = os.path.join(directory, prefix)\n            \n            os.makedirs(extract_dir, exist_ok=True)\n            \n            with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n                zip_ref.extractall(extract_dir)\n            \n            extracted_dirs.add(extract_dir)\n    \n    return sorted(list(extracted_dirs))",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 43, in test_case_1\n  File \"__test__.py\", line 14, in task_func\nValueError: The specified directory '/fake/test_zip_dir' does not exist.\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 68, in test_case_2\n  File \"__test__.py\", line 14, in task_func\nValueError: The specified directory '/fake/test_zip_dir' does not exist.\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 78, in test_case_3\n  File \"__test__.py\", line 14, in task_func\nValueError: The specified directory '/fake/test_zip_dir' does not exist.\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 87, in test_case_4\n  File \"__test__.py\", line 14, in task_func\nValueError: The specified directory '/fake/test_zip_dir' does not exist.\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 100, in test_case_5\n  File \"__test__.py\", line 14, in task_func\nValueError: The specified directory '/fake/test_zip_dir' does not exist.\n"
        }
      }
    ],
    "BigCodeBench/771": [
      {
        "task_id": "BigCodeBench/771",
        "solution": "import re\nimport os\nfrom pathlib import Path\nimport csv\ndef task_func(directory: str, pattern: str = r'^(.*?)-\\d+\\.csv$') -> list:\n\n    pass\nimport re\nimport os\nfrom pathlib import Path\nimport csv\nimport shutil\ndef task_func(directory: str, pattern: str = r'^(.*?)-\\d+\\.csv$') -> list:\n    new_files = []\n    dir_path = Path(directory)\n    \n    if not dir_path.is_dir():\n        raise ValueError(f\"The specified directory '{directory}' does not exist.\")\n\n    regex = re.compile(pattern)\n\n    for file_path in dir_path.glob('*.csv'):\n        match = regex.match(file_path.name)\n        if match:\n            base_name = match.group(1)\n            new_filename = f\"{base_name}-new.csv\"\n            new_file_path = dir_path / new_filename\n\n            # Copy the file content\n            shutil.copy2(file_path, new_file_path)\n\n            new_files.append(new_filename)\n\n    return new_files",
        "status": "fail",
        "details": {
          "test_empty_directory": "Traceback (most recent call last):\n  File \"__test__.py\", line 65, in test_empty_directory\n  File \"__test__.py\", line 18, in task_func\nValueError: The specified directory '/mnt/data/test_data' does not exist.\n",
          "test_exception_handling": "Traceback (most recent call last):\n  File \"__test__.py\", line 85, in test_exception_handling\n  File \"__test__.py\", line 18, in task_func\nValueError: The specified directory '/mnt/data/test_data' does not exist.\n",
          "test_file_creation_and_content": "Traceback (most recent call last):\n  File \"__test__.py\", line 51, in test_file_creation_and_content\n  File \"__test__.py\", line 18, in task_func\nValueError: The specified directory '/mnt/data/test_data' does not exist.\n",
          "test_mixed_file_types": "Traceback (most recent call last):\n  File \"__test__.py\", line 75, in test_mixed_file_types\n  File \"__test__.py\", line 18, in task_func\nValueError: The specified directory '/mnt/data/test_data' does not exist.\n",
          "test_non_matching_files": "Traceback (most recent call last):\n  File \"__test__.py\", line 69, in test_non_matching_files\n  File \"__test__.py\", line 18, in task_func\nValueError: The specified directory '/mnt/data/test_data' does not exist.\n"
        }
      }
    ],
    "BigCodeBench/800": [
      {
        "task_id": "BigCodeBench/800",
        "solution": "import csv\nimport os\nfrom collections import Counter\n# Constants\nCSV_FILE_PATH = 'match_data.csv'\ndef create_test_csv(filename, content):\n    with open(filename, 'w', newline='') as file:\n        writer = csv.writer(file)\n        writer.writerows(content)\n# Example usage in a test setup:\ndef setup_csv():\n    content = [\n        ['team', 'goals', 'penalties'],\n        ['Team A', '2', '1'],\n        ['Team B', '1', '2'],\n        ['Team C', '3', '0']\n    ]\n    create_test_csv('test_data/test_case_2.csv', content)\ndef task_func(goals, penalties, csv_file_path=CSV_FILE_PATH):\n\n    pass\nimport csv\nimport os\nfrom collections import Counter\nCSV_FILE_PATH = 'match_data.csv'\ndef task_func(goals, penalties, csv_file_path=CSV_FILE_PATH):\n    count = Counter()\n\n    if os.path.exists(csv_file_path):\n        with open(csv_file_path, 'r', newline='') as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                count['goals'] += int(row['goals'])\n                count['penalties'] += int(row['penalties'])\n    \n    count['goals'] += goals\n    count['penalties'] += penalties\n\n    with open(csv_file_path, 'w', newline='') as file:\n        writer = csv.DictWriter(file, fieldnames=['team', 'goals', 'penalties'])\n        writer.writeheader()\n        writer.writerow({\n            'team': 'Total',\n            'goals': count['goals'],\n            'penalties': count['penalties']\n        })\n\n    return count",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 63, in test_case_1\n  File \"__test__.py\", line 36, in task_func\nTypeError: unsupported operand type(s) for +=: 'int' and 'dict'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 73, in test_case_2\n  File \"__test__.py\", line 36, in task_func\nTypeError: unsupported operand type(s) for +=: 'int' and 'dict'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 83, in test_case_3\n  File \"__test__.py\", line 36, in task_func\nTypeError: unsupported operand type(s) for +=: 'int' and 'dict'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 94, in test_case_4\n  File \"__test__.py\", line 36, in task_func\nTypeError: unsupported operand type(s) for +=: 'int' and 'dict'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 104, in test_case_5\n  File \"__test__.py\", line 36, in task_func\nTypeError: unsupported operand type(s) for +=: 'int' and 'dict'\n"
        }
      }
    ],
    "BigCodeBench/826": [
      {
        "task_id": "BigCodeBench/826",
        "solution": "import re\nimport os\nimport shutil\ndef task_func(source_dir, target_dir, file_pattern=r'\\b[A-Za-z0-9]+\\.(txt|doc|docx)\\b'):\n\n    pass\nimport re\nimport os\nimport shutil\ndef task_func(source_dir, target_dir, file_pattern=r'\\b[A-Za-z0-9]+\\.(txt|doc|docx)\\b'):\n    # Ensure the target directory exists\n    os.makedirs(target_dir, exist_ok=True)\n\n    # Compile the regular expression pattern\n    pattern = re.compile(file_pattern)\n\n    moved_files_count = 0\n\n    # Iterate through all files in the source directory\n    for filename in os.listdir(source_dir):\n        source_path = os.path.join(source_dir, filename)\n        \n        # Check if it's a file and matches the pattern\n        if os.path.isfile(source_path) and pattern.match(filename):\n            target_path = os.path.join(target_dir, filename)\n            \n            try:\n                shutil.move(source_path, target_path)\n                moved_files_count += 1\n            except (IOError, OSError) as e:\n                print(f\"Error moving {filename}: {e}\")\n\n    return moved_files_count",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/785": [
      {
        "task_id": "BigCodeBench/785",
        "solution": "import subprocess\nimport os\nimport glob\n# Constants\nARCHIVE_DIR = '/tmp/archive'\ndef task_func(pattern):\n\n    pass\nimport subprocess\nimport os\nimport glob\nfrom datetime import datetime\nARCHIVE_DIR = '/tmp/archive'\ndef task_func(pattern):\n    \"\"\"\n    Archive files matching the given pattern and delete the originals.\n\n    Args:\n        pattern (str): The file pattern to match.\n\n    Returns:\n        str: The archive file path, or None if archiving failed.\n    \"\"\"\n    # Ensure the archive directory exists\n    os.makedirs(ARCHIVE_DIR, exist_ok=True)\n\n    # Find all files matching the pattern\n    files = glob.glob(pattern)\n\n    if not files:\n        print(f\"No files found matching the pattern: {pattern}\")\n        return None\n\n    # Create a unique archive file name\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    archive_name = f\"archive_{timestamp}.tar.gz\"\n    archive_path = os.path.join(ARCHIVE_DIR, archive_name)\n\n    try:\n        # Create the archive\n        subprocess.run(['tar', '-czf', archive_path] + files, check=True)\n        print(f\"Files archived successfully to: {archive_path}\")\n\n        # Delete original files\n        for file in files:\n            os.remove(file)\n            print(f\"Deleted original file: {file}\")\n\n        return archive_path\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Error creating archive: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n    return None",
        "status": "fail",
        "details": {
          "test_no_matching_files": "Traceback (most recent call last):\n  File \"__test__.py\", line 96, in test_no_matching_files\nAssertionError: None != 'No files found matching the pattern.'\n",
          "test_archiving_in_nonexistent_directory": "Traceback (most recent call last):\n  File \"__test__.py\", line 108, in test_archiving_in_nonexistent_directory\n  File \"/usr/local/lib/python3.10/genericpath.py\", line 30, in isfile\n    st = os.stat(path)\nTypeError: stat: path should be string, bytes, os.PathLike or integer, not NoneType\n"
        }
      }
    ],
    "BigCodeBench/845": [
      {
        "task_id": "BigCodeBench/845",
        "solution": "import re\nimport numpy as np\nfrom collections import Counter\nfrom Levenshtein import ratio\n# Constants\nALPHANUMERIC = re.compile('[\\W_]+')\ndef task_func(text1, text2):\n\n    pass\nimport re\nimport numpy as np\nfrom collections import Counter\nfrom Levenshtein import ratio\nALPHANUMERIC = re.compile('[\\W_]+')\ndef task_func(text1, text2):\n    # Clean the texts\n    clean_text1 = ALPHANUMERIC.sub(' ', text1.lower())\n    clean_text2 = ALPHANUMERIC.sub(' ', text2.lower())\n    \n    # Calculate Levenshtein ratio\n    levenshtein_ratio = ratio(clean_text1, clean_text2)\n    \n    # Tokenize the texts\n    tokens1 = clean_text1.split()\n    tokens2 = clean_text2.split()\n    \n    # Create term frequency dictionaries\n    tf1 = Counter(tokens1)\n    tf2 = Counter(tokens2)\n    \n    # Get unique words from both texts\n    all_words = set(tf1.keys()).union(set(tf2.keys()))\n    \n    # Create term frequency vectors\n    vec1 = np.array([tf1.get(word, 0) for word in all_words])\n    vec2 = np.array([tf2.get(word, 0) for word in all_words])\n    \n    # Calculate cosine similarity\n    dot_product = np.dot(vec1, vec2)\n    norm1 = np.linalg.norm(vec1)\n    norm2 = np.linalg.norm(vec2)\n    \n    cosine_similarity = 0.0 if norm1 == 0 or norm2 == 0 else dot_product / (norm1 * norm2)\n    \n    return (cosine_similarity, levenshtein_ratio)",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/854": [
      {
        "task_id": "BigCodeBench/854",
        "solution": "from functools import reduce\nfrom itertools import permutations\nimport math\ndef task_func(numbers):\n\n    pass\nfrom functools import reduce\nfrom itertools import permutations\nimport math\ndef task_func(numbers):\n    # Validate input\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list of integers\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"All elements must be integers\")\n    if any(num < 0 for num in numbers):\n        raise ValueError(\"Input numbers must not be negative\")\n\n    # Handle empty list case\n    if not numbers:\n        return [], []\n\n    # Generate all permutations\n    perms = list(permutations(numbers))\n\n    # Calculate factorial sums\n    factorial_sums = [sum(math.factorial(num) for num in perm) for perm in perms]\n\n    # Convert permutations to list of lists\n    perm_lists = [list(perm) for perm in perms]\n\n    return factorial_sums, perm_lists",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 40, in test_case_1\nAssertionError: Element counts were not equal:\nFirst has 1, Second has 0:  [1, 2]\nFirst has 1, Second has 0:  [2, 1]\nFirst has 0, Second has 1:  (2, 1)\nFirst has 0, Second has 1:  (1, 2)\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 46, in test_case_2\nAssertionError: Element counts were not equal:\nFirst has 1, Second has 0:  [1, 2, 3]\nFirst has 1, Second has 0:  [1, 3, 2]\nFirst has 1, Second has 0:  [2, 1, 3]\nFirst has 1, Second has 0:  [2, 3, 1]\nFirst has 1, Second has 0:  [3, 1, 2]\nFirst has 1, Second has 0:  [3, 2, 1]\nFirst has 0, Second has 1:  (1, 2, 3)\nFirst has 0, Second has 1:  (1, 3, 2)\nFirst has 0, Second has 1:  (2, 1, 3)\nFirst has 0, Second has 1:  (2, 3, 1)\nFirst has 0, Second has 1:  (3, 1, 2)\nFirst has 0, Second has 1:  (3, 2, 1)\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 52, in test_case_3\nAssertionError: Element counts were not equal:\nFirst has 1, Second has 0:  [1]\nFirst has 0, Second has 1:  (1,)\n"
        }
      }
    ],
    "BigCodeBench/857": [
      {
        "task_id": "BigCodeBench/857",
        "solution": "import warnings\nimport os\nimport glob\nimport shutil\nimport time\ndef task_func(SOURCE_DIR, DEST_DIR, EXTENSIONS):\n\n    pass\nimport warnings\nimport os\nimport glob\nimport shutil\nimport time\ndef task_func(SOURCE_DIR, DEST_DIR, EXTENSIONS):\n    transferred_files = []\n    \n    # Ensure the destination directory exists\n    os.makedirs(DEST_DIR, exist_ok=True)\n    \n    # Create a list of file patterns based on the provided extensions\n    file_patterns = [os.path.join(SOURCE_DIR, f\"*.{ext}\") for ext in EXTENSIONS]\n    \n    # Iterate through all matching files\n    for pattern in file_patterns:\n        for file_path in glob.glob(pattern):\n            file_name = os.path.basename(file_path)\n            dest_path = os.path.join(DEST_DIR, file_name)\n            \n            try:\n                # Check if the file already exists in the destination\n                if os.path.exists(dest_path):\n                    # If it exists, add a timestamp to the filename\n                    base_name, ext = os.path.splitext(file_name)\n                    timestamp = time.strftime(\"%Y%m%d_%H%M%S\")\n                    new_file_name = f\"{base_name}_{timestamp}{ext}\"\n                    dest_path = os.path.join(DEST_DIR, new_file_name)\n                \n                # Copy the file to the destination\n                shutil.copy2(file_path, dest_path)\n                transferred_files.append(file_name)\n                \n            except Exception as e:\n                warnings.warn(f\"Could not transfer file {file_name}: {str(e)}\")\n    \n    return transferred_files",
        "status": "fail",
        "details": {
          "test_all_extensions": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 101, in test_all_extensions\nAssertionError: Lists differ: ['fil[42 chars].jpg', 'file1.txt', 'file2.csv', 'file3.xlsx',[114 chars]jpg'] != ['fil[42 chars].jpg']\n\nFirst list contains 12 additional elements.\nFirst extra element 4:\n'file1.txt'\n\n+ ['file1.txt', 'file2.csv', 'file3.xlsx', 'file4.jpg']\n- ['file1.txt',\n-  'file2.csv',\n-  'file3.xlsx',\n-  'file4.jpg',\n-  'file1.txt',\n-  'file2.csv',\n-  'file3.xlsx',\n-  'file4.jpg',\n-  'file1.txt',\n-  'file2.csv',\n-  'file3.xlsx',\n-  'file4.jpg',\n-  'file1.txt',\n-  'file2.csv',\n-  'file3.xlsx',\n-  'file4.jpg']\n",
          "test_exception_handling": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 94, in test_exception_handling\nAssertionError: Lists differ: ['invalid file name.jpg'] != []\n\nFirst list contains 1 additional elements.\nFirst extra element 0:\n'invalid file name.jpg'\n\n- ['invalid file name.jpg']\n+ []\n",
          "test_successful_transfer": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 73, in test_successful_transfer\nAssertionError: Lists differ: ['file1.txt', 'file2.csv', 'file1.txt', 'file2.csv'] != ['file1.txt', 'file2.csv']\n\nFirst list contains 2 additional elements.\nFirst extra element 2:\n'file1.txt'\n\n- ['file1.txt', 'file2.csv', 'file1.txt', 'file2.csv']\n+ ['file1.txt', 'file2.csv']\n"
        }
      }
    ],
    "BigCodeBench/870": [
      {
        "task_id": "BigCodeBench/870",
        "solution": "import pandas as pd\nimport numpy as np\nimport itertools\ndef task_func(data_list=[('a', 1, 2.1), ('b', 2, 3.2), ('c', 3, 4.3), ('d', 4, 5.4), ('e', 5, 6.5)]):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport itertools\ndef task_func(data_list=[('a', 1, 2.1), ('b', 2, 3.2), ('c', 3, 4.3), ('d', 4, 5.4), ('e', 5, 6.5)]):\n    if not data_list:\n        return pd.DataFrame(columns=['Mean Value'])\n\n    # Find the maximum length of tuples in the list\n    max_length = max(len(t) for t in data_list)\n\n    # Initialize lists to store numerical values for each position\n    position_values = [[] for _ in range(max_length)]\n\n    # Iterate through each tuple in the list\n    for tuple_item in data_list:\n        for i, value in enumerate(tuple_item):\n            # Check if the value is numeric (int or float)\n            if isinstance(value, (int, float)):\n                position_values[i].append(value)\n\n    # Calculate mean for each position, ignoring non-numeric values\n    means = [np.mean(values) if values else np.nan for values in position_values]\n\n    # Create a DataFrame with the results\n    df = pd.DataFrame({'Mean Value': means}, index=[f'Position {i}' for i in range(max_length)])\n\n    return df",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/865": [
      {
        "task_id": "BigCodeBench/865",
        "solution": "import pandas as pd\nimport numpy as np\nfrom scipy.stats import zscore\nfrom sklearn.preprocessing import MinMaxScaler\ndef task_func(data):\n\n    pass\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import zscore\nfrom sklearn.preprocessing import MinMaxScaler\ndef task_func(data):\n    # Unpack the input data\n    items, counts, weights = zip(*data)\n    \n    # Normalize counts using z-score\n    normalized_counts = zscore(counts)\n    \n    # Normalize weights using min-max scaling\n    scaler = MinMaxScaler()\n    normalized_weights = scaler.fit_transform(np.array(weights).reshape(-1, 1)).flatten()\n    \n    # Create and return the DataFrame\n    return pd.DataFrame({\n        'Item': items,\n        'Normalized Count': normalized_counts,\n        'Normalized Weight': normalized_weights\n    })",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/879": [
      {
        "task_id": "BigCodeBench/879",
        "solution": "import pandas as pd\nimport numpy as np\nfrom scipy.stats import chi2_contingency\ndef task_func(data, col1, col2):\n\n    pass\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import chi2_contingency\ndef task_func(data, col1, col2):\n    # Check if data is empty\n    if data.empty:\n        raise ValueError(\"The input DataFrame is empty.\")\n\n    # Check if columns exist in the DataFrame\n    if col1 not in data.columns or col2 not in data.columns:\n        raise ValueError(f\"One or both columns '{col1}' and '{col2}' are not in the DataFrame.\")\n\n    # Check if columns contain categorical data\n    if not pd.api.types.is_categorical_dtype(data[col1]) and not pd.api.types.is_object_dtype(data[col1]):\n        raise TypeError(f\"Column '{col1}' does not contain categorical data.\")\n    if not pd.api.types.is_categorical_dtype(data[col2]) and not pd.api.types.is_object_dtype(data[col2]):\n        raise TypeError(f\"Column '{col2}' does not contain categorical data.\")\n\n    # Create contingency table\n    contingency_table = pd.crosstab(data[col1], data[col2])\n\n    # Check if columns have multiple categories\n    if contingency_table.shape[0] < 2 or contingency_table.shape[1] < 2:\n        raise ValueError(\"One or both columns do not have multiple categories.\")\n\n    # Check if all categories have at least 5 observations\n    if (contingency_table < 5).any().any():\n        raise ValueError(\"Some categories have less than 5 observations, violating chi-square test assumptions.\")\n\n    # Perform chi-square test\n    _, p_value, _, _ = chi2_contingency(contingency_table)\n\n    return p_value",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/897": [
      {
        "task_id": "BigCodeBench/897",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nimport random\n# Constants\nNUMBERS = list(range(1, 7))  # Adjusting for dice rolls (1 to 6)\ndef task_func(rolls, seed=None):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport random\nNUMBERS = list(range(1, 7))\ndef task_func(rolls, seed=None):\n    if seed is not None:\n        random.seed(seed)\n        np.random.seed(seed)\n\n    # Simulate dice rolls\n    dice_rolls = np.random.choice(NUMBERS, size=rolls)\n\n    # Calculate frequencies\n    frequencies = np.bincount(dice_rolls, minlength=7)[1:]\n\n    # Create histogram\n    fig, ax = plt.subplots(figsize=(10, 6))\n    bars = ax.bar(NUMBERS, frequencies, color='skyblue', edgecolor='navy')\n    ax.set_xlabel('Dice Value')\n    ax.set_ylabel('Frequency')\n    ax.set_title('Histogram of Dice Rolls')\n    ax.set_xticks(NUMBERS)\n    ax.set_xlim(0.5, 6.5)\n    ax.grid(axis='y', linestyle='--', alpha=0.7)\n\n    # Add value labels on top of each bar\n    for bar in bars:\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height,\n                f'{height}', ha='center', va='bottom')\n\n    plt.tight_layout()\n\n    return frequencies, ax",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 63, in test_case_3\nAssertionError: Lists differ: [16586, 16721, 16530, 16792, 16820, 16551] != [16607, 16689, 16800, 16625, 16640, 16639]\n\nFirst differing element 0:\n16586\n16607\n\n- [16586, 16721, 16530, 16792, 16820, 16551]\n+ [16607, 16689, 16800, 16625, 16640, 16639]\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 70, in test_case_4\nAssertionError: Lists differ: [0, 0, 1, 0, 0, 0] != [0, 1, 0, 0, 0, 0]\n\nFirst differing element 1:\n0\n1\n\n- [0, 0, 1, 0, 0, 0]\n?        ---\n\n+ [0, 1, 0, 0, 0, 0]\n?     +++\n\n"
        }
      }
    ],
    "BigCodeBench/906": [
      {
        "task_id": "BigCodeBench/906",
        "solution": "import zipfile\nimport os\nimport re\nimport shutil\ndef task_func(source_dir: str, target_dir: str, archive_name: str = 'archive.zip') -> str:\n\n    pass\nimport zipfile\nimport os\nimport re\nimport shutil\ndef task_func(source_dir: str, target_dir: str, archive_name: str = 'archive.zip') -> str:\n    # Ensure the target directory exists\n    os.makedirs(target_dir, exist_ok=True)\n\n    # Full path for the archive\n    archive_path = os.path.join(target_dir, archive_name)\n\n    # Create a ZipFile object\n    with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        # Walk through the source directory\n        for root, _, files in os.walk(source_dir):\n            for file in files:\n                # Check if the file has '_processed' suffix\n                if re.search(r'_processed\\.[^.]+$', file):\n                    file_path = os.path.join(root, file)\n                    # Add file to the zip archive\n                    zipf.write(file_path, os.path.relpath(file_path, source_dir))\n\n    return archive_path",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/914": [
      {
        "task_id": "BigCodeBench/914",
        "solution": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\ndef task_func(df):\n\n    pass\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\ndef task_func(df):\n    # Convert 'Date' column to datetime\n    df['Date'] = pd.to_datetime(df['Date'])\n    \n    # Create a numeric representation of dates\n    df['Days'] = (df['Date'] - df['Date'].min()).dt.total_seconds() / (24*60*60)\n    \n    # Prepare data for linear regression\n    X = df['Days'].values.reshape(-1, 1)\n    y = df['Close'].values\n\n    # Fit linear regression model\n    model = LinearRegression()\n    model.fit(X, y)\n\n    # Generate future dates\n    last_date = df['Date'].max()\n    future_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=7, freq='D')\n    future_days = ((future_dates - df['Date'].min()).total_seconds() / (24*60*60)).values.reshape(-1, 1)\n\n    # Predict future prices\n    future_prices = model.predict(future_days)\n\n    # Plot the data\n    fig, ax = plt.subplots(figsize=(12, 6))\n    ax.scatter(df['Date'], df['Close'], color='blue', label='Historical Data')\n    ax.plot(df['Date'], model.predict(X), color='red', label='Regression Line')\n    ax.scatter(future_dates, future_prices, color='green', label='Predicted Prices')\n\n    # Customize the plot\n    ax.set_xlabel('Date')\n    ax.set_ylabel('Closing Price')\n    ax.set_title('Stock Price Prediction')\n    ax.legend()\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n\n    return list(future_prices), ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Date'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 58, in test_case_1\n  File \"__test__.py\", line 14, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Date'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Date'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 66, in test_case_2\n  File \"__test__.py\", line 14, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Date'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Date'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 74, in test_case_3\n  File \"__test__.py\", line 14, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Date'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Date'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 82, in test_case_4\n  File \"__test__.py\", line 14, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Date'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Date'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 90, in test_case_5\n  File \"__test__.py\", line 14, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Date'\n"
        }
      }
    ],
    "BigCodeBench/916": [
      {
        "task_id": "BigCodeBench/916",
        "solution": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ndef task_func(df: pd.DataFrame) -> tuple:\n\n    pass\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ndef task_func(df: pd.DataFrame) -> tuple:\n    # Create a figure with two subplots\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12), gridspec_kw={'height_ratios': [1, 2]})\n\n    # Box plot\n    sns.boxplot(x=df['Close'], ax=ax1)\n    ax1.set_title('Box Plot of Closing Prices')\n    ax1.set_xlabel('Closing Price')\n\n    # Histogram\n    sns.histplot(data=df, x='Close', kde=True, ax=ax2)\n    ax2.set_title('Histogram of Closing Prices')\n    ax2.set_xlabel('Closing Price')\n    ax2.set_ylabel('Frequency')\n\n    # Adjust layout\n    plt.tight_layout()\n\n    return (ax1, ax2)",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 40, in test_case_1\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_empty_df": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 53, in test_empty_df\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_large_values_df": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 74, in test_large_values_df\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_single_value_df": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 66, in test_single_value_df\n  File \"__test__.py\", line 15, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n"
        }
      }
    ],
    "BigCodeBench/915": [
      {
        "task_id": "BigCodeBench/915",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import zscore\ndef task_func(df, z_threshold=2):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import zscore\ndef task_func(df, z_threshold=2):\n    # Calculate Z-scores for the 'closing_price' column\n    z_scores = zscore(df['closing_price'])\n    \n    # Identify outliers based on the Z-score threshold\n    outliers = df[np.abs(z_scores) > z_threshold].copy()\n    \n    # Create a plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    # Plot all data points\n    ax.scatter(df.index, df['closing_price'], color='blue', label='Normal')\n    \n    # Plot outliers in red\n    ax.scatter(outliers.index, outliers['closing_price'], color='red', label='Outliers')\n    \n    # Customize the plot\n    ax.set_xlabel('Index')\n    ax.set_ylabel('Closing Price')\n    ax.set_title('Outliers in Closing Prices')\n    ax.legend()\n    \n    # Add annotations for outliers\n    for idx, row in outliers.iterrows():\n        ax.annotate(f'{row[\"closing_price\"]:.2f}', \n                    (idx, row['closing_price']),\n                    xytext=(5, 5), \n                    textcoords='offset points')\n    \n    # Adjust layout to prevent clipping of annotations\n    plt.tight_layout()\n    \n    return outliers, ax",
        "status": "fail",
        "details": {
          "test_case_2": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Z_score'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 63, in test_case_2\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Z_score'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Z_score'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 71, in test_case_3\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Z_score'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Z_score'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 78, in test_case_4\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Z_score'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Z_score'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 86, in test_case_5\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Z_score'\n"
        }
      }
    ],
    "BigCodeBench/917": [
      {
        "task_id": "BigCodeBench/917",
        "solution": "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.axes import Axes\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom typing import List, Tuple\ndef task_func(df: pd.DataFrame) -> Tuple[List[float], Axes]:\n\n    pass\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.axes import Axes\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom typing import List, Tuple\ndef task_func(df: pd.DataFrame) -> Tuple[List[float], Axes]:\n    # Ensure the DataFrame is sorted by date\n    df = df.sort_index()\n\n    # Fit ARIMA model\n    model = ARIMA(df['Close'], order=(1, 1, 1))\n    results = model.fit()\n\n    # Forecast next 7 days\n    forecast = results.forecast(steps=7)\n    forecast_values = forecast.tolist()\n\n    # Create plot\n    fig, ax = plt.subplots(figsize=(12, 6))\n\n    # Plot historical data\n    ax.plot(df.index, df['Close'], label='Historical')\n\n    # Plot forecast\n    last_date = df.index[-1]\n    forecast_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=7)\n    ax.plot(forecast_dates, forecast_values, color='red', label='Forecast')\n\n    # Fill the area between the historical data and the forecast\n    ax.fill_between(forecast_dates, forecast_values, df['Close'].iloc[-1],\n                    color='red', alpha=0.3)\n\n    # Customize the plot\n    ax.set_title('Stock Price Forecast')\n    ax.set_xlabel('Date')\n    ax.set_ylabel('Price')\n    ax.legend()\n\n    # Rotate and align the tick labels so they look better\n    fig.autofmt_xdate()\n\n    # Use tight layout to prevent clipping of tick-labels\n    plt.tight_layout()\n\n    return forecast_values, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 68, in test_case_1\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_case_2": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 89, in test_case_2\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_case_3": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 109, in test_case_3\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 130, in test_case_4\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3653, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 147, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 176, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7080, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 7088, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'Close'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"__test__.py\", line 150, in test_case_5\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/frame.py\", line 3761, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/usr/local/lib/python3.10/site-packages/pandas/core/indexes/base.py\", line 3655, in get_loc\n    raise KeyError(key) from err\nKeyError: 'Close'\n"
        }
      }
    ],
    "BigCodeBench/928": [
      {
        "task_id": "BigCodeBench/928",
        "solution": "from collections import Counter\nimport itertools\nimport string\ndef task_func(word: str) -> dict:\n\n    pass\nfrom collections import Counter\nimport itertools\nimport string\ndef task_func(word: str) -> dict:\n    # Generate all possible two-letter combinations\n    all_combinations = [''.join(combo) for combo in itertools.product(string.ascii_lowercase, repeat=2)]\n    \n    # Initialize the dictionary with all combinations set to 0\n    result = {combo: 0 for combo in all_combinations}\n    \n    # Convert word to lowercase and count two-letter combinations\n    word = word.lower()\n    word_combinations = [word[i:i+2] for i in range(len(word) - 1)]\n    combination_counts = Counter(word_combinations)\n    \n    # Update the result dictionary with the counts\n    result.update(combination_counts)\n    \n    return result",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/952": [
      {
        "task_id": "BigCodeBench/952",
        "solution": "import pandas as pd\nimport random\nfrom datetime import datetime\ndef task_func(\n    task_list,\n    n_tasks,\n    employees=[\"John Doe\", \"Jane Smith\", \"James Brown\", \"Mary Johnson\", \"Robert Davis\"],\n    seed=None,\n):\n\n    pass\nimport pandas as pd\nimport random\nfrom datetime import datetime\ndef task_func(\n    task_list,\n    n_tasks,\n    employees=[\"John Doe\", \"Jane Smith\", \"James Brown\", \"Mary Johnson\", \"Robert Davis\"],\n    seed=None,\n):\n    if n_tasks < 0:\n        raise ValueError(\"n_tasks must be non-negative\")\n\n    if seed is not None:\n        random.seed(seed)\n\n    sanitized_tasks = [task.replace(\" \", \"_\") for task in task_list]\n    current_date = datetime.now().date()\n\n    assignments = [\n        {\n            'Task Name': random.choice(sanitized_tasks),\n            'Assigned To': random.choice(employees),\n            'Due Date': current_date\n        }\n        for _ in range(n_tasks)\n    ]\n\n    return pd.DataFrame(assignments)",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 55, in test_case_1\nAssertionError: False is not true\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 80, in test_case_5\nAssertionError: Items in the second set but not the first:\n'Task Name'\n'Assigned To'\n'Due Date'\n",
          "test_case_6": "Traceback (most recent call last):\n  File \"__test__.py\", line 84, in test_case_6\n  File \"__test__.py\", line 30, in task_func\n  File \"__test__.py\", line 32, in <listcomp>\n  File \"/usr/local/lib/python3.10/random.py\", line 378, in choice\n    return seq[self._randbelow(len(seq))]\nIndexError: list index out of range\n"
        }
      }
    ],
    "BigCodeBench/945": [
      {
        "task_id": "BigCodeBench/945",
        "solution": "import pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\ndef task_func(start_date='2016-01-01', periods=13, freq='WOM-2FRI', sales_data=None):\n\n    pass\nimport pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\ndef task_func(start_date='2016-01-01', periods=13, freq='WOM-2FRI', sales_data=None):\n    # Generate date range\n    date_range = pd.date_range(start=start_date, periods=periods, freq=freq)\n    \n    # Generate or use provided sales data\n    if sales_data is None:\n        np.random.seed(42)  # for reproducibility\n        sales_data = np.random.randint(1000, 5000, size=periods)\n    else:\n        sales_data = np.array(sales_data)\n    \n    # Create features (X) as the numeric representation of dates\n    X = np.arange(periods).reshape(-1, 1)\n    y = sales_data\n    \n    # Fit linear regression model\n    model = LinearRegression()\n    model.fit(X, y)\n    \n    # Generate future dates for forecasting\n    X_future = np.arange(periods, 2*periods).reshape(-1, 1)\n    \n    # Forecast future sales\n    future_sales = model.predict(X_future)\n    \n    return future_sales",
        "status": "fail",
        "details": {
          "test_forecasted_values_increasing": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_forecasted_values_increasing\nAssertionError: True is not false\n"
        }
      }
    ],
    "BigCodeBench/942": [
      {
        "task_id": "BigCodeBench/942",
        "solution": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n# Constants\nSTART_DATE = '2016-01-01'\nPERIODS = 13\nFREQ = 'WOM-2FRI'\nCATEGORIES = ['Electronics', 'Fashion', 'Home & Kitchen', 'Automotive', 'Sports']\ndef task_func(start_date=START_DATE, periods=PERIODS, freq=FREQ, categories=CATEGORIES):\n\n    pass\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nSTART_DATE = '2016-01-01'\nPERIODS = 13\nFREQ = 'WOM-2FRI'\nCATEGORIES = ['Electronics', 'Fashion', 'Home & Kitchen', 'Automotive', 'Sports']\ndef task_func(start_date=START_DATE, periods=PERIODS, freq=FREQ, categories=CATEGORIES):\n    # Generate date range\n    dates = pd.date_range(start=start_date, periods=periods, freq=freq)\n    \n    # Create empty list to store data\n    data = []\n    \n    # Generate sales data for each category\n    for category in categories:\n        base_sales = np.random.randint(1000, 5000)\n        trend = np.random.uniform(-0.1, 0.1)\n        noise = np.random.normal(0, 0.05, periods)\n        sales = base_sales * (1 + trend * np.arange(periods) + noise)\n        sales = np.maximum(sales, 0)  # Ensure non-negative sales\n        \n        for date, sale in zip(dates, sales):\n            data.append({'Date': date, 'Category': category, 'Sales': round(sale, 2)})\n    \n    # Create DataFrame\n    df = pd.DataFrame(data)\n    \n    # Plotting\n    fig, ax = plt.subplots(figsize=(12, 6))\n    \n    for category in categories:\n        category_data = df[df['Category'] == category]\n        ax.plot(category_data['Date'], category_data['Sales'], label=category, marker='o')\n    \n    ax.set_xlabel('Date')\n    ax.set_ylabel('Sales')\n    ax.set_title('Sales Report by Category')\n    ax.legend()\n    ax.grid(True, linestyle='--', alpha=0.7)\n    \n    # Rotate x-axis labels for better readability\n    plt.xticks(rotation=45, ha='right')\n    \n    # Adjust layout to prevent cutting off labels\n    plt.tight_layout()\n    \n    return df, ax",
        "status": "fail",
        "details": {
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 70, in test_case_1\nAssertionError: 'Sales Report by Category' != 'Category-wise Sales Trends'\n- Sales Report by Category\n+ Category-wise Sales Trends\n\n"
        }
      }
    ],
    "BigCodeBench/963": [
      {
        "task_id": "BigCodeBench/963",
        "solution": "import os\nimport glob\nfrom pathlib import Path\nimport zipfile\ndef task_func(source_directory, target_directory, zip_name):\n\n    pass\nimport os\nimport glob\nfrom pathlib import Path\nimport zipfile\ndef task_func(source_directory, target_directory, zip_name):\n    # Check if source directory exists\n    if not os.path.exists(source_directory):\n        raise OSError(f\"Source directory '{source_directory}' does not exist.\")\n\n    # Create target directory if it doesn't exist\n    Path(target_directory).mkdir(parents=True, exist_ok=True)\n\n    # Define valid extensions\n    valid_extensions = ['.txt', '.docx', '.xlsx', '.csv']\n\n    # Create the full path for the zip file\n    zip_path = os.path.join(target_directory, f\"{zip_name}.zip\")\n\n    # Create a ZipFile object\n    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        # Iterate through all files in the source directory\n        for ext in valid_extensions:\n            for file in glob.glob(os.path.join(source_directory, f\"*{ext}\")):\n                # Add file to the zip, preserving the relative path\n                zipf.write(file, os.path.relpath(file, source_directory))\n\n    # Return the full path to the created zip file\n    return zip_path",
        "status": "fail",
        "details": {
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 120, in test_case_5\nAssertionError: 0 != 2\n",
          "test_case_7": "Traceback (most recent call last):\n  File \"__test__.py\", line 136, in test_case_7\nAssertionError: 0 != 4\n"
        }
      }
    ],
    "BigCodeBench/955": [
      {
        "task_id": "BigCodeBench/955",
        "solution": "import numpy as np\nimport matplotlib.pyplot as plt\nimport re\nfrom collections import Counter\ndef task_func(mystrings, text):\n\n    pass\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport re\nfrom collections import Counter\ndef task_func(mystrings, text):\n    # Check if the input text is empty\n    if not text.strip():\n        raise ValueError(\"Input text is empty\")\n\n    # Convert text to lowercase\n    text = text.lower()\n\n    # Create a dictionary to map words to their underscore versions\n    word_map = {word.lower(): word.lower().replace(' ', '_') for word in mystrings}\n\n    # Replace words in the text\n    for word, underscore_word in word_map.items():\n        text = re.sub(r'\\b' + re.escape(word) + r'\\b', underscore_word, text)\n\n    # Split the text into words\n    words = text.split()\n\n    # Count word frequencies\n    word_counts = Counter(words)\n\n    # Get unique words in the order they appear\n    unique_words = []\n    for word in words:\n        if word not in unique_words:\n            unique_words.append(word)\n\n    # Get frequencies for the unique words\n    frequencies = [word_counts[word] for word in unique_words]\n\n    # Create the plot\n    fig, ax = plt.subplots(figsize=(12, 6))\n    ax.bar(range(len(unique_words)), frequencies)\n\n    # Set x-axis ticks and labels\n    ax.set_xticks(range(len(unique_words)))\n    ax.set_xticklabels(unique_words, rotation=45, ha='right')\n\n    # Set labels and title\n    ax.set_xlabel('Words')\n    ax.set_ylabel('Frequency')\n    ax.set_title('Word Frequency')\n\n    # Adjust layout to prevent cutting off labels\n    plt.tight_layout()\n\n    return ax",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 81, in test_case_3\nAssertionError: False is not true\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 90, in test_case_4\nAssertionError: False is not true\n",
          "test_case_6": "Traceback (most recent call last):\n  File \"__test__.py\", line 102, in test_case_6\nAssertionError: 'Hello_World!' not found in ['hello_world!']\n"
        }
      }
    ],
    "BigCodeBench/417": [
      {
        "task_id": "BigCodeBench/417",
        "solution": "from sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import SGD\ndef task_func(X, Y):\n\n    pass\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import SGD\ndef task_func(X, Y, learning_rate=0.01, epochs=100, batch_size=32):\n    # Ensure input dimension is 2\n    if X.shape[1] != 2:\n        raise ValueError(\"Input dimension must be 2.\")\n\n    # Split data into training (75%) and test (25%) sets\n    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.25, random_state=42)\n\n    # Construct Sequential model\n    model = Sequential([\n        Dense(4, activation='sigmoid', input_shape=(2,)),\n        Dense(1, activation='sigmoid')\n    ])\n\n    # Compile model\n    model.compile(optimizer=SGD(learning_rate=learning_rate),\n                  loss='binary_crossentropy',\n                  metrics=['accuracy'])\n\n    # Fit model to training data\n    history = model.fit(X_train, Y_train,\n                        epochs=epochs,\n                        batch_size=batch_size,\n                        validation_data=(X_test, Y_test),\n                        verbose=0)\n\n    # Plot training and validation loss\n    fig, ax = plt.subplots()\n    ax.plot(history.history['loss'], label='Train')\n    ax.plot(history.history['val_loss'], label='Test')\n    ax.set_title('Model loss')\n    ax.set_xlabel('Epoch')\n    ax.set_ylabel('Loss')\n    ax.legend()\n\n    return model, ax",
        "status": "timeout",
        "details": {}
      }
    ],
    "BigCodeBench/964": [
      {
        "task_id": "BigCodeBench/964",
        "solution": "import os\nfrom pathlib import Path\nimport pandas as pd\nimport docx\ndef task_func(source_directory: str, target_directory: str) -> int:\n\n    pass\nimport os\nfrom pathlib import Path\nimport pandas as pd\nimport docx\nimport csv\nimport openpyxl\ndef task_func(source_directory: str, target_directory: str) -> int:\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n\n    Path(target_directory).mkdir(parents=True, exist_ok=True)\n\n    converted_count = 0\n    allowed_extensions = {'.txt', '.docx', '.xlsx', '.csv'}\n\n    for filename in os.listdir(source_directory):\n        file_path = os.path.join(source_directory, filename)\n        file_extension = os.path.splitext(filename)[1].lower()\n\n        if file_extension in allowed_extensions:\n            text_content = []\n\n            if file_extension == '.txt' or file_extension == '.csv':\n                with open(file_path, 'r', encoding='utf-8') as file:\n                    text_content = file.readlines()\n            elif file_extension == '.docx':\n                doc = docx.Document(file_path)\n                text_content = [para.text for para in doc.paragraphs]\n            elif file_extension == '.xlsx':\n                wb = openpyxl.load_workbook(file_path, read_only=True)\n                sheet = wb.active\n                text_content = [\n                    ' '.join(str(cell.value) if cell.value is not None else '' for cell in row)\n                    for row in sheet.iter_rows()\n                ]\n\n            df = pd.DataFrame({'Text': text_content})\n\n            csv_filename = f\"{os.path.splitext(filename)[0]}.csv\"\n            csv_path = os.path.join(target_directory, csv_filename)\n            df.to_csv(csv_path, index=False, quoting=csv.QUOTE_ALL)\n\n            converted_count += 1\n\n    return converted_count",
        "status": "fail",
        "details": {
          "test_case_9": "Traceback (most recent call last):\n  File \"__test__.py\", line 141, in test_case_9\nAssertionError: 0 != 1\n"
        }
      }
    ],
    "BigCodeBench/971": [
      {
        "task_id": "BigCodeBench/971",
        "solution": "import os\nfrom pathlib import Path\nfrom datetime import datetime, timezone\ndef task_func(directory_path: str):\n\n    pass\nimport os\nfrom pathlib import Path\nfrom datetime import datetime, timezone\ndef task_func(directory_path: str):\n    dir_path = Path(directory_path)\n    \n    if not dir_path.is_dir():\n        raise ValueError(\"The provided directory does not exist.\")\n    \n    result = []\n    \n    for entry in dir_path.iterdir():\n        if entry.is_file():\n            stats = entry.stat()\n            size = stats.st_size\n            \n            try:\n                creation_time = datetime.fromtimestamp(stats.st_birthtime, tz=timezone.utc)\n            except AttributeError:\n                creation_time = datetime.fromtimestamp(stats.st_ctime, tz=timezone.utc)\n            \n            modification_time = datetime.fromtimestamp(stats.st_mtime, tz=timezone.utc)\n            \n            result.append((\n                entry.name,\n                size,\n                creation_time.isoformat(),\n                modification_time.isoformat()\n            ))\n    \n    return result",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/985": [
      {
        "task_id": "BigCodeBench/985",
        "solution": "import pandas as pd\nimport json\nimport os\nimport math\ndef task_func(json_data, output_dir=\".\", file_name=\"country_population_report.csv\"):\n\n    pass\nimport pandas as pd\nimport json\nimport os\nimport math\ndef task_func(json_data, output_dir=\".\", file_name=\"country_population_report.csv\"):\n    # Validate and parse JSON data\n    try:\n        data = json.loads(json_data)\n    except json.JSONDecodeError:\n        raise ValueError(\"Malformed JSON data\")\n\n    if not data:\n        raise ValueError(\"Empty JSON data\")\n\n    # Prepare data for DataFrame\n    countries = []\n    populations = []\n\n    for country, population in data.items():\n        if not isinstance(country, str):\n            raise ValueError(\"Non-string country name found\")\n        \n        if not isinstance(population, (int, float)) or population < 0:\n            raise ValueError(\"Invalid population value found\")\n        \n        countries.append(country)\n        populations.append(math.floor(population))  # Round down float populations\n\n    # Create DataFrame\n    df = pd.DataFrame({\n        \"Country\": countries,\n        \"Population\": populations\n    })\n\n    # Sort DataFrame by country name\n    df = df.sort_values(\"Country\", ignore_index=True)\n\n    # Prepare file path\n    file_path = os.path.join(output_dir, file_name)\n\n    # Write DataFrame to CSV\n    try:\n        df.to_csv(file_path, index=False)\n    except IOError:\n        raise IOError(f\"Unable to write to file: {file_path}\")\n\n    return file_path, df",
        "status": "fail",
        "details": {
          "test_case_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 91, in test_case_3\nAssertionError: ValueError not raised\n",
          "test_case_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 73, in test_case_1\n  File \"__test__.py\", line 31, in task_func\nValueError: Invalid population value found\n",
          "test_case_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 102, in test_case_4\n  File \"__test__.py\", line 31, in task_func\nValueError: Invalid population value found\n",
          "test_case_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 110, in test_case_5\n  File \"__test__.py\", line 31, in task_func\nValueError: Invalid population value found\n",
          "test_case_6": "Traceback (most recent call last):\n  File \"__test__.py\", line 118, in test_case_6\n  File \"__test__.py\", line 31, in task_func\nValueError: Invalid population value found\n",
          "test_case_8": "Traceback (most recent call last):\n  File \"__test__.py\", line 142, in test_case_8\n  File \"__test__.py\", line 31, in task_func\nValueError: Invalid population value found\n",
          "test_case_9": "Traceback (most recent call last):\n  File \"__test__.py\", line 152, in test_case_9\n  File \"__test__.py\", line 31, in task_func\nValueError: Invalid population value found\n"
        }
      }
    ],
    "BigCodeBench/969": [
      {
        "task_id": "BigCodeBench/969",
        "solution": "import numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nimport pandas as pd\ndef task_func(df: pd.DataFrame) -> pd.DataFrame:\n\n    pass\nimport numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nimport pandas as pd\ndef task_func(df: pd.DataFrame) -> pd.DataFrame:\n    # Check if DataFrame is empty\n    if df.empty:\n        raise ValueError(\"The input DataFrame is empty.\")\n    \n    # Check for non-numeric data types\n    if not df.dtypes.apply(lambda x: np.issubdtype(x, np.number)).all():\n        raise TypeError(\"The DataFrame contains non-numeric data types.\")\n    \n    # Check for NaN values\n    if df.isna().any().any():\n        raise ValueError(\"The DataFrame contains NaN values.\")\n    \n    # Compute cumulative sum\n    cumsum_df = df.cumsum()\n    \n    # Initialize MinMaxScaler\n    scaler = MinMaxScaler()\n    \n    # Normalize cumulative sum\n    normalized_df = pd.DataFrame(\n        scaler.fit_transform(cumsum_df),\n        columns=df.columns,\n        index=df.index\n    )\n    \n    return normalized_df",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/988": [
      {
        "task_id": "BigCodeBench/988",
        "solution": "import os\nimport re\nfrom pathlib import Path\ndef task_func(dir_path: str, predicates: list) -> dict:\n\n    pass\nimport os\nimport re\nfrom pathlib import Path\ndef task_func(dir_path: str, predicates: list) -> dict:\n    # Check if the directory exists\n    if not os.path.isdir(dir_path):\n        raise FileNotFoundError(f\"The specified directory '{dir_path}' does not exist or is not a directory.\")\n    \n    # Remove duplicate predicates and check if any valid predicates remain\n    unique_predicates = list(set(predicates))\n    if not unique_predicates:\n        raise ValueError(\"No valid predicates are provided.\")\n    \n    result = {}\n    \n    # Iterate through items in the directory\n    for item in os.listdir(dir_path):\n        item_results = []\n        \n        # Evaluate each predicate for the current item\n        for predicate in unique_predicates:\n            try:\n                # Attempt to use the predicate as a regex pattern\n                if re.search(predicate, item):\n                    item_results.append(True)\n                else:\n                    item_results.append(False)\n            except re.error:\n                # If the predicate is not a valid regex, use simple string matching\n                item_results.append(predicate in item)\n        \n        # Store the results for the current item\n        result[item] = item_results\n    \n    return result",
        "status": "fail",
        "details": {
          "test_deduplicate_predicates": "Traceback (most recent call last):\n  File \"__test__.py\", line 151, in test_deduplicate_predicates\n  File \"__test__.py\", line 75, in helper_assert_predicate\nAssertionError: False is not true\n",
          "test_invalid_predicates": "Traceback (most recent call last):\n  File \"__test__.py\", line 156, in test_invalid_predicates\nAssertionError: ValueError not raised\n",
          "test_multiple_predicates": "Traceback (most recent call last):\n  File \"__test__.py\", line 141, in test_multiple_predicates\n  File \"__test__.py\", line 75, in helper_assert_predicate\nAssertionError: False is not true\n",
          "test_dir_is_dir": "Traceback (most recent call last):\n  File \"__test__.py\", line 100, in test_dir_is_dir\nTypeError: list indices must be integers or slices, not str\n",
          "test_dir_is_not_file": "Traceback (most recent call last):\n  File \"__test__.py\", line 108, in test_dir_is_not_file\nTypeError: list indices must be integers or slices, not str\n",
          "test_file_is_file": "Traceback (most recent call last):\n  File \"__test__.py\", line 84, in test_file_is_file\nTypeError: list indices must be integers or slices, not str\n",
          "test_file_is_not_dir": "Traceback (most recent call last):\n  File \"__test__.py\", line 92, in test_file_is_not_dir\nTypeError: list indices must be integers or slices, not str\n",
          "test_has_no_special_char": "Traceback (most recent call last):\n  File \"__test__.py\", line 126, in test_has_no_special_char\nTypeError: list indices must be integers or slices, not str\n",
          "test_has_numbers": "Traceback (most recent call last):\n  File \"__test__.py\", line 135, in test_has_numbers\nTypeError: list indices must be integers or slices, not str\n",
          "test_has_special_char": "Traceback (most recent call last):\n  File \"__test__.py\", line 117, in test_has_special_char\nTypeError: list indices must be integers or slices, not str\n"
        }
      }
    ],
    "BigCodeBench/587": [
      {
        "task_id": "BigCodeBench/587",
        "solution": "import rsa\nimport os\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom base64 import b64encode\ndef task_func(file_path):\n\n    pass\nimport rsa\nimport os\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom base64 import b64encode\ndef task_func(file_path):\n    # Generate RSA key pair\n    (pubkey, privkey) = rsa.newkeys(2048)\n\n    # Generate a random AES key\n    aes_key = os.urandom(32)  # 256-bit key\n\n    # Read the file content\n    with open(file_path, 'rb') as file:\n        plaintext = file.read()\n\n    # Pad the plaintext\n    padder = padding.PKCS7(algorithms.AES.block_size).padder()\n    padded_plaintext = padder.update(plaintext) + padder.finalize()\n\n    # Generate a random IV\n    iv = os.urandom(16)\n\n    # Create AES cipher\n    cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), backend=default_backend())\n    encryptor = cipher.encryptor()\n\n    # Encrypt the file content\n    ciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()\n\n    # Encrypt the AES key with RSA public key\n    encrypted_aes_key = rsa.encrypt(aes_key, pubkey)\n\n    # Save the encrypted file\n    encrypted_file_name = file_path + '.encrypted'\n    with open(encrypted_file_name, 'wb') as encrypted_file:\n        encrypted_file.write(iv + ciphertext)\n\n    # Save the encrypted AES key\n    encrypted_key_file_name = file_path + '.key'\n    with open(encrypted_key_file_name, 'wb') as key_file:\n        key_file.write(encrypted_aes_key)\n\n    return pubkey, encrypted_file_name, encrypted_key_file_name",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/990": [
      {
        "task_id": "BigCodeBench/990",
        "solution": "import binascii\nimport base64\nimport urllib.parse\nimport codecs\ndef task_func(hex_string):\n\n    pass\nimport binascii\nimport base64\nimport urllib.parse\nimport codecs\ndef task_func(hex_string):\n    try:\n        byte_data = binascii.unhexlify(hex_string)\n    except binascii.Error:\n        return \"Invalid hexadecimal string\"\n\n    try:\n        utf8_string = byte_data.decode('utf-8')\n    except UnicodeDecodeError:\n        return \"Invalid UTF-8 encoding\"\n\n    result = {\n        'hex': hex_string,\n        'base64': base64.b64encode(byte_data).decode('ascii'),\n        'utf-8': utf8_string,\n        'utf-16': utf8_string.encode('utf-16le').decode('utf-16le'),\n        'utf-32': utf8_string.encode('utf-32le').decode('utf-32le'),\n        'URL': urllib.parse.quote(utf8_string),\n        'ROT13': codecs.encode(utf8_string, 'rot_13')\n    }\n\n    try:\n        result['ASCII'] = utf8_string.encode('ascii').decode('ascii')\n    except UnicodeEncodeError:\n        result['ASCII'] = 'Not representable in ASCII'\n\n    return result",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/998": [
      {
        "task_id": "BigCodeBench/998",
        "solution": "import urllib.request\nimport os\nimport hashlib\nimport tarfile\n# Constants\nTARGET_TAR_FILE = \"downloaded_files.tar.gz\"\nEXPECTED_MD5_CHECKSUM = \"d41d8cd98f00b204e9800998ecf8427e\"\ndef task_func(url):\n\n    pass\nimport urllib.request\nimport os\nimport hashlib\nimport tarfile\nTARGET_TAR_FILE = \"downloaded_files.tar.gz\"\nEXPECTED_MD5_CHECKSUM = \"d41d8cd98f00b204e9800998ecf8427e\"\ndef task_func(url):\n    try:\n        # Download the file\n        urllib.request.urlretrieve(url, TARGET_TAR_FILE)\n        \n        # Calculate MD5 checksum\n        md5_hash = hashlib.md5()\n        with open(TARGET_TAR_FILE, \"rb\") as f:\n            for chunk in iter(lambda: f.read(4096), b\"\"):\n                md5_hash.update(chunk)\n        calculated_checksum = md5_hash.hexdigest()\n        \n        # Compare checksums\n        if calculated_checksum != EXPECTED_MD5_CHECKSUM:\n            print(\"Checksum mismatch. Deleting downloaded file.\")\n            os.remove(TARGET_TAR_FILE)\n            return False\n        \n        # Extract the tar.gz file\n        with tarfile.open(TARGET_TAR_FILE, \"r:gz\") as tar:\n            tar.extractall()\n        \n        print(\"File downloaded, checksum verified, and contents extracted successfully.\")\n        return True\n    \n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n        if os.path.exists(TARGET_TAR_FILE):\n            os.remove(TARGET_TAR_FILE)\n        return False",
        "status": "fail",
        "details": {
          "test_valid_file": "Traceback (most recent call last):\n  File \"__test__.py\", line 71, in test_valid_file\nAssertionError: True is not false\n"
        }
      }
    ],
    "BigCodeBench/999": [
      {
        "task_id": "BigCodeBench/999",
        "solution": "import urllib.request\nimport os\nimport csv\nimport collections\ndef task_func(url, column_name, csv_file_path):\n\n    pass\nimport urllib.request\nimport os\nimport csv\nimport collections\ndef task_func(url, column_name, csv_file_path):\n    try:\n        # Download the CSV file\n        urllib.request.urlretrieve(url, csv_file_path)\n\n        # Process the CSV file\n        value_counts = collections.defaultdict(int)\n        column_exists = False\n\n        with open(csv_file_path, 'r', newline='', encoding='utf-8') as csvfile:\n            csv_reader = csv.DictReader(csvfile)\n            \n            # Check if the specified column exists\n            if column_name not in csv_reader.fieldnames:\n                raise ValueError(f\"The provided column_name '{column_name}' does not exist in the CSV file.\")\n            \n            for row in csv_reader:\n                column_exists = True\n                value = row.get(column_name, '').strip()\n                if value:  # Only count non-empty values\n                    value_counts[value] += 1\n\n        # If the column was not found in any row, raise an exception\n        if not column_exists:\n            raise ValueError(f\"The provided column_name '{column_name}' does not exist in the CSV file.\")\n\n        return dict(value_counts)\n\n    except urllib.error.URLError as e:\n        raise Exception(f\"Error downloading the file: {e}\")\n    except csv.Error as e:\n        raise Exception(f\"Error processing the CSV file: {e}\")\n    finally:\n        # Delete the downloaded CSV file\n        if os.path.exists(csv_file_path):\n            os.remove(csv_file_path)",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/1003": [
      {
        "task_id": "BigCodeBench/1003",
        "solution": "import urllib.request\nfrom lxml import etree\nimport pandas as pd\ndef task_func(url):\n\n    pass\nimport urllib.request\nfrom lxml import etree\nimport pandas as pd\ndef task_func(url):\n    try:\n        # Fetch XML content from the URL\n        with urllib.request.urlopen(url) as response:\n            xml_content = response.read()\n\n        # Parse XML content\n        root = etree.fromstring(xml_content)\n\n        # Find all 'item' elements\n        items = root.xpath('//item')\n\n        # Check if items are found\n        if not items:\n            raise ValueError(\"XML structure does not match expected format.\")\n\n        # Extract data from 'item' elements\n        data = []\n        for item in items:\n            item_data = {child.tag: child.text.strip() if child.text else '' for child in item}\n            data.append(item_data)\n\n        # Convert the list of dictionaries to a DataFrame\n        df = pd.DataFrame(data)\n\n        return df\n\n    except urllib.error.URLError:\n        raise ValueError(\"Invalid URL or unable to fetch XML file.\")\n    except etree.XMLSyntaxError:\n        raise ValueError(\"Invalid XML syntax.\")\n    except Exception as e:\n        raise ValueError(f\"XML structure does not match expected format: {str(e)}\")",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/1004": [
      {
        "task_id": "BigCodeBench/1004",
        "solution": "import urllib.request\nimport re\nfrom collections import Counter\nimport matplotlib.pyplot as plt\ndef task_func(url):\n\n    pass\nimport urllib.request\nimport re\nfrom collections import Counter\nimport matplotlib.pyplot as plt\ndef task_func(url):\n    # Download the text file from the specified URL\n    try:\n        with urllib.request.urlopen(url) as response:\n            text = response.read().decode('utf-8')\n    except Exception as e:\n        print(f\"Error downloading file: {e}\")\n        return None, None\n\n    # Process the text to count word frequencies\n    words = re.findall(r'\\b\\w+\\b', text)\n    word_counts = Counter(words)\n\n    # Get the ten most common words\n    top_ten = word_counts.most_common(10)\n\n    # Create a bar chart\n    fig, ax = plt.subplots(figsize=(12, 6))\n    words, counts = zip(*top_ten)\n    ax.bar(words, counts, color='skyblue')\n    \n    # Customize the plot\n    ax.set_title('Ten Most Frequent Words', fontsize=16)\n    ax.set_xlabel('Words', fontsize=12)\n    ax.set_ylabel('Frequency', fontsize=12)\n    ax.tick_params(axis='both', which='major', labelsize=10)\n    plt.xticks(rotation=45, ha='right')\n    \n    # Adjust layout to prevent cutoff\n    plt.tight_layout()\n\n    return word_counts, ax",
        "status": "fail",
        "details": {
          "test_non_text_file": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 74, in test_non_text_file\nAssertionError: Exception not raised\n",
          "test_empty_file": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 65, in test_empty_file\n  File \"__test__.py\", line 30, in task_func\nValueError: not enough values to unpack (expected 2, got 0)\n"
        }
      }
    ],
    "BigCodeBench/1008": [
      {
        "task_id": "BigCodeBench/1008",
        "solution": "import requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nfrom io import StringIO\ndef task_func(url, table_id):\n\n    pass\nimport requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nfrom io import StringIO\ndef task_func(url, table_id):\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.HTTPError(f\"HTTP request failed: {str(e)}\")\n\n    soup = BeautifulSoup(response.content, 'html.parser')\n    table = soup.find('table', id=table_id)\n\n    if not table:\n        raise ValueError(\"Table with the specified ID not found.\")\n\n    rows = table.find_all('tr')\n    if not rows:\n        return pd.DataFrame()\n\n    headers = [th.get_text(strip=True) for th in rows[0].find_all(['th', 'td'])]\n    data = []\n    for row in rows[1:]:\n        cells = row.find_all(['td', 'th'])\n        if cells:\n            data.append([cell.get_text(strip=True) for cell in cells])\n\n    df = pd.DataFrame(data, columns=headers)\n    return df",
        "status": "fail",
        "details": {
          "test_empty_table": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 107, in test_empty_table\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n",
          "test_network_error": "Traceback (most recent call last):\n  File \"__test__.py\", line 14, in task_func\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1114, in __call__\n    return self._mock_call(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1118, in _mock_call\n    return self._execute_mock_call(*args, **kwargs)\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1173, in _execute_mock_call\n    raise effect\nrequests.exceptions.ConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 82, in test_network_error\n  File \"__test__.py\", line 17, in task_func\nrequests.exceptions.HTTPError: HTTP request failed: \n",
          "test_successful_scrape": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 62, in test_successful_scrape\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n",
          "test_table_not_found": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 76, in test_table_not_found\n  File \"__test__.py\", line 19, in task_func\n  File \"/usr/local/lib/python3.10/site-packages/bs4/__init__.py\", line 319, in __init__\n    for (self.markup, self.original_encoding, self.declared_html_encoding,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/builder/_htmlparser.py\", line 325, in prepare_markup\n    dammit = UnicodeDammit(markup, try_encodings, is_html=True,\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 445, in __init__\n    for encoding in self.detector.encodings:\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 301, in encodings\n    self.declared_encoding = self.find_declared_encoding(\n  File \"/usr/local/lib/python3.10/site-packages/bs4/dammit.py\", line 378, in find_declared_encoding\n    declared_encoding_match = xml_re.search(markup, endpos=xml_endpos)\nTypeError: expected string or bytes-like object\n"
        }
      }
    ],
    "BigCodeBench/1006": [
      {
        "task_id": "BigCodeBench/1006",
        "solution": "import os\nimport requests\nfrom zipfile import ZipFile, BadZipFile\ndef task_func(url, download_path=\"mnt/data/downloads/\"):\n\n    pass\nimport os\nimport requests\nfrom zipfile import ZipFile, BadZipFile\ndef task_func(url, download_path=\"mnt/data/downloads/\"):\n    try:\n        # Ensure the download directory exists\n        os.makedirs(download_path, exist_ok=True)\n\n        # Download the file\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n\n        # Check if the content type is ZIP\n        content_type = response.headers.get('Content-Type', '').lower()\n        if 'application/zip' not in content_type:\n            return \"Error: The URL does not point to a ZIP file.\"\n\n        # Generate a unique filename for the ZIP\n        zip_filename = os.path.join(download_path, 'downloaded_file.zip')\n\n        # Save the ZIP file\n        with open(zip_filename, 'wb') as file:\n            for chunk in response.iter_content(chunk_size=8192):\n                file.write(chunk)\n\n        # Extract the ZIP file\n        extract_path = os.path.join(download_path, 'extracted')\n        try:\n            with ZipFile(zip_filename, 'r') as zip_ref:\n                zip_ref.extractall(extract_path)\n        except BadZipFile:\n            os.remove(zip_filename)\n            return \"Error: The downloaded file is not a valid ZIP file.\"\n\n        # Clean up the downloaded ZIP file\n        os.remove(zip_filename)\n\n        return extract_path\n\n    except requests.exceptions.RequestException:\n        return \"Error: Unable to download the file from the provided URL.\"\n    except Exception as e:\n        return f\"Error: {str(e)}\"",
        "status": "fail",
        "details": {
          "test_valid_zip_url": "Traceback (most recent call last):\n  File \"__test__.py\", line 59, in test_valid_zip_url\nAssertionError: False is not true\n"
        }
      }
    ],
    "BigCodeBench/1013": [
      {
        "task_id": "BigCodeBench/1013",
        "solution": "import requests\nfrom urllib.parse import urljoin\nfrom bs4 import BeautifulSoup\nimport csv\ndef task_func(\n    url: str,\n    base_url: str = \"https://www.example.com\",\n    csv_file: str = \"scraped_data.csv\",\n) -> int:\n\n    pass\nimport requests\nfrom urllib.parse import urljoin\nfrom bs4 import BeautifulSoup\nimport csv\ndef task_func(\n    url: str,\n    base_url: str = \"https://www.example.com\",\n    csv_file: str = \"scraped_data.csv\",\n) -> int:\n    try:\n        # Fetch the webpage content\n        response = requests.get(url)\n        response.raise_for_status()\n\n        # Parse the HTML content\n        soup = BeautifulSoup(response.text, 'html.parser')\n\n        # Find all hyperlinks and convert to absolute URLs\n        links = soup.find_all('a', href=True)\n        absolute_urls = set(urljoin(base_url, link['href']) for link in links)\n\n        # Write absolute URLs to CSV file\n        with open(csv_file, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerow(['Absolute URL'])\n            for absolute_url in absolute_urls:\n                writer.writerow([absolute_url])\n\n        return len(absolute_urls)\n\n    except requests.RequestException as e:\n        print(f\"Error fetching the webpage: {e}\")\n    except IOError as e:\n        print(f\"Error writing to CSV file: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n    return 0",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/1012": [
      {
        "task_id": "BigCodeBench/1012",
        "solution": "import requests\nfrom pathlib import Path\nimport zipfile\n# Constants\nDOWNLOAD_DIR = Path(\"downloads\")\nZIP_DIR = Path(\"unzipped_files\")\ndef task_func(url, filename):\n\n    pass\nimport requests\nfrom pathlib import Path\nimport zipfile\nimport shutil\nDOWNLOAD_DIR = Path(\"downloads\")\nZIP_DIR = Path(\"unzipped_files\")\ndef task_func(url, filename):\n    # Ensure download directory exists\n    DOWNLOAD_DIR.mkdir(exist_ok=True)\n    \n    # Download the file\n    file_path = DOWNLOAD_DIR / filename\n    try:\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n        with file_path.open('wb') as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                f.write(chunk)\n    except requests.exceptions.RequestException as e:\n        return f\"Error: Failed to download file - {str(e)}\", []\n\n    # Ensure ZIP directory exists and is empty\n    if ZIP_DIR.exists():\n        shutil.rmtree(ZIP_DIR)\n    ZIP_DIR.mkdir(exist_ok=True)\n\n    # Extract the ZIP file\n    try:\n        with zipfile.ZipFile(file_path, 'r') as zip_ref:\n            zip_ref.extractall(ZIP_DIR)\n    except (zipfile.BadZipFile, zipfile.LargeZipFile) as e:\n        return f\"Error: Failed to extract ZIP file - {str(e)}\", []\n    except IOError as e:\n        return f\"Error: File-related error during extraction - {str(e)}\", []\n\n    # Get list of files in the unzipped directory\n    try:\n        extracted_files = [f.name for f in ZIP_DIR.iterdir() if f.is_file()]\n    except OSError as e:\n        return f\"Error: Failed to list extracted files - {str(e)}\", []\n\n    return \"Success: File downloaded and extracted successfully\", extracted_files",
        "status": "fail",
        "details": {
          "test_invalid_url": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 71, in test_invalid_url\nAssertionError: 'Download failed' not found in 'Error: Failed to extract ZIP file - File is not a zip file'\n",
          "test_non_200_http_response": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 78, in test_non_200_http_response\nAssertionError: 'Download failed' not found in 'Error: Failed to extract ZIP file - File is not a zip file'\n",
          "test_successful_download_and_extraction": "Traceback (most recent call last):\n  File \"__test__.py\", line 64, in test_successful_download_and_extraction\nAssertionError: 'Download and extraction successful' not found in 'Success: File downloaded and extracted successfully'\n"
        }
      }
    ],
    "BigCodeBench/1019": [
      {
        "task_id": "BigCodeBench/1019",
        "solution": "from PIL import Image\nimport codecs\nimport pytesseract\nIMAGE_PATH = \"image.png\"\ndef task_func(filename=IMAGE_PATH, from_encoding=\"cp1251\", to_encoding=\"utf8\"):\n\n    pass\n",
        "status": "fail",
        "details": {
          "test_ocr_and_comment_extraction_fail": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 53, in test_ocr_and_comment_extraction_fail\nAssertionError: None != ''\n",
          "test_ocr_extraction_succeeds_no_encoding_needed": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 61, in test_ocr_extraction_succeeds_no_encoding_needed\nAssertionError: None != 'Extracted Text already in utf8'\n",
          "test_ocr_fails_comment_extraction_succeeds": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 37, in test_ocr_fails_comment_extraction_succeeds\nAssertionError: None != 'Mocked Comment in cp1251'\n",
          "test_ocr_succeeds_encoding_fails": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 44, in test_ocr_succeeds_encoding_fails\nAssertionError: ValueError not raised\n",
          "test_successful_ocr_extraction_and_encoding": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 24, in test_successful_ocr_extraction_and_encoding\nAssertionError: None != 'Extracted Text in cp1251'\n"
        }
      }
    ],
    "BigCodeBench/1020": [
      {
        "task_id": "BigCodeBench/1020",
        "solution": "import json\nimport requests\nimport chardet\n# Constants\nAPI_URL = \"http://api.example.com/data\"\ndef task_func(url=API_URL, from_encoding=None, to_encoding=\"utf8\"):\n\n    pass\nimport json\nimport requests\nimport chardet\nAPI_URL = \"http://api.example.com/data\"\ndef task_func(url=API_URL, from_encoding=None, to_encoding=\"utf8\"):\n    try:\n        # Send GET request with a 5-second timeout\n        response = requests.get(url, timeout=5)\n        content = response.content\n\n        # If content is empty, return an empty dictionary\n        if not content:\n            return {}\n\n        # Detect encoding if not provided\n        if from_encoding is None:\n            detected = chardet.detect(content)\n            if detected['encoding'] is None:\n                raise ValueError(\"Unable to detect encoding for non-empty content\")\n            from_encoding = detected['encoding']\n\n        # Decode content\n        decoded_content = content.decode(from_encoding)\n\n        # Re-encode content\n        encoded_content = decoded_content.encode(to_encoding)\n\n        # Parse JSON\n        parsed_data = json.loads(encoded_content)\n\n        return parsed_data\n\n    except requests.Timeout:\n        print(\"Request timed out after 5 seconds\")\n        return {}\n    except requests.RequestException as e:\n        print(f\"Request failed: {e}\")\n        return {}\n    except json.JSONDecodeError:\n        print(\"Failed to parse JSON\")\n        return {}\n    except UnicodeDecodeError:\n        print(f\"Failed to decode content with encoding: {from_encoding}\")\n        return {}\n    except UnicodeEncodeError:\n        print(f\"Failed to encode content to: {to_encoding}\")\n        return {}",
        "status": "fail",
        "details": {
          "test_get_data_with_invalid_json": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 94, in test_get_data_with_invalid_json\nAssertionError: JSONDecodeError not raised\n"
        }
      }
    ],
    "BigCodeBench/1015": [
      {
        "task_id": "BigCodeBench/1015",
        "solution": "import requests\nfrom lxml import html\nimport pandas as pd\nimport sqlite3\ndef task_func(webpage_url: str, database_name: str = \"my_database.db\") -> int:\n\n    pass\nimport requests\nfrom lxml import html\nimport pandas as pd\nimport sqlite3\ndef task_func(webpage_url: str, database_name: str = \"my_database.db\") -> int:\n    try:\n        # Fetch webpage content\n        if webpage_url.startswith(('http://', 'https://')):\n            response = requests.get(webpage_url)\n            response.raise_for_status()\n            content = response.content\n        else:\n            with open(webpage_url, 'rb') as file:\n                content = file.read()\n\n        # Parse HTML content\n        tree = html.fromstring(content)\n        tables = tree.xpath('//table')\n\n        if not tables:\n            return 0\n\n        # Extract data from the first table\n        table_data = []\n        for row in tables[0].xpath('.//tr'):\n            row_data = [cell.text_content().strip() for cell in row.xpath('.//td|.//th')]\n            if row_data:\n                table_data.append(row_data)\n\n        if not table_data:\n            return 0\n\n        # Convert to DataFrame\n        df = pd.DataFrame(table_data[1:], columns=table_data[0])\n\n        # Connect to SQLite database and replace the table\n        with sqlite3.connect(database_name) as conn:\n            conn.execute(\"DROP TABLE IF EXISTS my_table\")\n            df.to_sql('my_table', conn, index=False, if_exists='replace')\n\n        return len(df)\n\n    except requests.RequestException as e:\n        raise requests.RequestException(f\"Network error: {str(e)}\")\n    except sqlite3.DatabaseError as e:\n        raise sqlite3.DatabaseError(f\"Database error: {str(e)}\")\n    except Exception as e:\n        raise Exception(f\"Unexpected error: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_local_file_url": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 86, in test_local_file_url\nAssertionError: 0 != 1\n",
          "test_valid_webpage_url": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 75, in test_valid_webpage_url\nAssertionError: 0 != 1\n"
        }
      }
    ],
    "BigCodeBench/583": [
      {
        "task_id": "BigCodeBench/583",
        "solution": "import rsa\nimport os\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Cipher import AES\nfrom base64 import b64encode, b64decode\ndef task_func():\n\n    pass\nimport rsa\nimport os\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Cipher import AES\nfrom base64 import b64encode, b64decode\ndef task_func():\n    # Generate RSA key pair\n    (pubkey, privkey) = rsa.newkeys(2048)\n\n    # Generate a random password and nonce for AES encryption\n    password = get_random_bytes(32)  # 256-bit key\n    nonce = get_random_bytes(16)  # 128-bit nonce\n\n    # Convert private key to PEM format\n    privkey_pem = privkey.save_pkcs1()\n\n    # Encrypt the private key\n    cipher = AES.new(password, AES.MODE_GCM, nonce=nonce)\n    ciphertext, tag = cipher.encrypt_and_digest(privkey_pem)\n\n    # Generate a random filename\n    random_bytes = get_random_bytes(8)\n    filename = f\"private_key_{random_bytes.hex()}.txt\"\n\n    # Combine nonce, ciphertext, and tag\n    encrypted_data = nonce + ciphertext + tag\n\n    # Save the encrypted private key to a file\n    with open(filename, 'wb') as f:\n        f.write(encrypted_data)\n\n    return pubkey, filename, password, nonce",
        "status": "fail",
        "details": {
          "test_key_size": "Traceback (most recent call last):\n  File \"__test__.py\", line 66, in test_key_size\nAssertionError: 2048 != 512\n",
          "test_encryption_decryption": "Traceback (most recent call last):\n  File \"__test__.py\", line 77, in test_encryption_decryption\n  File \"/usr/local/lib/python3.10/codecs.py\", line 322, in decode\n    (result, consumed) = self._buffer_decode(data, self.errors, final)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 1: invalid start byte\n",
          "test_file_content": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_file_content\n  File \"/usr/local/lib/python3.10/codecs.py\", line 322, in decode\n    (result, consumed) = self._buffer_decode(data, self.errors, final)\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xc5 in position 4: invalid continuation byte\n"
        }
      }
    ],
    "BigCodeBench/1022": [
      {
        "task_id": "BigCodeBench/1022",
        "solution": "import pandas as pd\nimport os\nfrom datetime import datetime\nfrom pandas.errors import EmptyDataError\ndef task_func(csv_file_path, column_name, date_format=\"%Y-%m-%d\"):\n\n    pass\nimport pandas as pd\nimport os\nfrom datetime import datetime\nfrom pandas.errors import EmptyDataError\ndef task_func(csv_file_path, column_name, date_format=\"%Y-%m-%d\"):\n    if not os.path.exists(csv_file_path):\n        raise FileNotFoundError(f\"The file {csv_file_path} does not exist.\")\n\n    try:\n        df = pd.read_csv(csv_file_path)\n\n        if df.empty:\n            return pd.DataFrame()\n\n        if column_name not in df.columns:\n            raise ValueError(f\"The column '{column_name}' is not present in the CSV file.\")\n\n        df[column_name] = pd.to_datetime(df[column_name], format=date_format)\n        \n        current_date = datetime.now()\n        df_filtered = df[df[column_name] <= current_date]\n        \n        return df_filtered.sort_values(by=column_name)\n\n    except EmptyDataError:\n        return pd.DataFrame()\n    except pd.errors.ParserError as e:\n        raise ValueError(f\"Error parsing CSV file: {str(e)}\")",
        "status": "fail",
        "details": {
          "test_no_future_dates": "Traceback (most recent call last):\n  File \"__test__.py\", line 97, in test_no_future_dates\nAssertionError: False is not true\n",
          "test_valid_input": "Traceback (most recent call last):\n  File \"__test__.py\", line 62, in test_valid_input\nAssertionError: True is not false\n"
        }
      }
    ],
    "BigCodeBench/1039": [
      {
        "task_id": "BigCodeBench/1039",
        "solution": "import ssl\nimport os\nimport hashlib\ndef task_func(client_socket, cert_file, key_file, buffer_size=1024):\n\n    pass\nimport ssl\nimport os\nimport hashlib\ndef task_func(client_socket, cert_file, key_file, buffer_size=1024):\n    \"\"\"\n    Secures a client socket using SSL/TLS, receives a file path from the client,\n    calculates the SHA256 hash of the file, and sends the hash back to the client.\n\n    Args:\n        client_socket: The client socket to be secured and used for communication.\n        cert_file (str): Path to the SSL certificate file.\n        key_file (str): Path to the SSL key file.\n        buffer_size (int): Size of the buffer for receiving data. Default is 1024.\n\n    Returns:\n        str: The SHA256 hash of the requested file, 'File not found' if the file does not exist,\n             or an error message in case of an exception.\n    \"\"\"\n    try:\n        # Create SSL context and wrap the socket\n        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n        context.load_cert_chain(certfile=cert_file, keyfile=key_file)\n        secure_socket = context.wrap_socket(client_socket, server_side=True)\n\n        # Receive the file path from the client\n        file_path = secure_socket.recv(buffer_size).decode().strip()\n\n        # Check if the file exists\n        if not os.path.exists(file_path):\n            secure_socket.send(b\"File not found\")\n            return \"File not found\"\n\n        # Calculate SHA256 hash of the file\n        sha256_hash = hashlib.sha256()\n        with open(file_path, \"rb\") as file:\n            for chunk in iter(lambda: file.read(4096), b\"\"):\n                sha256_hash.update(chunk)\n        file_hash = sha256_hash.hexdigest()\n\n        # Send the hash back to the client\n        secure_socket.send(file_hash.encode())\n        return file_hash\n\n    except ssl.SSLError as e:\n        error_msg = f\"SSL error: {str(e)}\"\n    except IOError as e:\n        error_msg = f\"I/O error: {str(e)}\"\n    except Exception as e:\n        error_msg = f\"Unexpected error: {str(e)}\"\n\n    # Send error message to client and return it\n    secure_socket.send(error_msg.encode())\n    return error_msg",
        "status": "fail",
        "details": {
          "test_exception_handling": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 145, in test_exception_handling\nAssertionError: False is not true\n",
          "test_file_found": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 100, in test_file_found\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 898, in assert_called\n    raise AssertionError(msg)\nAssertionError: Expected 'close' to have been called.\n",
          "test_file_not_found": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 127, in test_file_not_found\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 898, in assert_called\n    raise AssertionError(msg)\nAssertionError: Expected 'close' to have been called.\n"
        }
      }
    ],
    "BigCodeBench/1042": [
      {
        "task_id": "BigCodeBench/1042",
        "solution": "import smtplib\nfrom email.message import EmailMessage\nimport getpass\nSERVER_ADDRESS = \"localhost\"\nSERVER_PORT = 25\nBUFFER_SIZE = 1024\nSMTP_SERVER = \"smtp.gmail.com\"\nSMTP_PORT = 587\ndef task_func(client_socket):\n\n    pass\nimport smtplib\nfrom email.message import EmailMessage\nimport getpass\nBUFFER_SIZE = 1024\nSMTP_SERVER = \"smtp.gmail.com\"\nSMTP_PORT = 587\ndef task_func(client_socket):\n    try:\n        # Receive message from client socket\n        message = client_socket.recv(BUFFER_SIZE).decode('utf-8')\n        \n        # Get email details from user\n        sender_email = input(\"Enter sender's email: \")\n        recipient_email = input(\"Enter recipient's email: \")\n        sender_password = getpass.getpass(\"Enter sender's email password: \")\n        \n        # Create email message\n        email = EmailMessage()\n        email['From'] = sender_email\n        email['To'] = recipient_email\n        email['Subject'] = \"Message from Client Socket\"\n        email.set_content(message)\n        \n        # Connect to SMTP server and send email\n        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:\n            server.starttls()\n            server.login(sender_email, sender_password)\n            server.send_message(email)\n        \n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n    finally:\n        client_socket.close()",
        "status": "fail",
        "details": {
          "test_smtp_server_connection_error": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 111, in test_smtp_server_connection_error\nAssertionError: SMTPConnectError not raised\n",
          "test_successful_email_dispatch": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 149, in test_successful_email_dispatch\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 920, in assert_called_with\n    raise AssertionError(error_message)\nAssertionError: expected call not found.\nExpected: SMTP('smtp.gmail.com', 587)\nActual: not called.\n",
          "test_successful_email_send": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 70, in test_successful_email_send\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 920, in assert_called_with\n    raise AssertionError(error_message)\nAssertionError: expected call not found.\nExpected: SMTP('smtp.gmail.com', 587)\nActual: not called.\n"
        }
      }
    ],
    "BigCodeBench/1057": [
      {
        "task_id": "BigCodeBench/1057",
        "solution": "import pandas as pd\nimport itertools\nimport numpy as np\ndef task_func(animals=None, foods=None):\n\n    pass\nimport pandas as pd\nimport itertools\nimport numpy as np\ndef task_func(animals=None, foods=None):\n    # Default lists if not provided\n    default_animals = ['cat', 'dog', 'rabbit', 'hamster', 'parrot']\n    default_foods = ['carrot', 'apple', 'banana', 'fish', 'meat']\n\n    # Use default lists if not provided or empty\n    animals = animals if animals else default_animals\n    foods = foods if foods else default_foods\n\n    # If both lists are empty, return an empty DataFrame\n    if not animals and not foods:\n        return pd.DataFrame()\n\n    # Generate all combinations\n    combinations = list(itertools.product(animals, foods))\n\n    # Shuffle combinations\n    np.random.shuffle(combinations)\n\n    # Create DataFrame\n    df = pd.DataFrame(index=animals, columns=foods)\n\n    # Fill DataFrame with combinations\n    for animal, food in combinations:\n        df.at[animal, food] = f\"{animal}:{food}\"\n\n    return df",
        "status": "fail",
        "details": {
          "test_default_input": "Traceback (most recent call last):\n  File \"__test__.py\", line 47, in test_default_input\nAssertionError: Tuples differ: (5, 5) != (10, 7)\n\nFirst differing element 0:\n5\n10\n\n- (5, 5)\n+ (10, 7) : The shape of the DataFrame with default inputs is not as expected.\n",
          "test_empty_input": "Traceback (most recent call last):\n  File \"__test__.py\", line 73, in test_empty_input\nAssertionError: Tuples differ: (5, 5) != (0, 0)\n\nFirst differing element 0:\n5\n0\n\n- (5, 5)\n+ (0, 0) : The shape of the DataFrame with empty inputs is not as expected.\n",
          "test_partial_default": "Traceback (most recent call last):\n  File \"__test__.py\", line 104, in test_partial_default\nAssertionError: Tuples differ: (3, 5) != (3, 7)\n\nFirst differing element 1:\n5\n7\n\n- (3, 5)\n?     ^\n\n+ (3, 7)\n?     ^\n : The shape of the DataFrame with partial default inputs is not as expected.\n"
        }
      }
    ],
    "BigCodeBench/1077": [
      {
        "task_id": "BigCodeBench/1077",
        "solution": "from datetime import datetime\nimport pytz\nimport numpy as np\ndef task_func(time_strings, timezone):\n\n    pass\nfrom datetime import datetime\nimport pytz\nimport numpy as np\ndef task_func(time_strings, timezone):\n    if len(time_strings) < 2:\n        return 0.0\n\n    tz = pytz.timezone(timezone)\n    \n    def parse_and_localize(ts):\n        dt = datetime.fromisoformat(ts.rstrip('Z'))\n        return tz.localize(dt) if dt.tzinfo is None else dt.astimezone(tz)\n    \n    datetimes = [parse_and_localize(ts) for ts in time_strings]\n    \n    time_diffs = [abs((datetimes[i+1] - datetimes[i]).total_seconds()) \n                  for i in range(len(datetimes) - 1)]\n    \n    return float(np.mean(time_diffs)) if time_diffs else 0.0",
        "status": "fail",
        "details": {
          "test_different_timezones": "Traceback (most recent call last):\n  File \"__test__.py\", line 44, in test_different_timezones\n  File \"__test__.py\", line 20, in task_func\n  File \"__test__.py\", line 20, in <listcomp>\n  File \"__test__.py\", line 17, in parse_and_localize\nValueError: Invalid isoformat string: '01/04/21 12:00:00.000'\n",
          "test_example_case": "Traceback (most recent call last):\n  File \"__test__.py\", line 36, in test_example_case\n  File \"__test__.py\", line 20, in task_func\n  File \"__test__.py\", line 20, in <listcomp>\n  File \"__test__.py\", line 17, in parse_and_localize\nValueError: Invalid isoformat string: '30/03/09 16:31:32.123'\n",
          "test_out_of_order_strings": "Traceback (most recent call last):\n  File \"__test__.py\", line 69, in test_out_of_order_strings\n  File \"__test__.py\", line 20, in task_func\n  File \"__test__.py\", line 20, in <listcomp>\n  File \"__test__.py\", line 17, in parse_and_localize\nValueError: Invalid isoformat string: '01/04/21 12:02:02.000'\n",
          "test_span_across_days": "Traceback (most recent call last):\n  File \"__test__.py\", line 61, in test_span_across_days\n  File \"__test__.py\", line 20, in task_func\n  File \"__test__.py\", line 20, in <listcomp>\n  File \"__test__.py\", line 17, in parse_and_localize\nValueError: Invalid isoformat string: '31/03/21 23:59:00.000'\n",
          "test_varying_differences": "Traceback (most recent call last):\n  File \"__test__.py\", line 53, in test_varying_differences\n  File \"__test__.py\", line 20, in task_func\n  File \"__test__.py\", line 20, in <listcomp>\n  File \"__test__.py\", line 17, in parse_and_localize\nValueError: Invalid isoformat string: '01/04/21 12:00:00.000'\n"
        }
      }
    ],
    "BigCodeBench/1129": [
      {
        "task_id": "BigCodeBench/1129",
        "solution": "import json\nimport requests\nimport os\nfrom datetime import datetime\ndef task_func(json_data, unknown_key, save_dir=None):\n\n    pass\nimport json\nimport requests\nimport os\nfrom datetime import datetime\ndef task_func(json_data, unknown_key, save_dir=None):\n    try:\n        # Parse the JSON string\n        data = json.loads(json_data)\n        \n        # Get the URL associated with the specified key\n        if unknown_key not in data:\n            raise KeyError(f\"Key '{unknown_key}' not found in JSON data\")\n        url = data[unknown_key]\n        \n        # Download the file from the URL\n        response = requests.get(url)\n        response.raise_for_status()\n        \n        # Generate timestamp and create filename\n        timestamp = datetime.now().strftime('%Y%m%d%H%M%S%f')\n        filename = f\"{unknown_key}_{timestamp}.txt\"\n        \n        # Set save directory to current working directory if not specified\n        if save_dir is None:\n            save_dir = os.getcwd()\n        \n        # Ensure the save directory exists\n        os.makedirs(save_dir, exist_ok=True)\n        \n        # Create full file path\n        file_path = os.path.join(save_dir, filename)\n        \n        # Save the file\n        with open(file_path, 'wb') as file:\n            file.write(response.content)\n        \n        # Return the absolute path of the saved file\n        return os.path.abspath(file_path)\n    \n    except json.JSONDecodeError as e:\n        print(f\"Error decoding JSON: {e}\")\n    except KeyError as e:\n        print(f\"Key error: {e}\")\n    except requests.RequestException as e:\n        print(f\"Error downloading file: {e}\")\n    except IOError as e:\n        print(f\"Error saving file: {e}\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n    \n    return None",
        "status": "fail",
        "details": {
          "test_download_with_incorrect_key": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 89, in test_download_with_incorrect_key\nAssertionError: KeyError not raised\n",
          "test_multiple_downloads": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 118, in test_multiple_downloads\nAssertionError: None == None\n",
          "test_download_to_default_directory": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 106, in test_download_to_default_directory\n  File \"/usr/local/lib/python3.10/genericpath.py\", line 19, in exists\n    os.stat(path)\nTypeError: stat: path should be string, bytes, os.PathLike or integer, not NoneType\n",
          "test_download_with_direct_key": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 81, in test_download_with_direct_key\n  File \"/usr/local/lib/python3.10/genericpath.py\", line 19, in exists\n    os.stat(path)\nTypeError: stat: path should be string, bytes, os.PathLike or integer, not NoneType\n",
          "test_download_with_specified_directory": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.10/unittest/mock.py\", line 1379, in patched\n    return func(*newargs, **newkeywargs)\n  File \"__test__.py\", line 97, in test_download_with_specified_directory\n  File \"/usr/local/lib/python3.10/genericpath.py\", line 19, in exists\n    os.stat(path)\nTypeError: stat: path should be string, bytes, os.PathLike or integer, not NoneType\n"
        }
      }
    ],
    "BigCodeBench/1124": [
      {
        "task_id": "BigCodeBench/1124",
        "solution": "import re\nfrom urllib.parse import urlparse\nfrom bs4 import BeautifulSoup\nimport requests\ndef task_func(myString):\n\n    pass\nimport re\nfrom urllib.parse import urlparse\nfrom bs4 import BeautifulSoup\nimport requests\ndef task_func(myString):\n    # Regular expression to find URLs in the string\n    url_pattern = r'https?://(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&//=]*)'\n    \n    # Try to find a URL in the string\n    match = re.search(url_pattern, myString)\n    \n    if not match:\n        return \"No valid URL found in the provided string.\"\n    \n    url = match.group(0)\n    \n    # Validate the URL\n    try:\n        result = urlparse(url)\n        if not all([result.scheme, result.netloc]):\n            return \"No valid URL found in the provided string.\"\n    except ValueError:\n        return \"No valid URL found in the provided string.\"\n    \n    # Attempt to fetch the web page\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException:\n        return f\"Unable to fetch the content of the URL: {url}\"\n    \n    # Parse the HTML content\n    soup = BeautifulSoup(response.text, 'html.parser')\n    \n    # Try to find the title tag\n    title_tag = soup.find('title')\n    \n    if title_tag and title_tag.string:\n        return title_tag.string.strip()\n    else:\n        return \"No title tag found in the webpage.\"",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/1085": [
      {
        "task_id": "BigCodeBench/1085",
        "solution": "import re\nfrom collections import Counter\nimport matplotlib.pyplot as plt\ndef task_func(text):\n\n    pass\nimport re\nfrom collections import Counter\nimport matplotlib.pyplot as plt\ndef task_func(text):\n    # Lowercase the text and remove punctuation\n    cleaned_text = re.sub(r'[^\\w\\s]', '', text.lower())\n    \n    # Split the text into words\n    words = cleaned_text.split()\n    \n    # Count the frequency of each word\n    word_counts = Counter(words)\n    \n    # Get the 10 most common words\n    top_10 = word_counts.most_common(10)\n    \n    # Separate words and counts for plotting\n    words, counts = zip(*top_10)\n    \n    # Create a bar plot\n    fig, ax = plt.subplots(figsize=(12, 6))\n    bars = ax.bar(words, counts, color='skyblue', edgecolor='navy')\n    \n    # Customize the plot\n    ax.set_title('Top 10 Most Common Words', fontsize=16, fontweight='bold')\n    ax.set_xlabel('Words', fontsize=12)\n    ax.set_ylabel('Frequency', fontsize=12)\n    ax.tick_params(axis='both', which='major', labelsize=10)\n    plt.xticks(rotation=45, ha='right')\n    \n    # Add value labels on top of each bar\n    for bar in bars:\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height,\n                f'{height}', ha='center', va='bottom')\n    \n    # Adjust layout and add grid\n    plt.tight_layout()\n    ax.grid(axis='y', linestyle='--', alpha=0.7)\n    \n    return top_10, ax",
        "status": "fail",
        "details": {
          "test_empty_text": "Traceback (most recent call last):\n  File \"__test__.py\", line 56, in test_empty_text\n  File \"__test__.py\", line 24, in task_func\nValueError: not enough values to unpack (expected 2, got 0)\n"
        }
      }
    ],
    "BigCodeBench/1053": [
      {
        "task_id": "BigCodeBench/1053",
        "solution": "import pandas as pd\nfrom sklearn.feature_extraction.text import CountVectorizer\nimport matplotlib.pyplot as plt\n# Constants\nSTOP_WORDS = [\"a\", \"an\", \"the\", \"in\", \"on\", \"at\", \"and\", \"or\"]\ndef task_func(file_path, save_path=None):\n\n    pass\nimport pandas as pd\nfrom sklearn.feature_extraction.text import CountVectorizer\nimport matplotlib.pyplot as plt\nSTOP_WORDS = [\"a\", \"an\", \"the\", \"in\", \"on\", \"at\", \"and\", \"or\"]\ndef task_func(file_path, save_path=None):\n    try:\n        # Read the CSV file\n        df = pd.read_csv(file_path, header=0)\n        \n        # If no header, assume first column is text data\n        if 'Text' not in df.columns:\n            df.columns = ['Text']\n        \n        # Combine all text into a single string\n        text = ' '.join(df['Text'].astype(str))\n        \n        # Create and fit CountVectorizer\n        vectorizer = CountVectorizer(stop_words=STOP_WORDS)\n        word_count = vectorizer.fit_transform([text])\n        \n        # Get word frequencies\n        word_freq = dict(zip(vectorizer.get_feature_names_out(), word_count.toarray()[0]))\n        \n        # Sort words by frequency and get top 10\n        top_words = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:10]\n        \n        # Separate words and frequencies for plotting\n        words, frequencies = zip(*top_words)\n        \n        # Create the plot\n        fig, ax = plt.subplots(figsize=(12, 6))\n        ax.bar(words, frequencies)\n        ax.set_title('Top 10 Most Common Words')\n        ax.set_xlabel('Words')\n        ax.set_ylabel('Frequency')\n        plt.xticks(rotation=45, ha='right')\n        plt.tight_layout()\n        \n        if save_path:\n            plt.savefig(save_path)\n            plt.close(fig)\n            return None\n        else:\n            return ax\n        \n    except FileNotFoundError:\n        raise FileNotFoundError(f\"The file '{file_path}' was not found.\")\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n        return None",
        "status": "pass",
        "details": {}
      }
    ],
    "BigCodeBench/1137": [
      {
        "task_id": "BigCodeBench/1137",
        "solution": "import bs4\nimport requests\nimport re\nimport json\ndef task_func(url: str, output_path: str) -> list:\n\n    pass\nimport bs4\nimport requests\nimport re\nimport json\ndef task_func(url: str, output_path: str) -> list:\n    # Regular expression pattern for phone numbers\n    phone_pattern = r'\\b(?:\\+?1[-.\\s]?)?(?:\\(\\d{3}\\)|\\d{3})[-.\\s]?\\d{3}[-.\\s]?\\d{4}\\b'\n    \n    def extract_text(html_content):\n        soup = bs4.BeautifulSoup(html_content, 'html.parser')\n        return soup.get_text(separator=' ', strip=True)\n\n    # Fetch content from URL or local file\n    if url.startswith(('http://', 'https://')):\n        response = requests.get(url)\n        content = response.text\n    else:\n        with open(url, 'r', encoding='utf-8') as file:\n            content = file.read()\n\n    # Extract text from HTML content\n    text = extract_text(content)\n\n    # Find all phone numbers in the text\n    phone_numbers = re.findall(phone_pattern, text)\n\n    # Remove duplicates and sort the list\n    phone_numbers = sorted(set(phone_numbers))\n\n    # Save phone numbers to JSON file\n    with open(output_path, 'w', encoding='utf-8') as json_file:\n        json.dump(phone_numbers, json_file, indent=2, ensure_ascii=False)\n\n    return phone_numbers",
        "status": "fail",
        "details": {
          "test_phone_numbers_page_1": "Traceback (most recent call last):\n  File \"__test__.py\", line 69, in test_phone_numbers_page_1\n  File \"__test__.py\", line 94, in run_test_case\n  File \"__test__.py\", line 25, in task_func\nFileNotFoundError: [Errno 2] No such file or directory: 'file:///tmp/tmpeu2r0b2g/test_page_1.html'\n",
          "test_phone_numbers_page_2": "Traceback (most recent call last):\n  File \"__test__.py\", line 74, in test_phone_numbers_page_2\n  File \"__test__.py\", line 94, in run_test_case\n  File \"__test__.py\", line 25, in task_func\nFileNotFoundError: [Errno 2] No such file or directory: 'file:///tmp/tmpybibbpwx/test_page_2.html'\n",
          "test_phone_numbers_page_3": "Traceback (most recent call last):\n  File \"__test__.py\", line 79, in test_phone_numbers_page_3\n  File \"__test__.py\", line 94, in run_test_case\n  File \"__test__.py\", line 25, in task_func\nFileNotFoundError: [Errno 2] No such file or directory: 'file:///tmp/tmpf6iz__ov/test_page_3.html'\n",
          "test_phone_numbers_page_4": "Traceback (most recent call last):\n  File \"__test__.py\", line 84, in test_phone_numbers_page_4\n  File \"__test__.py\", line 94, in run_test_case\n  File \"__test__.py\", line 25, in task_func\nFileNotFoundError: [Errno 2] No such file or directory: 'file:///tmp/tmphfzem0hm/test_page_4.html'\n",
          "test_phone_numbers_page_5": "Traceback (most recent call last):\n  File \"__test__.py\", line 89, in test_phone_numbers_page_5\n  File \"__test__.py\", line 94, in run_test_case\n  File \"__test__.py\", line 25, in task_func\nFileNotFoundError: [Errno 2] No such file or directory: 'file:///tmp/tmphzdbigar/test_page_5.html'\n"
        }
      }
    ],
    "BigCodeBench/1040": [
      {
        "task_id": "BigCodeBench/1040",
        "solution": "import socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n\n    pass\nimport socket\nimport select\nimport queue\nfrom datetime import datetime, timedelta\ndef task_func(\n    server_address=\"localhost\", server_port=12345, buffer_size=1024, run_duration=5\n):\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setblocking(0)\n    server.bind((server_address, server_port))\n    server.listen(5)\n\n    inputs = [server]\n    outputs = []\n    message_queues = {}\n\n    start_time = datetime.now()\n    end_time = start_time + timedelta(seconds=run_duration)\n\n    while datetime.now() < end_time:\n        readable, writable, exceptional = select.select(inputs, outputs, inputs, 0.1)\n\n        for s in readable:\n            if s is server:\n                connection, client_address = s.accept()\n                connection.setblocking(0)\n                inputs.append(connection)\n                message_queues[connection] = queue.Queue()\n            else:\n                try:\n                    data = s.recv(buffer_size)\n                    if data:\n                        current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                        message_queues[s].put(f\"{data.decode().strip()} [Server time: {current_time}]\".encode())\n                        if s not in outputs:\n                            outputs.append(s)\n                    else:\n                        if s in outputs:\n                            outputs.remove(s)\n                        inputs.remove(s)\n                        s.close()\n                        del message_queues[s]\n                except Exception as e:\n                    print(f\"Error handling client: {e}\")\n                    if s in outputs:\n                        outputs.remove(s)\n                    inputs.remove(s)\n                    s.close()\n                    del message_queues[s]\n\n        for s in writable:\n            try:\n                next_msg = message_queues[s].get_nowait()\n            except queue.Empty:\n                outputs.remove(s)\n            else:\n                s.send(next_msg)\n\n        for s in exceptional:\n            print(f\"Handling exceptional condition for {s.getpeername()}\")\n            inputs.remove(s)\n            if s in outputs:\n                outputs.remove(s)\n            s.close()\n            del message_queues[s]\n\n    server.close()\n    \n    duration = datetime.now() - start_time\n    return f\"Server ran for {duration.total_seconds():.2f} seconds, echoing messages with timestamps.\"",
        "status": "fail",
        "details": {
          "test_multiple_connections": "Traceback (most recent call last):\n  File \"__test__.py\", line 129, in test_multiple_connections\nConnectionResetError: [Errno 104] Connection reset by peer\n",
          "test_queue_empty_condition": "Traceback (most recent call last):\n  File \"__test__.py\", line 109, in test_queue_empty_condition\nConnectionRefusedError: [Errno 111] Connection refused\n"
        }
      }
    ]
  }
}