{"task_id": "BigCodeBench/13", "solution": "Here's a self-contained Python function that uses `subprocess` to download files from a specified directory on an FTP server using `wget`. The function handles exceptions for connection issues, login failures, and directory changes, as specified in your requirements.\n\n```python\nimport subprocess\nimport ftplib\nimport os\n\ndef task_func(ftp_server='ftp.dlptest.com', ftp_user='dlpuser', ftp_password='rNrKYTX9g7z3RgJRmxWuGHbeu', ftp_dir='/ftp/test'):\n    try:\n        # Connect to the FTP server\n        ftp = ftplib.FTP(ftp_server)\n    except Exception as e:\n        raise Exception(f\"Failed to connect to FTP server {ftp_server}: {str(e)}\")\n\n    try:\n        # Log in to the FTP server\n        ftp.login(user=ftp_user, passwd=ftp_password)\n    except Exception as e:\n        raise Exception(f\"Failed to log into FTP server {ftp_server} with user {ftp_user}: {str(e)}\")\n\n    try:\n        # Change to the specified directory\n        ftp.cwd(ftp_dir)\n    except Exception as e:\n        raise Exception(f\"Failed to change to directory {ftp_dir} on server {ftp_server}: {str(e)}\")\n\n    # List files in the directory\n    filenames = ftp.nlst()\n    ftp.quit()\n\n    # Prepare the wget command\n    wget_command = ['wget', '--user', ftp_user, '--password', ftp_password, '-r', '-np', '-nH', '--cut-dirs=1', f'ftp://{ftp_server}{ftp_dir}/']\n\n    # Execute the wget command\n    try:\n        subprocess.run(wget_command, check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Error occurred while downloading files: {str(e)}\")\n\n    return filenames\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        downloaded_files = task_func()\n        print(\"Files attempted to download:\", downloaded_files)\n    except Exception as e:\n        print(e)\n```\n\n### Explanation:\n1. **FTP Connection**: The function attempts to connect to the FTP server and handle any exceptions that may arise during the connection, login, or directory change.\n2. **File Listing**: It retrieves the list of filenames in the specified directory using `ftp.nlst()`.\n3. **Wget Command**: It constructs a `wget` command to download files recursively from the specified FTP directory.\n4. **Subprocess Execution**: The `subprocess.run()` function is used to execute the `wget` command, and it checks for errors during execution.\n5. **Error Handling**: The function raises exceptions with specific messages if any of the FTP operations fail.\n\nYou can run this code in an environment where `wget` is installed and accessible. Make sure to adjust the FTP server details as needed."}
{"task_id": "BigCodeBench/15", "solution": "Here's a self-contained Python function that meets the requirements specified in your problem statement. This function reads shell commands from a CSV file, executes them, and saves the outputs (or error messages) to separate files in a specified output directory.\n\n```python\nimport subprocess\nimport csv\nimport os\n\ndef task_func(commands_file_path, output_dir_path):\n    # Check if the commands file exists\n    if not os.path.exists(commands_file_path):\n        raise FileNotFoundError(f\"The file {commands_file_path} does not exist.\")\n    \n    # Create the output directory if it doesn't exist\n    os.makedirs(output_dir_path, exist_ok=True)\n    \n    output_files = []\n    \n    # Read commands from the CSV file\n    with open(commands_file_path, mode='r', newline='') as csvfile:\n        reader = csv.reader(csvfile)\n        for index, row in enumerate(reader):\n            command = row[0]  # Assuming each row contains one command\n            output_file_path = os.path.join(output_dir_path, f'command_{index}_output.txt')\n            output_files.append(output_file_path)\n            \n            try:\n                # Execute the command\n                result = subprocess.run(command, shell=True, check=True, text=True, capture_output=True)\n                # Write the standard output to the file\n                with open(output_file_path, 'w') as output_file:\n                    output_file.write(result.stdout)\n            except subprocess.CalledProcessError as e:\n                # Write the error message and exit code to the file\n                with open(output_file_path, 'w') as output_file:\n                    output_file.write(f\"Error: {e.stderr}\\nExit Code: {e.returncode}\\n\")\n    \n    return output_files\n```\n\n### Explanation:\n1. **File Existence Check**: The function first checks if the specified CSV file exists. If not, it raises a `FileNotFoundError`.\n2. **Output Directory Creation**: It creates the output directory if it does not already exist using `os.makedirs`.\n3. **Reading Commands**: It reads commands from the CSV file. Each command is expected to be in a separate row.\n4. **Executing Commands**: For each command, it uses `subprocess.run` to execute the command. The `shell=True` argument allows the command to be executed through the shell.\n5. **Output Handling**: If the command executes successfully, its output is written to a file. If it fails, the error message and exit code are written to the same file.\n6. **Return Value**: The function returns a list of paths to the output files created.\n\n### Usage:\nTo use this function, you would call it with the path to your CSV file containing the commands and the desired output directory. For example:\n\n```python\noutput_files = task_func('commands.csv', 'output_directory')\nprint(output_files)\n```\n\nThis will execute the commands listed in `commands.csv` and save the outputs in `output_directory`."}
{"task_id": "BigCodeBench/17", "solution": "Here's a self-contained Python code that checks if a particular process is running based on its name, and either starts it or restarts it as required:\n\n```python\nimport subprocess\nimport psutil\nimport time\n\ndef task_func(process_name: str) -> str:\n    # Check if the process is running\n    process_running = False\n    for proc in psutil.process_iter(['name']):\n        if proc.info['name'] == process_name:\n            process_running = True\n            break\n\n    if not process_running:\n        # Process not found, start it\n        subprocess.Popen(process_name)\n        return f\"Process not found. Starting {process_name}.\"\n    else:\n        # Process found, restart it\n        for proc in psutil.process_iter(['name']):\n            if proc.info['name'] == process_name:\n                proc.terminate()  # Terminate the process\n                proc.wait()  # Wait for the process to terminate\n                break\n        time.sleep(1)  # Optional: wait a moment before restarting\n        subprocess.Popen(process_name)\n        return f\"Process found. Restarting {process_name}.\"\n\n# Example usage:\nif __name__ == \"__main__\":\n    process_name = \"your_process_name_here\"  # Replace with the actual process name\n    result = task_func(process_name)\n    print(result)\n```\n\n### Explanation:\n1. **Imports**: The code imports the necessary modules: `subprocess` for starting processes, `psutil` for checking running processes, and `time` for optional delays.\n2. **Function Definition**: The function `task_func` takes a `process_name` as an argument.\n3. **Process Check**: It iterates through all running processes to check if the specified process is running.\n4. **Starting the Process**: If the process is not found, it starts the process using `subprocess.Popen`.\n5. **Restarting the Process**: If the process is found, it terminates the process and then starts it again.\n6. **Return Messages**: The function returns a message indicating whether the process was started or restarted.\n7. **Example Usage**: The code includes an example usage section where you can specify the process name to test the function.\n\nMake sure to replace `\"your_process_name_here\"` with the actual name of the process you want to manage."}
{"task_id": "BigCodeBench/19", "solution": "Here's the self-contained code that fulfills the requirements specified in your problem statement:\n\n```python\nimport os\nimport glob\nimport zipfile\n\ndef task_func(directory):\n    # Check if the specified directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"The specified directory '{directory}' does not exist.\")\n    \n    # Use glob to find all files in the specified directory (not including subdirectories)\n    file_pattern = os.path.join(directory, '*')\n    files = glob.glob(file_pattern)\n    \n    # Filter out directories, keeping only files\n    files = [f for f in files if os.path.isfile(f)]\n    \n    # If there are no files, return None\n    if not files:\n        return None\n    \n    # Define the path for the zip file\n    zip_file_path = os.path.join(directory, 'files.zip')\n    \n    # Create a zip file and add the files to it\n    with zipfile.ZipFile(zip_file_path, 'w') as zip_file:\n        for file in files:\n            zip_file.write(file, os.path.basename(file))\n    \n    # Return the path to the created zip file\n    return zip_file_path\n```\n\n### Explanation:\n1. **Directory Existence Check**: The function first checks if the specified directory exists. If not, it raises a `FileNotFoundError`.\n2. **File Collection**: It uses `glob` to collect all files in the directory, filtering out any subdirectories.\n3. **Empty Directory Handling**: If no files are found, the function returns `None`.\n4. **Zip File Creation**: If files are found, it creates a zip file named `files.zip` in the specified directory and adds the files to it.\n5. **Return Value**: Finally, it returns the path to the created zip file."}
{"task_id": "BigCodeBench/34", "solution": "Here's a self-contained code snippet that fulfills the requirements of your problem statement:\n\n```python\nimport re\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\n\ndef task_func(text):\n    # Remove URLs from the text\n    text_without_urls = re.sub(r'http\\S+|www\\S+|https\\S+', '', text, flags=re.MULTILINE)\n    \n    # Split the text into words and filter out empty strings\n    words = text_without_urls.split()\n    \n    # Check if there are no words left to generate a word cloud\n    if not words:\n        raise ValueError(\"No words available to generate a word cloud after removing URLs.\")\n    \n    # Generate the word cloud\n    wordcloud = WordCloud(width=800, height=400, background_color='white').generate(' '.join(words))\n    \n    # Plot the word cloud\n    plt.figure(figsize=(10, 5))\n    plt.imshow(wordcloud, interpolation='bilinear')\n    plt.axis('off')  # Hide the axes\n    plt.show()\n    \n    return wordcloud\n\n# Example usage:\n# text = \"Here is a link to my website: https://example.com and some text.\"\n# task_func(text)\n```\n\n### Explanation:\n1. **URL Removal**: The function uses a regular expression to remove URLs from the input text.\n2. **Word Check**: After removing URLs, it checks if there are any words left. If not, it raises a `ValueError`.\n3. **Word Cloud Generation**: If there are words available, it generates a word cloud using the `WordCloud` class.\n4. **Plotting**: The generated word cloud is plotted using `matplotlib`.\n5. **Return Value**: The function returns the `WordCloud` object.\n\nYou can uncomment the example usage at the bottom to test the function with a sample text."}
{"task_id": "BigCodeBench/37", "solution": "Here's a self-contained code snippet that fulfills the requirements of your problem statement. This function trains a Random Forest classifier on the provided DataFrame and plots the feature importances.\n\n```python\nfrom sklearn.ensemble import RandomForestClassifier\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef task_func(df, target_column):\n    # Separate features and target variable\n    X = df.drop(columns=[target_column])\n    y = df[target_column]\n    \n    # Initialize and train the Random Forest Classifier\n    clf = RandomForestClassifier(random_state=42)\n    clf.fit(X, y)\n    \n    # Get feature importances\n    feature_importances = clf.feature_importances_\n    \n    # Create a DataFrame for feature importances\n    importance_df = pd.DataFrame({\n        'Feature': X.columns,\n        'Importance': feature_importances\n    })\n    \n    # Sort the DataFrame by importance\n    importance_df = importance_df.sort_values(by='Importance', ascending=False)\n    \n    # Plotting\n    plt.figure(figsize=(10, 6))\n    sns.barplot(x='Importance', y='Feature', data=importance_df)\n    plt.xlabel('Feature Importance Score')\n    plt.ylabel('Features')\n    plt.title('Visualizing Important Features')\n    plt.show()\n    \n    # Return the trained classifier and the Axes object\n    ax = plt.gca()  # Get the current Axes object\n    return clf, ax\n\n# Example usage:\n# import pandas as pd\n# df = pd.read_csv('your_data.csv')  # Load your DataFrame\n# trained_classifier, axes = task_func(df, 'target_column_name')\n```\n\n### Explanation:\n1. **Data Preparation**: The function separates the features (X) from the target variable (y) based on the specified `target_column`.\n2. **Model Training**: A `RandomForestClassifier` is initialized and trained on the data.\n3. **Feature Importance Extraction**: The feature importances are extracted from the trained model and stored in a DataFrame.\n4. **Sorting**: The DataFrame is sorted by importance in descending order.\n5. **Plotting**: A bar plot is created using Seaborn to visualize the feature importances, with appropriate labels and title.\n6. **Return Values**: The function returns the trained classifier and the Axes object of the plot.\n\nMake sure to replace `'your_data.csv'` and `'target_column_name'` with your actual data file and target column name when using the function."}
{"task_id": "BigCodeBench/82", "solution": "Here's a self-contained Flask application that implements user authentication using Flask-Login and Flask-WTF. The application includes routes for login, logout, and a protected page, along with a simple User class for managing user authentication.\n\n```python\nfrom flask import Flask, render_template, redirect, url_for, flash\nfrom flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Length\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n# User class to represent a user\nclass User(UserMixin):\n    def __init__(self, id, username, password):\n        self.id = id\n        self.username = username\n        self.password = generate_password_hash(password)\n\n# In-memory user storage for demonstration purposes\nusers = {\n    'testuser': User(id=1, username='testuser', password='testpassword')\n}\n\n# Flask-WTF form for login\nclass LoginForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=25)])\n    password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=80)])\n    submit = SubmitField('Log In')\n\n# Initialize Flask app and LoginManager\ndef task_func(secret_key, template_folder):\n    app = Flask(__name__, template_folder=template_folder)\n    app.secret_key = secret_key\n    login_manager = LoginManager()\n    login_manager.init_app(app)\n    login_manager.login_view = 'login'\n\n    @login_manager.user_loader\n    def load_user(user_id):\n        for user in users.values():\n            if user.id == int(user_id):\n                return user\n        return None\n\n    @app.route('/login', methods=['GET', 'POST'])\n    def login():\n        form = LoginForm()\n        if form.validate_on_submit():\n            user = users.get(form.username.data)\n            if user and check_password_hash(user.password, form.password.data):\n                login_user(user)\n                return redirect(url_for('protected'))\n            else:\n                flash('Invalid username or password')\n        return render_template('login.html', form=form)\n\n    @app.route('/logout')\n    @login_required\n    def logout():\n        logout_user()\n        return redirect(url_for('login'))\n\n    @app.route('/protected')\n    @login_required\n    def protected():\n        return f'Hello, {current_user.username}! This is a protected page.'\n\n    return app\n\n# Example usage\nif __name__ == '__main__':\n    app = task_func(secret_key='your_secret_key', template_folder='templates')\n    app.run(debug=True)\n```\n\n### Explanation:\n1. **User Class**: A simple `User` class that implements `UserMixin` from Flask-Login. It includes a constructor to initialize user attributes and hash the password.\n\n2. **In-Memory User Storage**: A dictionary `users` is used to store user instances for demonstration purposes.\n\n3. **Login Form**: A `LoginForm` class is defined using Flask-WTF to handle user input for login.\n\n4. **Flask Application**: The `task_func` function initializes a Flask application with a secret key and template folder. It sets up Flask-Login and defines routes for login, logout, and a protected page.\n\n5. **Routes**:\n   - `/login`: Displays the login form and handles login logic.\n   - `/logout`: Logs the user out and redirects to the login page.\n   - `/protected`: A protected route that can only be accessed by logged-in users.\n\n6. **Running the Application**: The application can be run directly, and it will listen for incoming requests.\n\n### Note:\nMake sure to create a `templates` folder with a `login.html` file to render the login form. Here's a simple example of what `login.html` could look like:\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Login</title>\n</head>\n<body>\n    <h1>Login</h1>\n    <form method=\"POST\">\n        {{ form.hidden_tag() }}\n        <p>\n            {{ form.username.label }}<br>\n            {{ form.username(size=32) }}<br>\n            {% for error in form.username.errors %}\n                <span style=\"color: red;\">[{{ error }}]</span>\n            {% endfor %}\n        </p>\n        <p>\n            {{ form.password.label }}<br>\n            {{ form.password(size=32) }}<br>\n            {% for error in form.password.errors %}\n                <span style=\"color: red;\">[{{ error }}]</span>\n            {% endfor %}\n        </p>\n        <p>{{ form.submit() }}</p>\n    </form>\n    <p><a href=\"{{ url_for('logout') }}\">Logout</a></p>\n</body>\n</html>\n```\n\nThis code provides a complete example of a Flask application with user authentication."}
{"task_id": "BigCodeBench/89", "solution": "Here's a self-contained Python function that identifies and removes outliers from a specified column of a dataset based on the Z-score. It also visualizes the data before and after outlier removal using scatter plots.\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nimport pandas as pd\n\ndef task_func(data, column, outlier_z_score):\n    # Ensure the column exists in the DataFrame\n    if column not in data.columns:\n        raise ValueError(f\"Column '{column}' does not exist in the DataFrame.\")\n    \n    # Standardize the column\n    scaler = StandardScaler()\n    data[column] = scaler.fit_transform(data[[column]])\n    \n    # Calculate Z-scores\n    z_scores = np.abs(stats.zscore(data[column]))\n    \n    # Identify outliers\n    outlier_indices = np.where(z_scores > outlier_z_score)[0]\n    \n    # Remove outliers\n    data_without_outliers = data.drop(index=outlier_indices).reset_index(drop=True)\n    \n    # Visualize the data\n    plt.figure(figsize=(12, 6))\n\n    # Scatter plot of data with outliers\n    plt.subplot(1, 2, 1)\n    plt.scatter(data.index, data[column], color='blue', label='Data with Outliers')\n    plt.axhline(y=outlier_z_score, color='red', linestyle='--', label='Z-score Threshold')\n    plt.axhline(y=-outlier_z_score, color='red', linestyle='--')\n    plt.title('Data with Outliers')\n    plt.xlabel('Index')\n    plt.ylabel(column)\n    plt.legend()\n\n    # Scatter plot of data without outliers\n    plt.subplot(1, 2, 2)\n    plt.scatter(data_without_outliers.index, data_without_outliers[column], color='green', label='Data without Outliers')\n    plt.title('Data without Outliers')\n    plt.xlabel('Index')\n    plt.ylabel(column)\n    plt.legend()\n\n    plt.tight_layout()\n    plt.show()\n\n    # Return the original data, data without outliers, and indices of outliers\n    return (data, data_without_outliers, outlier_indices)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a sample DataFrame\n    np.random.seed(0)\n    sample_data = pd.DataFrame({\n        'A': np.random.normal(0, 1, 100),\n        'B': np.random.normal(0, 1, 100)\n    })\n    # Introduce some outliers\n    sample_data.loc[::10, 'A'] = sample_data['A'] * 10\n\n    # Call the function\n    original_data, cleaned_data, outliers = task_func(sample_data, 'A', 3)\n```\n\n### Explanation:\n1. **Imports**: The necessary libraries are imported, including `numpy`, `matplotlib`, `scipy`, and `pandas`.\n2. **Function Definition**: The function `task_func` takes three parameters: the dataset (`data`), the column to analyze (`column`), and the Z-score threshold (`outlier_z_score`).\n3. **Standardization**: The specified column is standardized using `StandardScaler`.\n4. **Z-score Calculation**: The Z-scores are calculated for the standardized column.\n5. **Outlier Identification**: Outliers are identified based on the Z-score threshold.\n6. **Outlier Removal**: The outliers are removed from the dataset.\n7. **Visualization**: Two scatter plots are created to visualize the data with and without outliers.\n8. **Return Statement**: The function returns a tuple containing the original data, the cleaned data, and the indices of the outliers.\n\n### Example Usage:\nAn example usage is provided in the `if __name__ == \"__main__\":` block, where a sample DataFrame is created, and the function is called to demonstrate its functionality."}
{"task_id": "BigCodeBench/92", "solution": "Here's the self-contained code that performs K-means clustering on a dataset and generates a scatter plot visualizing the clusters and their centroids. The function includes the necessary exception handling as specified:\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nimport numpy as np\n\ndef task_func(data, n_clusters=3):\n    # Validate input types\n    if not isinstance(data, pd.DataFrame):\n        raise ValueError(\"Input 'data' must be a pandas DataFrame.\")\n    if not isinstance(n_clusters, int) or n_clusters <= 1:\n        raise ValueError(\"'n_clusters' must be an integer greater than 1.\")\n    \n    # Perform K-means clustering\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n    cluster_labels = kmeans.fit_predict(data)\n    \n    # Plotting the clusters and centroids\n    plt.figure(figsize=(10, 6))\n    scatter = plt.scatter(data.iloc[:, 0], data.iloc[:, 1], c=cluster_labels, cmap='viridis', marker='o', edgecolor='k')\n    \n    # Plot centroids\n    centroids = kmeans.cluster_centers_\n    plt.scatter(centroids[:, 0], centroids[:, 1], c='red', marker='X', s=200, label='Centroids')\n    \n    plt.title('K-means Clustering')\n    plt.xlabel('Feature 1')\n    plt.ylabel('Feature 2')\n    plt.legend()\n    plt.grid(True)\n    \n    # Return the cluster labels and the Axes object\n    return cluster_labels, plt.gca()\n\n# Example usage (uncomment to run):\n# data = pd.DataFrame({\n#     'Feature 1': np.random.rand(100),\n#     'Feature 2': np.random.rand(100)\n# })\n# labels, ax = task_func(data, n_clusters=3)\n# plt.show()\n```\n\n### Explanation:\n1. **Input Validation**: The function checks if `data` is a pandas DataFrame and if `n_clusters` is an integer greater than 1. If not, it raises a `ValueError`.\n2. **K-means Clustering**: It uses the `KMeans` class from `sklearn.cluster` to fit the model and predict cluster labels.\n3. **Plotting**: It creates a scatter plot of the data points colored by their cluster labels and marks the centroids with red 'X' markers.\n4. **Return Values**: The function returns a tuple containing the cluster labels and the Axes object of the plot.\n\nYou can uncomment the example usage section to test the function with random data."}
{"task_id": "BigCodeBench/93", "solution": "```python\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\n\ndef task_func(data, n_components=2):\n    # Validate n_components\n    if not isinstance(n_components, int) or n_components <= 0:\n        raise ValueError(\"n_components must be a positive integer.\")\n    \n    # Standardize the data (important for PCA)\n    data_standardized = (data - data.mean()) / data.std()\n    \n    # Perform PCA\n    pca = PCA(n_components=n_components)\n    principal_components = pca.fit_transform(data_standardized)\n    \n    # Create a DataFrame for the transformed data\n    columns = [f'Principal Component {i+1}' for i in range(n_components)]\n    transformed_data = pd.DataFrame(data=principal_components, columns=columns)\n    \n    # Generate scatter plot\n    fig, ax = plt.subplots()\n    ax.scatter(transformed_data.iloc[:, 0], transformed_data.iloc[:, 1], alpha=0.5)\n    ax.set_xlabel('Principal Component 1')\n    ax.set_ylabel('Principal Component 2')\n    ax.set_title('PCA Result')\n    \n    # Return the transformed data and the Axes object\n    return transformed_data, ax\n\n# Example usage:\n# Assuming you have a DataFrame `df` with your data\n# df = pd.DataFrame(...)  # Your data here\n# transformed_data, ax = task_func(df, n_components=2)\n# plt.show()  # To display the plot\n``` \n\nThis code defines a function `task_func` that performs PCA on the provided dataset, checks for valid `n_components`, standardizes the data, and generates a scatter plot of the first two principal components. The function returns the transformed data as a DataFrame and the Axes object for the plot."}
{"task_id": "BigCodeBench/99", "solution": "Here's the self-contained code that meets your requirements:\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nfrom sklearn.datasets import load_iris\n\ndef task_func():\n    # Set the global font to Arial\n    plt.rcParams['font.family'] = 'Arial'\n    \n    # Load the iris dataset\n    iris = load_iris()\n    iris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)\n    iris_df['species'] = iris.target_names[iris.target]\n    \n    # Create a pair plot\n    pair_plot = sns.pairplot(iris_df, hue='species', markers=[\"o\", \"s\", \"D\"])\n    \n    # Set the title\n    plt.suptitle('Iris Dataset Pair Plot', y=1.02)\n    \n    # Show the plot\n    plt.show()\n    \n    return pair_plot.fig\n\n# Call the function to generate the plot\nfig = task_func()\n```\n\n### Explanation:\n1. **Imports**: The necessary libraries are imported: `matplotlib.pyplot`, `pandas`, `seaborn`, and `load_iris` from `sklearn.datasets`.\n2. **Function Definition**: The function `task_func()` is defined.\n3. **Font Setting**: The global font is set to Arial using `plt.rcParams`.\n4. **Data Loading**: The iris dataset is loaded and converted into a pandas DataFrame. The species names are added as a new column.\n5. **Pair Plot Creation**: A pair plot is created using `seaborn.pairplot()`, with different markers for each species.\n6. **Title Setting**: The title of the plot is set using `plt.suptitle()`.\n7. **Plot Display**: The plot is displayed using `plt.show()`.\n8. **Return Statement**: The function returns the figure object of the pair plot.\n\nYou can run this code in a Python environment with the required libraries installed to visualize the pair plot of the iris dataset."}
