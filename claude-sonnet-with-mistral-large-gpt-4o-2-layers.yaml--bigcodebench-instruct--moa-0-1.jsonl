{"task_id": "BigCodeBench/0", "solution": "Here's the self-contained code that calculates the average of the sums of absolute differences between each pair of consecutive numbers for all permutations of a given list, with each permutation being shuffled before calculating the differences:\n\n```python\nimport itertools\nfrom random import shuffle\n\ndef task_func(numbers=list(range(1, 3))):\n    def sum_abs_diff(lst):\n        return sum(abs(lst[i] - lst[i-1]) for i in range(1, len(lst)))\n    \n    total_sum = 0\n    count = 0\n    \n    for perm in itertools.permutations(numbers):\n        shuffled = list(perm)\n        shuffle(shuffled)\n        total_sum += sum_abs_diff(shuffled)\n        count += 1\n    \n    return total_sum / count if count > 0 else 0.0\n\n# Example usage\nprint(task_func())  # Using default [1, 2]\nprint(task_func(list(range(1, 11))))  # Using numbers from 1 to 10\n```\n\nThis implementation does the following:\n\n1. We define a helper function `sum_abs_diff` inside `task_func` to calculate the sum of absolute differences between consecutive numbers in a list.\n\n2. We initialize `total_sum` to keep track of the sum of all differences and `count` to keep track of the number of permutations.\n\n3. We use `itertools.permutations(numbers)` to generate all possible permutations of the input list.\n\n4. For each permutation:\n   - We convert it to a list and shuffle it using `random.shuffle`.\n   - We calculate the sum of absolute differences for this shuffled permutation using our helper function.\n   - We add this sum to `total_sum` and increment `count`.\n\n5. Finally, we return the average by dividing `total_sum` by `count`. If `count` is zero (which would only happen with an empty input list), we return 0.0 to avoid division by zero.\n\nThis function fulfills all the requirements:\n- It uses the specified imports and function signature.\n- It handles the default case of `[1, 2]` as well as custom inputs.\n- It shuffles each permutation before calculating differences.\n- It returns a float representing the average of all sums of absolute differences.\n- It's self-contained and ready to use.\n\nYou can call this function with different inputs to get the desired average. For example, `task_func(list(range(1, 11)))` will use the numbers from 1 to 10 as requested in the original description."}
{"task_id": "BigCodeBench/1", "solution": "Here's a self-contained Python function that generates a random string of the specified length composed of uppercase and lowercase letters, counts the occurrence of each character, and returns the result as a dictionary. The function also raises a ValueError if the length is negative:\n\n```python\nimport collections\nimport random\nimport string\n\ndef task_func(length=100):\n    if length < 0:\n        raise ValueError(\"Length must be a non-negative integer\")\n    \n    # Generate a random string of specified length\n    random_string = ''.join(random.choices(string.ascii_letters, k=length))\n    \n    # Count occurrences of each character\n    char_counts = collections.Counter(random_string)\n    \n    return dict(char_counts)\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        result = task_func(50)\n        print(\"Character counts for a random string of length 50:\")\n        print(result)\n        \n        # Test with default length\n        result = task_func()\n        print(\"\\nCharacter counts for a random string of default length (100):\")\n        print(result)\n        \n        # Test with length 0\n        result = task_func(0)\n        print(\"\\nCharacter counts for an empty string (length 0):\")\n        print(result)\n        \n        # Test with negative length (should raise ValueError)\n        task_func(-10)\n    except ValueError as e:\n        print(f\"\\nValueError caught: {e}\")\n```\n\nThis implementation does the following:\n\n1. It defines the `task_func` with a default length of 100.\n2. It checks if the length is negative and raises a `ValueError` if so.\n3. It generates a random string using `random.choices` from `string.ascii_letters`, which includes both uppercase and lowercase letters.\n4. It uses `collections.Counter` to count the occurrences of each character in the string.\n5. It returns the result as a dictionary.\n\nThe example usage demonstrates how to use the function with different inputs, including:\n- A custom length (50)\n- The default length (100)\n- A length of 0 (which should return an empty dictionary)\n- A negative length (which should raise a ValueError)\n\nThis implementation is efficient, using built-in Python libraries to handle the random string generation and character counting. It's also flexible, allowing for any non-negative integer length, and properly handles edge cases like zero length and negative inputs."}
{"task_id": "BigCodeBench/2", "solution": "Here's a self-contained Python function that creates a dictionary with random letters as keys and lists of random integers as values, then sorts it by the mean of the values in descending order using the statistics library:\n\n```python\nimport random\nimport statistics\n\ndef task_func(LETTERS):\n    # Create dictionary with random letters as keys and lists of random integers as values\n    letter_dict = {letter: [random.randint(1, 100) for _ in range(random.randint(3, 10))] for letter in LETTERS}\n    \n    # Sort the dictionary by the mean of the values in descending order\n    sorted_dict = dict(sorted(letter_dict.items(), key=lambda x: statistics.mean(x[1]), reverse=True))\n    \n    return sorted_dict\n\n# Example usage\nif __name__ == \"__main__\":\n    # Generate a sample of random uppercase letters\n    LETTERS = random.sample(string.ascii_uppercase, 5)\n    result = task_func(LETTERS)\n    print(\"Sorted Dictionary:\")\n    for letter, numbers in result.items():\n        print(f\"{letter}: {numbers} (Mean: {statistics.mean(numbers):.2f})\")\n```\n\nThis code does the following:\n\n1. We define the `task_func(LETTERS)` function that takes a list of letters as input.\n\n2. Inside the function, we create a dictionary `letter_dict` using a dictionary comprehension:\n   - Each key is a letter from the input `LETTERS`.\n   - Each value is a list of random integers between 1 and 100.\n   - The length of each list is randomly chosen between 3 and 10.\n\n3. We then sort the dictionary by the mean of the values in descending order:\n   - We use the `sorted()` function with a `key` parameter that uses `statistics.mean()` to calculate the mean of each value list.\n   - The `reverse=True` argument ensures descending order.\n\n4. The sorted dictionary is converted back to a regular dictionary and returned.\n\n5. In the example usage section:\n   - We generate a sample of 5 random uppercase letters using `random.sample()` and `string.ascii_uppercase`.\n   - We call `task_func()` with these letters and store the result.\n   - We print the sorted dictionary, showing each letter, its list of numbers, and the mean of those numbers.\n\nThis implementation provides a clear and efficient solution to the task, demonstrating the use of the `statistics` library for calculating means and the `sorted()` function with a custom key for sorting dictionaries based on their values."}
{"task_id": "BigCodeBench/3", "solution": "Here's a self-contained function that meets your requirements:\n\n```python\nimport random\nimport numpy as np\n\ndef task_func(LETTERS):\n    # Initialize the dictionary to store random lists of integers\n    random_dict = {}\n    \n    # Generate random lists for each specified letter\n    for letter in LETTERS:\n        list_length = random.randint(1, 10)\n        random_list = [random.randint(0, 100) for _ in range(list_length)]\n        random_dict[letter] = random_list\n    \n    # Calculate the mean of the integers for each key\n    mean_dict = {letter: np.mean(integers) for letter, integers in random_dict.items()}\n    \n    return mean_dict\n\n# Example usage:\n# LETTERS = ['a', 'b', 'c']\n# result = task_func(LETTERS)\n# print(result)\n```\n\nThis function does the following:\n\n1. It takes a list of letters (`LETTERS`) as input.\n\n2. It initializes an empty dictionary `random_dict` to store the random lists of integers for each letter.\n\n3. For each letter in `LETTERS`:\n   - It generates a random list length between 1 and 10.\n   - It creates a list of random integers (each between 0 and 100) of that length.\n   - It stores this list in `random_dict` with the letter as the key.\n\n4. It then creates a new dictionary `mean_dict` using a dictionary comprehension:\n   - For each letter and list of integers in `random_dict`, it calculates the mean of the integers using `np.mean()`.\n   - It stores this mean in `mean_dict` with the letter as the key.\n\n5. Finally, it returns `mean_dict`.\n\nThe function is self-contained and includes the necessary imports. It will output a dictionary where each key is a letter from the input list, and each value is the mean of a randomly generated list of integers (with each list having 1 to 10 integers ranging from 0 to 100).\n\nTo use this function, you would call it with a list of letters, like this:\n\n```python\nLETTERS = ['a', 'b', 'c']\nresult = task_func(LETTERS)\nprint(result)\n```\n\nThis might output something like:\n\n```\n{'a': 45.6, 'b': 62.25, 'c': 50.8}\n```\n\nNote that due to the random nature of the function, your actual output will vary each time you run it."}
{"task_id": "BigCodeBench/4", "solution": "Here's a self-contained implementation of the function that counts the occurrence of each integer in the values of the input dictionary:\n\n```python\nfrom collections import Counter\nimport itertools\n\ndef task_func(d):\n    # Flatten all lists in the dictionary values into a single iterable\n    all_numbers = itertools.chain.from_iterable(d.values())\n    \n    # Use Counter to count occurrences of each integer\n    counts = Counter(all_numbers)\n    \n    # Return the Counter object as a dictionary\n    return dict(counts)\n\n# Example usage:\ninput_dict = {\n    'a': [1, 2, 2, 3],\n    'b': [2, 3, 3, 4],\n    'c': [4, 4, 4]\n}\n\nresult = task_func(input_dict)\nprint(result)  # Output: {1: 1, 2: 3, 3: 3, 4: 4}\n```\n\nThis implementation efficiently solves the problem using the following steps:\n\n1. We use `itertools.chain.from_iterable(d.values())` to flatten all the lists in the dictionary values into a single iterable. This combines all the integers from all lists into one sequence.\n\n2. We then use the `Counter` class from the `collections` module to count the occurrences of each integer in this flattened sequence. The `Counter` object is a specialized dictionary-like class that's perfect for counting hashable objects (like integers in this case).\n\n3. Finally, we convert the `Counter` object to a regular dictionary using `dict(counts)` and return it. This step isn't strictly necessary since `Counter` is a subclass of `dict`, but it ensures the return type is exactly as specified.\n\nThe resulting dictionary will have integers as keys and their respective counts across all lists as values. In the example usage, we can see that:\n- 1 appears once\n- 2 appears three times\n- 3 appears three times\n- 4 appears four times\n\nThis solution is both efficient and concise, making use of Python's built-in tools to handle the counting and flattening operations."}
{"task_id": "BigCodeBench/5", "solution": "Here's a self-contained Python function that meets the requirements you've described:\n\n```python\nimport random\nimport math\n\ndef task_func(LETTERS=[chr(i) for i in range(97, 123)]):\n    def generate_random_list():\n        return [random.randint(0, 100) for _ in range(random.randint(1, 10))]\n    \n    def calculate_population_stddev(numbers):\n        if len(numbers) == 0:\n            return 0\n        mean = sum(numbers) / len(numbers)\n        variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)\n        return math.sqrt(variance)\n    \n    # Create a dictionary with random integer lists for each letter\n    random_dict = {letter: generate_random_list() for letter in LETTERS}\n    \n    # Calculate the population standard deviation for each list\n    stddev_dict = {letter: calculate_population_stddev(numbers) for letter, numbers in random_dict.items()}\n    \n    return stddev_dict\n\n# Example usage\nif __name__ == \"__main__\":\n    result = task_func()\n    for letter, stddev in result.items():\n        print(f\"{letter}: {stddev:.4f}\")\n```\n\nThis code does the following:\n\n1. The `task_func` takes an optional parameter `LETTERS`, which defaults to a list of lowercase letters from 'a' to 'z'.\n\n2. Inside `task_func`, we define two helper functions:\n   - `generate_random_list()`: Creates a list of 1 to 10 random integers between 0 and 100.\n   - `calculate_population_stddev(numbers)`: Calculates the population standard deviation of a given list of numbers.\n\n3. We create `random_dict` where each key is a letter from `LETTERS`, and each value is a list of random integers generated by `generate_random_list()`.\n\n4. We then create `stddev_dict` by calculating the population standard deviation for each list in `random_dict`.\n\n5. Finally, we return `stddev_dict`, which contains the letters as keys and their corresponding population standard deviations as values.\n\nThe example usage demonstrates how to call the function and print the results. When you run this code, it will output a dictionary where each key is a letter, and each value is the population standard deviation of the randomly generated list for that letter.\n\nThis implementation is efficient, readable, and fully meets the specified requirements. It generates random lists, calculates standard deviations, and returns the results in the desired format."}
